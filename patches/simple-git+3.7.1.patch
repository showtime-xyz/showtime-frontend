diff --git a/node_modules/simple-git/dist/cjs/index.js b/node_modules/simple-git/dist/cjs/index.js
index f01617a..445e380 100644
--- a/node_modules/simple-git/dist/cjs/index.js
+++ b/node_modules/simple-git/dist/cjs/index.js
@@ -441,9 +441,9 @@ var init_task_options = __esm({
 function callTaskParser(parser3, streams) {
   return parser3(streams.stdOut, streams.stdErr);
 }
-function parseStringResponse(result, parsers11, texts, trim = true) {
-  asArray(texts).forEach((text) => {
-    for (let lines = toLinesWithContent(text, trim), i = 0, max = lines.length; i < max; i++) {
+function parseStringResponse(result, parsers11, ...texts) {
+  texts.forEach((text) => {
+    for (let lines = toLinesWithContent(text), i = 0, max = lines.length; i < max; i++) {
       const line = (offset = 0) => {
         if (i + offset >= max) {
           return;
@@ -1905,26 +1905,6 @@ var init_init = __esm({
   }
 });
 
-// src/lib/args/log-format.ts
-function logFormatFromCommand(customArgs) {
-  for (let i = 0; i < customArgs.length; i++) {
-    const format = logFormatRegex.exec(customArgs[i]);
-    if (format) {
-      return `--${format[1]}`;
-    }
-  }
-  return "" /* NONE */;
-}
-function isLogFormat(customArg) {
-  return logFormatRegex.test(customArg);
-}
-var logFormatRegex;
-var init_log_format = __esm({
-  "src/lib/args/log-format.ts"() {
-    logFormatRegex = /^--(stat|numstat|name-only|name-status)(=|$)/;
-  }
-});
-
 // src/lib/responses/DiffSummary.ts
 var DiffSummary;
 var init_DiffSummary = __esm({
@@ -1941,97 +1921,74 @@ var init_DiffSummary = __esm({
 });
 
 // src/lib/parsers/parse-diff-summary.ts
-function getDiffParser(format = "" /* NONE */) {
-  const parser3 = diffSummaryParsers[format];
-  return (stdOut) => parseStringResponse(new DiffSummary(), parser3, stdOut, false);
+function parseDiffResult(stdOut) {
+  const lines = stdOut.trim().split("\n");
+  const status = new DiffSummary();
+  readSummaryLine(status, lines.pop());
+  for (let i = 0, max = lines.length; i < max; i++) {
+    const line = lines[i];
+    textFileChange(line, status) || binaryFileChange(line, status);
+  }
+  return status;
+}
+function readSummaryLine(status, summary) {
+  (summary || "").trim().split(", ").forEach(function(text) {
+    const summary2 = /(\d+)\s([a-z]+)/.exec(text);
+    if (!summary2) {
+      return;
+    }
+    summaryType(status, summary2[2], parseInt(summary2[1], 10));
+  });
 }
-var statParser, numStatParser, nameOnlyParser, nameStatusParser, diffSummaryParsers;
+function summaryType(status, key, value) {
+  const match = /([a-z]+?)s?\b/.exec(key);
+  if (!match || !statusUpdate[match[1]]) {
+    return;
+  }
+  statusUpdate[match[1]](status, value);
+}
+function textFileChange(input, { files }) {
+  const line = input.trim().match(/^(.+)\s+\|\s+(\d+)(\s+[+\-]+)?$/);
+  if (line) {
+    var alterations = (line[3] || "").trim();
+    files.push({
+      file: line[1].trim(),
+      changes: parseInt(line[2], 10),
+      insertions: alterations.replace(/-/g, "").length,
+      deletions: alterations.replace(/\+/g, "").length,
+      binary: false
+    });
+    return true;
+  }
+  return false;
+}
+function binaryFileChange(input, { files }) {
+  const line = input.match(/^(.+) \|\s+Bin ([0-9.]+) -> ([0-9.]+) ([a-z]+)$/);
+  if (line) {
+    files.push({
+      file: line[1].trim(),
+      before: +line[2],
+      after: +line[3],
+      binary: true
+    });
+    return true;
+  }
+  return false;
+}
+var statusUpdate;
 var init_parse_diff_summary = __esm({
   "src/lib/parsers/parse-diff-summary.ts"() {
-    init_log_format();
     init_DiffSummary();
-    init_utils();
-    statParser = [
-      new LineParser(/(.+)\s+\|\s+(\d+)(\s+[+\-]+)?$/, (result, [file, changes, alterations = ""]) => {
-        result.files.push({
-          file: file.trim(),
-          changes: asNumber(changes),
-          insertions: alterations.replace(/[^+]/g, "").length,
-          deletions: alterations.replace(/[^-]/g, "").length,
-          binary: false
-        });
-      }),
-      new LineParser(/(.+) \|\s+Bin ([0-9.]+) -> ([0-9.]+) ([a-z]+)/, (result, [file, before, after]) => {
-        result.files.push({
-          file: file.trim(),
-          before: asNumber(before),
-          after: asNumber(after),
-          binary: true
-        });
-      }),
-      new LineParser(/(\d+) files? changed\s*((?:, \d+ [^,]+){0,2})/, (result, [changed, summary]) => {
-        const inserted = /(\d+) i/.exec(summary);
-        const deleted = /(\d+) d/.exec(summary);
-        result.changed = asNumber(changed);
-        result.insertions = asNumber(inserted == null ? void 0 : inserted[1]);
-        result.deletions = asNumber(deleted == null ? void 0 : deleted[1]);
-      })
-    ];
-    numStatParser = [
-      new LineParser(/(\d+)\t(\d+)\t(.+)$/, (result, [changesInsert, changesDelete, file]) => {
-        const insertions = asNumber(changesInsert);
-        const deletions = asNumber(changesDelete);
-        result.changed++;
-        result.insertions += insertions;
-        result.deletions += deletions;
-        result.files.push({
-          file,
-          changes: insertions + deletions,
-          insertions,
-          deletions,
-          binary: false
-        });
-      }),
-      new LineParser(/-\t-\t(.+)$/, (result, [file]) => {
-        result.changed++;
-        result.files.push({
-          file,
-          after: 0,
-          before: 0,
-          binary: true
-        });
-      })
-    ];
-    nameOnlyParser = [
-      new LineParser(/(.+)$/, (result, [file]) => {
-        result.changed++;
-        result.files.push({
-          file,
-          changes: 0,
-          insertions: 0,
-          deletions: 0,
-          binary: false
-        });
-      })
-    ];
-    nameStatusParser = [
-      new LineParser(/([ACDMRTUXB])\s*(.+)$/, (result, [_status, file]) => {
-        result.changed++;
-        result.files.push({
-          file,
-          changes: 0,
-          insertions: 0,
-          deletions: 0,
-          binary: false
-        });
-      })
-    ];
-    diffSummaryParsers = {
-      ["" /* NONE */]: statParser,
-      ["--stat" /* STAT */]: statParser,
-      ["--numstat" /* NUM_STAT */]: numStatParser,
-      ["--name-status" /* NAME_STATUS */]: nameStatusParser,
-      ["--name-only" /* NAME_ONLY */]: nameOnlyParser
+    statusUpdate = {
+      file(status, value) {
+        status.changed = value;
+      },
+      deletion(status, value) {
+        status.deletions = value;
+      },
+      insertion(status, value) {
+        status.insertions = value;
+      }
     };
   }
 });
@@ -2043,8 +2000,7 @@ function lineBuilder(tokens, fields) {
     return line;
   }, /* @__PURE__ */ Object.create({ diff: null }));
 }
-function createListLogSummaryParser(splitter = SPLITTER, fields = defaultFieldNames, logFormat = "" /* NONE */) {
-  const parseDiffResult = getDiffParser(logFormat);
+function createListLogSummaryParser(splitter = SPLITTER, fields = defaultFieldNames) {
   return function(stdOut) {
     const all = toLinesWithContent(stdOut, true, START_BOUNDARY).map(function(item) {
       const lineDetail = item.trim().split(COMMIT_BOUNDARY);
@@ -2066,7 +2022,6 @@ var init_parse_list_log_summary = __esm({
   "src/lib/parsers/parse-list-log-summary.ts"() {
     init_utils();
     init_parse_diff_summary();
-    init_log_format();
     START_BOUNDARY = "\xF2\xF2\xF2\xF2\xF2\xF2 ";
     COMMIT_BOUNDARY = " \xF2\xF2";
     SPLITTER = " \xF2 ";
@@ -2074,43 +2029,6 @@ var init_parse_list_log_summary = __esm({
   }
 });
 
-// src/lib/tasks/diff.ts
-var diff_exports = {};
-__export(diff_exports, {
-  diffSummaryTask: () => diffSummaryTask,
-  validateLogFormatConfig: () => validateLogFormatConfig
-});
-function diffSummaryTask(customArgs) {
-  let logFormat = logFormatFromCommand(customArgs);
-  const commands = ["diff"];
-  if (logFormat === "" /* NONE */) {
-    logFormat = "--stat" /* STAT */;
-    commands.push("--stat=4096");
-  }
-  commands.push(...customArgs);
-  return validateLogFormatConfig(commands) || {
-    commands,
-    format: "utf-8",
-    parser: getDiffParser(logFormat)
-  };
-}
-function validateLogFormatConfig(customArgs) {
-  const flags = customArgs.filter(isLogFormat);
-  if (flags.length > 1) {
-    return configurationErrorTask(`Summary flags are mutually exclusive - pick one of ${flags.join(",")}`);
-  }
-  if (flags.length && customArgs.includes("-z")) {
-    return configurationErrorTask(`Summary flag ${flags} parsing is not compatible with null termination option '-z'`);
-  }
-}
-var init_diff = __esm({
-  "src/lib/tasks/diff.ts"() {
-    init_log_format();
-    init_parse_diff_summary();
-    init_task();
-  }
-});
-
 // src/lib/tasks/log.ts
 function prettyFormat(format, splitter) {
   const fields = [];
@@ -2171,19 +2089,17 @@ function parseLogOptions(opt = {}, customArgs = []) {
   };
 }
 function logTask(splitter, fields, customArgs) {
-  const parser3 = createListLogSummaryParser(splitter, fields, logFormatFromCommand(customArgs));
   return {
     commands: ["log", ...customArgs],
     format: "utf-8",
-    parser: parser3
+    parser: createListLogSummaryParser(splitter, fields)
   };
 }
 function log_default() {
   return {
     log(...rest) {
       const next = trailingFunctionArgument(arguments);
-      const options = parseLogOptions(trailingOptionsArgument(arguments), filterType(arguments[0], filterArray));
-      const task = rejectDeprecatedSignatures(...rest) || validateLogFormatConfig(options.commands) || createLogTask(options);
+      const task = rejectDeprecatedSignatures(...rest) || createLogTask(parseLogOptions(trailingOptionsArgument(arguments), filterType(arguments[0], filterArray)));
       return this._runTask(task, next);
     }
   };
@@ -2197,11 +2113,9 @@ function log_default() {
 var excludeOptions;
 var init_log = __esm({
   "src/lib/tasks/log.ts"() {
-    init_log_format();
     init_parse_list_log_summary();
     init_utils();
     init_task();
-    init_diff();
     excludeOptions = /* @__PURE__ */ ((excludeOptions2) => {
       excludeOptions2[excludeOptions2["--pretty"] = 0] = "--pretty";
       excludeOptions2[excludeOptions2["max-count"] = 1] = "max-count";
@@ -2378,7 +2292,7 @@ var init_parse_remote_messages = __esm({
 
 // src/lib/parsers/parse-pull.ts
 function parsePullErrorResult(stdOut, stdErr) {
-  const pullError = parseStringResponse(new PullFailedSummary(), errorParsers, [stdOut, stdErr]);
+  const pullError = parseStringResponse(new PullFailedSummary(), errorParsers, stdOut, stdErr);
   return pullError.message && pullError;
 }
 var FILE_UPDATE_REGEX, SUMMARY_REGEX, ACTION_REGEX, parsers3, errorParsers, parsePullDetail, parsePullResult;
@@ -2425,7 +2339,7 @@ var init_parse_pull = __esm({
       })
     ];
     parsePullDetail = (stdOut, stdErr) => {
-      return parseStringResponse(new PullSummary(), parsers3, [stdOut, stdErr]);
+      return parseStringResponse(new PullSummary(), parsers3, stdOut, stdErr);
     };
     parsePullResult = (stdOut, stdErr) => {
       return Object.assign(new PullSummary(), parsePullDetail(stdOut, stdErr), parseRemoteMessages(stdOut, stdErr));
@@ -2549,7 +2463,7 @@ var init_parse_push = __esm({
       return __spreadValues(__spreadValues({}, pushDetail), responseDetail);
     };
     parsePushDetail = (stdOut, stdErr) => {
-      return parseStringResponse({ pushed: [] }, parsers5, [stdOut, stdErr]);
+      return parseStringResponse({ pushed: [] }, parsers5, stdOut, stdErr);
     };
   }
 });
@@ -2968,7 +2882,7 @@ var init_parse_branch_delete = __esm({
       })
     ];
     parseBranchDeletions = (stdOut, stdErr) => {
-      return parseStringResponse(new BranchDeletionBatch(), parsers7, [stdOut, stdErr]);
+      return parseStringResponse(new BranchDeletionBatch(), parsers7, stdOut, stdErr);
     };
   }
 });
@@ -2984,15 +2898,14 @@ var init_BranchSummary = __esm({
         this.current = "";
         this.detached = false;
       }
-      push(status, detached, name, commit, label) {
-        if (status === "*" /* CURRENT */) {
+      push(current, detached, name, commit, label) {
+        if (current) {
           this.detached = detached;
           this.current = name;
         }
         this.all.push(name);
         this.branches[name] = {
-          current: status === "*" /* CURRENT */,
-          linkedWorkTree: status === "+" /* LINKED */,
+          current,
           name,
           commit,
           label
@@ -3003,9 +2916,6 @@ var init_BranchSummary = __esm({
 });
 
 // src/lib/parsers/parse-branch.ts
-function branchStatus(input) {
-  return input ? input.charAt(0) : "";
-}
 function parseBranchSummary(stdOut) {
   return parseStringResponse(new BranchSummaryResult(), parsers8, stdOut);
 }
@@ -3015,11 +2925,11 @@ var init_parse_branch = __esm({
     init_BranchSummary();
     init_utils();
     parsers8 = [
-      new LineParser(/^([*+]\s)?\((?:HEAD )?detached (?:from|at) (\S+)\)\s+([a-z0-9]+)\s(.*)$/, (result, [current, name, commit, label]) => {
-        result.push(branchStatus(current), true, name, commit, label);
+      new LineParser(/^(\*\s)?\((?:HEAD )?detached (?:from|at) (\S+)\)\s+([a-z0-9]+)\s(.*)$/, (result, [current, name, commit, label]) => {
+        result.push(!!current, true, name, commit, label);
       }),
-      new LineParser(/^([*+]\s)?(\S+)\s+([a-z0-9]+)\s?(.*)$/s, (result, [current, name, commit, label]) => {
-        result.push(branchStatus(current), false, name, commit, label);
+      new LineParser(/^(\*\s)?(\S+)\s+([a-z0-9]+)\s?(.*)$/s, (result, [current, name, commit, label]) => {
+        result.push(!!current, false, name, commit, label);
       })
     ];
   }
@@ -3164,6 +3074,26 @@ var init_clone = __esm({
   }
 });
 
+// src/lib/tasks/diff.ts
+var diff_exports = {};
+__export(diff_exports, {
+  diffSummaryTask: () => diffSummaryTask
+});
+function diffSummaryTask(customArgs) {
+  return {
+    commands: ["diff", "--stat=4096", ...customArgs],
+    format: "utf-8",
+    parser(stdOut) {
+      return parseDiffResult(stdOut);
+    }
+  };
+}
+var init_diff = __esm({
+  "src/lib/tasks/diff.ts"() {
+    init_parse_diff_summary();
+  }
+});
+
 // src/lib/parsers/parse-fetch.ts
 function parseFetchResult(stdOut, stdErr) {
   const result = {
@@ -3172,7 +3102,7 @@ function parseFetchResult(stdOut, stdErr) {
     branches: [],
     tags: []
   };
-  return parseStringResponse(result, parsers9, [stdOut, stdErr]);
+  return parseStringResponse(result, parsers9, stdOut, stdErr);
 }
 var parsers9;
 var init_parse_fetch = __esm({
@@ -3380,19 +3310,16 @@ __export(stash_list_exports, {
 });
 function stashListTask(opt = {}, customArgs) {
   const options = parseLogOptions(opt);
-  const commands = ["stash", "list", ...options.commands, ...customArgs];
-  const parser3 = createListLogSummaryParser(options.splitter, options.fields, logFormatFromCommand(commands));
-  return validateLogFormatConfig(commands) || {
-    commands,
+  const parser3 = createListLogSummaryParser(options.splitter, options.fields);
+  return {
+    commands: ["stash", "list", ...options.commands, ...customArgs],
     format: "utf-8",
     parser: parser3
   };
 }
 var init_stash_list = __esm({
   "src/lib/tasks/stash-list.ts"() {
-    init_log_format();
     init_parse_list_log_summary();
-    init_diff();
     init_log();
   }
 });
@@ -3799,8 +3726,10 @@ function esModuleFactory(defaultExport) {
     default: { value: defaultExport }
   });
 }
-function gitExportFactory(factory) {
-  return Object.assign(factory.bind(null), api_exports);
+function gitExportFactory(factory, extra) {
+  return Object.assign(function(...args) {
+    return factory.apply(null, args);
+  }, api_exports, extra || {});
 }
 function gitInstanceFactory(baseDir, options) {
   const plugins = new PluginStore();
@@ -3972,6 +3901,5 @@ var init_promise_wrapped = __esm({
 // src/index.js
 var { gitP: gitP2 } = (init_promise_wrapped(), __toCommonJS(promise_wrapped_exports));
 var { esModuleFactory: esModuleFactory2, gitInstanceFactory: gitInstanceFactory2, gitExportFactory: gitExportFactory2 } = (init_git_factory(), __toCommonJS(git_factory_exports));
-var simpleGit = esModuleFactory2(gitExportFactory2(gitInstanceFactory2));
-module.exports = Object.assign(simpleGit, { gitP: gitP2, simpleGit });
+module.exports = esModuleFactory2(gitExportFactory2(gitInstanceFactory2, { gitP: gitP2 }));
 //# sourceMappingURL=index.js.map
diff --git a/node_modules/simple-git/dist/cjs/index.js.map b/node_modules/simple-git/dist/cjs/index.js.map
index 79a8d8f..2779a93 100644
--- a/node_modules/simple-git/dist/cjs/index.js.map
+++ b/node_modules/simple-git/dist/cjs/index.js.map
@@ -1,7 +1,7 @@
 {
   "version": 3,
-  "sources": ["../../src/lib/errors/git-error.ts", "../../src/lib/errors/git-response-error.ts", "../../src/lib/errors/git-construct-error.ts", "../../src/lib/errors/git-plugin-error.ts", "../../src/lib/errors/task-configuration-error.ts", "../../src/lib/utils/util.ts", "../../src/lib/utils/argument-filters.ts", "../../src/lib/utils/exit-codes.ts", "../../src/lib/utils/git-output-streams.ts", "../../src/lib/utils/line-parser.ts", "../../src/lib/utils/simple-git-options.ts", "../../src/lib/utils/task-options.ts", "../../src/lib/utils/task-parser.ts", "../../src/lib/utils/index.ts", "../../src/lib/tasks/check-is-repo.ts", "../../src/lib/responses/CleanSummary.ts", "../../src/lib/tasks/task.ts", "../../src/lib/tasks/clean.ts", "../../src/lib/responses/ConfigList.ts", "../../src/lib/tasks/config.ts", "../../src/lib/tasks/grep.ts", "../../src/lib/tasks/reset.ts", "../../src/lib/api.ts", "../../src/lib/plugins/command-config-prefixing-plugin.ts", "../../src/lib/plugins/completion-detection.plugin.ts", "../../src/lib/plugins/error-detection.plugin.ts", "../../src/lib/plugins/plugin-store.ts", "../../src/lib/plugins/progress-monitor-plugin.ts", "../../src/lib/plugins/simple-git-plugin.ts", "../../src/lib/plugins/spawn-options-plugin.ts", "../../src/lib/plugins/timout-plugin.ts", "../../src/lib/plugins/index.ts", "../../src/lib/git-logger.ts", "../../src/lib/runners/tasks-pending-queue.ts", "../../src/lib/runners/git-executor-chain.ts", "../../src/lib/runners/git-executor.ts", "../../src/lib/task-callback.ts", "../../src/lib/tasks/change-working-directory.ts", "../../src/lib/parsers/parse-commit.ts", "../../src/lib/tasks/commit.ts", "../../src/lib/tasks/hash-object.ts", "../../src/lib/responses/InitSummary.ts", "../../src/lib/tasks/init.ts", "../../src/lib/args/log-format.ts", "../../src/lib/responses/DiffSummary.ts", "../../src/lib/parsers/parse-diff-summary.ts", "../../src/lib/parsers/parse-list-log-summary.ts", "../../src/lib/tasks/diff.ts", "../../src/lib/tasks/log.ts", "../../src/lib/responses/MergeSummary.ts", "../../src/lib/responses/PullSummary.ts", "../../src/lib/parsers/parse-remote-objects.ts", "../../src/lib/parsers/parse-remote-messages.ts", "../../src/lib/parsers/parse-pull.ts", "../../src/lib/parsers/parse-merge.ts", "../../src/lib/tasks/merge.ts", "../../src/lib/parsers/parse-push.ts", "../../src/lib/tasks/push.ts", "../../src/lib/responses/FileStatusSummary.ts", "../../src/lib/responses/StatusSummary.ts", "../../src/lib/tasks/status.ts", "../../src/lib/simple-git-api.ts", "../../src/lib/runners/scheduler.ts", "../../src/lib/tasks/apply-patch.ts", "../../src/lib/responses/BranchDeleteSummary.ts", "../../src/lib/parsers/parse-branch-delete.ts", "../../src/lib/responses/BranchSummary.ts", "../../src/lib/parsers/parse-branch.ts", "../../src/lib/tasks/branch.ts", "../../src/lib/responses/CheckIgnore.ts", "../../src/lib/tasks/check-ignore.ts", "../../src/lib/tasks/clone.ts", "../../src/lib/parsers/parse-fetch.ts", "../../src/lib/tasks/fetch.ts", "../../src/lib/parsers/parse-move.ts", "../../src/lib/tasks/move.ts", "../../src/lib/tasks/pull.ts", "../../src/lib/responses/GetRemoteSummary.ts", "../../src/lib/tasks/remote.ts", "../../src/lib/tasks/stash-list.ts", "../../src/lib/tasks/sub-module.ts", "../../src/lib/responses/TagList.ts", "../../src/lib/tasks/tag.ts", "../../src/git.js", "../../src/lib/git-factory.ts", "../../src/lib/runners/promise-wrapped.ts", "../../src/index.js"],
-  "sourcesContent": ["import type { SimpleGitTask } from '../types';\n\n/**\n * The `GitError` is thrown when the underlying `git` process throws a\n * fatal exception (eg an `ENOENT` exception when attempting to use a\n * non-writable directory as the root for your repo), and acts as the\n * base class for more specific errors thrown by the parsing of the\n * git response or errors in the configuration of the task about to\n * be run.\n *\n * When an exception is thrown, pending tasks in the same instance will\n * not be executed. The recommended way to run a series of tasks that\n * can independently fail without needing to prevent future tasks from\n * running is to catch them individually:\n *\n * ```typescript\n import { gitP, SimpleGit, GitError, PullResult } from 'simple-git';\n\n function catchTask (e: GitError) {\n   return e.\n }\n\n const git = gitP(repoWorkingDir);\n const pulled: PullResult | GitError = await git.pull().catch(catchTask);\n const pushed: string | GitError = await git.pushTags().catch(catchTask);\n ```\n */\nexport class GitError extends Error {\n\n   constructor (\n      public task?: SimpleGitTask<any>,\n      message?: string,\n   ) {\n      super(message);\n      Object.setPrototypeOf(this, new.target.prototype);\n   }\n\n}\n", "import { GitError } from './git-error';\n\n/**\n * The `GitResponseError` is the wrapper for a parsed response that is treated as\n * a fatal error, for example attempting a `merge` can leave the repo in a corrupted\n * state when there are conflicts so the task will reject rather than resolve.\n *\n * For example, catching the merge conflict exception:\n *\n * ```typescript\n import { gitP, SimpleGit, GitResponseError, MergeSummary } from 'simple-git';\n\n const git = gitP(repoRoot);\n const mergeOptions: string[] = ['--no-ff', 'other-branch'];\n const mergeSummary: MergeSummary = await git.merge(mergeOptions)\n      .catch((e: GitResponseError<MergeSummary>) => e.git);\n\n if (mergeSummary.failed) {\n   // deal with the error\n }\n ```\n */\nexport class GitResponseError<T = any> extends GitError {\n\n   constructor(\n      /**\n       * `.git` access the parsed response that is treated as being an error\n       */\n      public readonly git: T,\n      message?: string,\n   ) {\n      super(undefined, message || String(git));\n   }\n\n}\n", "import { GitError } from './git-error';\nimport { SimpleGitOptions } from '../types';\n\n/**\n * The `GitConstructError` is thrown when an error occurs in the constructor\n * of the `simple-git` instance itself. Most commonly as a result of using\n * a `baseDir` option that points to a folder that either does not exist,\n * or cannot be read by the user the node script is running as.\n *\n * Check the `.message` property for more detail including the properties\n * passed to the constructor.\n */\nexport class GitConstructError extends GitError {\n\n   constructor (\n      public readonly config: SimpleGitOptions,\n      message: string,\n   ) {\n      super(undefined, message);\n   }\n\n}\n", "import { SimpleGitOptions, SimpleGitTask } from '../types';\nimport { GitError } from './git-error';\n\nexport class GitPluginError extends GitError {\n\n   constructor (\n      public task?: SimpleGitTask<any>,\n      public readonly plugin?: keyof SimpleGitOptions,\n      message?: string,\n   ) {\n      super(task, message);\n      Object.setPrototypeOf(this, new.target.prototype);\n   }\n\n}\n", "import { GitError } from './git-error';\n\n/**\n * The `TaskConfigurationError` is thrown when a command was incorrectly\n * configured. An error of this kind means that no attempt was made to\n * run your command through the underlying `git` binary.\n *\n * Check the `.message` property for more detail on why your configuration\n * resulted in an error.\n */\nexport class TaskConfigurationError extends GitError {\n\n   constructor (\n      message?: string,\n   ) {\n      super(undefined, message);\n   }\n\n}\n", "import { exists, FOLDER } from '@kwsites/file-exists';\nimport { Maybe } from '../types';\n\nexport const NULL = '\\0';\n\nexport const NOOP: (...args: any[]) => void = () => {\n};\n\n/**\n * Returns either the source argument when it is a `Function`, or the default\n * `NOOP` function constant\n */\nexport function asFunction<T extends () => any>(source: T | any): T {\n   return typeof source === 'function' ? source : NOOP;\n}\n\n/**\n * Determines whether the supplied argument is both a function, and is not\n * the `NOOP` function.\n */\nexport function isUserFunction<T extends Function>(source: T | any): source is T {\n   return (typeof source === 'function' && source !== NOOP);\n}\n\nexport function splitOn(input: string, char: string): [string, string] {\n   const index = input.indexOf(char);\n   if (index <= 0) {\n      return [input, ''];\n   }\n\n   return [\n      input.substr(0, index),\n      input.substr(index + 1),\n   ];\n}\n\nexport function first<T extends any[]>(input: T, offset?: number): Maybe<T[number]>;\nexport function first<T extends IArguments>(input: T, offset?: number): Maybe<unknown>;\nexport function first(input: any[] | IArguments, offset = 0): Maybe<unknown> {\n   return isArrayLike(input) && input.length > offset ? input[offset] : undefined;\n}\n\nexport function last<T extends any[]>(input: T, offset?: number): Maybe<T[number]>;\nexport function last<T extends IArguments>(input: T, offset?: number): Maybe<unknown>;\nexport function last<T>(input: T, offset?: number): Maybe<unknown>;\nexport function last(input: unknown, offset = 0) {\n   if (isArrayLike(input) && input.length > offset) {\n      return input[input.length - 1 - offset];\n   }\n}\n\ntype ArrayLike<T = any> = T[] | IArguments | { [index: number]: T; length: number };\n\nfunction isArrayLike(input: any): input is ArrayLike {\n   return !!(input && typeof input.length === 'number');\n}\n\nexport function toLinesWithContent(input = '', trimmed = true, separator = '\\n'): string[] {\n   return input.split(separator)\n      .reduce((output, line) => {\n         const lineContent = trimmed ? line.trim() : line;\n         if (lineContent) {\n            output.push(lineContent);\n         }\n         return output;\n      }, [] as string[]);\n}\n\ntype LineWithContentCallback<T = void> = (line: string) => T;\n\nexport function forEachLineWithContent<T>(input: string, callback: LineWithContentCallback<T>): T[] {\n   return toLinesWithContent(input, true).map(line => callback(line));\n}\n\nexport function folderExists(path: string): boolean {\n   return exists(path, FOLDER);\n}\n\n/**\n * Adds `item` into the `target` `Array` or `Set` when it is not already present and returns the `item`.\n */\nexport function append<T>(target: T[] | Set<T>, item: T): typeof item {\n   if (Array.isArray(target)) {\n      if (!target.includes(item)) {\n         target.push(item);\n      }\n   } else {\n      target.add(item);\n   }\n   return item;\n}\n\n/**\n * Adds `item` into the `target` `Array` when it is not already present and returns the `target`.\n */\nexport function including<T>(target: T[], item: T): typeof target {\n   if (Array.isArray(target) && !target.includes(item)) {\n      target.push(item);\n   }\n\n   return target;\n}\n\nexport function remove<T>(target: Set<T> | T[], item: T): T {\n   if (Array.isArray(target)) {\n      const index = target.indexOf(item);\n      if (index >= 0) {\n         target.splice(index, 1);\n      }\n   } else {\n      target.delete(item);\n   }\n   return item;\n}\n\nexport const objectToString = Object.prototype.toString.call.bind(Object.prototype.toString) as (input: any) => string;\n\nexport function asArray<T>(source: T | T[]): T[] {\n   return Array.isArray(source) ? source : [source];\n}\n\nexport function asStringArray<T>(source: T | T[]): string[] {\n   return asArray(source).map(String);\n}\n\nexport function asNumber(source: string | null | undefined, onNaN = 0) {\n   if (source == null) {\n      return onNaN;\n   }\n\n   const num = parseInt(source, 10);\n   return isNaN(num) ? onNaN : num;\n}\n\nexport function prefixedArray<T>(input: T[], prefix: T): T[] {\n   const output: T[] = [];\n   for (let i = 0, max = input.length; i < max; i++) {\n      output.push(prefix, input[i]);\n   }\n   return output;\n}\n\nexport function bufferToString(input: Buffer | Buffer[]): string {\n   return (Array.isArray(input) ? Buffer.concat(input) : input).toString('utf-8');\n}\n\n/**\n * Get a new object from a source object with only the listed properties.\n */\nexport function pick(source: Record<string, any>, properties: string[]) {\n   return Object.assign({}, ...properties.map((property) => property in source ? {[property]: source[property]} : {}));\n}\n\nexport function delay(duration = 0): Promise<void> {\n   return new Promise(done => setTimeout(done, duration));\n}\n", "import { Maybe, Options, Primitives } from '../types';\nimport { objectToString } from './util';\n\nexport interface ArgumentFilterPredicate<T> {\n   (input: any): input is T;\n}\n\nexport function filterType<T, K>(input: K, filter: ArgumentFilterPredicate<T>): K extends T ? T : undefined;\nexport function filterType<T, K>(input: K, filter: ArgumentFilterPredicate<T>, def: T): T;\nexport function filterType<T, K>(input: K, filter: ArgumentFilterPredicate<T>, def?: T): Maybe<T> {\n   if (filter(input)) {\n      return input;\n   }\n   return (arguments.length > 2) ? def : undefined\n}\n\nexport const filterArray: ArgumentFilterPredicate<Array<any>> = (input): input is Array<any> => {\n   return Array.isArray(input);\n}\n\nexport function filterPrimitives(input: unknown, omit?: Array<'boolean' | 'string' | 'number'>): input is Primitives {\n   return /number|string|boolean/.test(typeof input) && (!omit || !omit.includes((typeof input) as 'boolean' | 'string' | 'number'));\n}\n\nexport const filterString: ArgumentFilterPredicate<string> = (input): input is string => {\n   return typeof input === 'string';\n};\n\nexport const filterStringArray: ArgumentFilterPredicate<string[]> = (input): input is string[] => {\n   return Array.isArray(input) && input.every(filterString);\n};\n\nexport const filterStringOrStringArray: ArgumentFilterPredicate<string | string[]> = (input): input is string | string[] => {\n   return filterString(input) || (Array.isArray(input) && input.every(filterString));\n};\n\nexport function filterPlainObject<T extends Options>(input: T | unknown): input is T;\nexport function filterPlainObject<T extends Object>(input: T | unknown): input is T {\n   return !!input && objectToString(input) === '[object Object]';\n}\n\nexport function filterFunction(input: unknown): input is Function {\n   return typeof input === 'function';\n}\n\nexport const filterHasLength: ArgumentFilterPredicate<{ length: number }> = (input): input is { length: number } => {\n   if (input == null || 'number|boolean|function'.includes(typeof input)) {\n      return false;\n   }\n   return Array.isArray(input) || typeof input === 'string' || typeof input.length === 'number';\n}\n", "/**\n * Known process exit codes used by the task parsers to determine whether an error\n * was one they can automatically handle\n */\nexport enum ExitCodes {\n   SUCCESS,\n   ERROR,\n   UNCLEAN = 128,\n}\n", "import { TaskResponseFormat } from '../types';\n\nexport class GitOutputStreams<T extends TaskResponseFormat = Buffer> {\n\n   constructor(public readonly stdOut: T, public readonly stdErr: T) {\n   }\n\n   asStrings(): GitOutputStreams<string> {\n      return new GitOutputStreams(this.stdOut.toString('utf8'), this.stdErr.toString('utf8'));\n   }\n}\n", "export class LineParser<T> {\n\n   protected matches: string[] = [];\n\n   private _regExp: RegExp[];\n\n   constructor(\n      regExp: RegExp | RegExp[],\n      useMatches?: (target: T, match: string[]) => boolean | void,\n   ) {\n      this._regExp = Array.isArray(regExp) ? regExp : [regExp];\n      if (useMatches) {\n         this.useMatches = useMatches;\n      }\n   }\n\n   parse = (line: (offset: number) => (string | undefined), target: T): boolean => {\n      this.resetMatches();\n\n      if (!this._regExp.every((reg, index) => this.addMatch(reg, index, line(index)))) {\n         return false;\n      }\n\n      return this.useMatches(target, this.prepareMatches()) !== false;\n   }\n\n   // @ts-ignore\n   protected useMatches(target: T, match: string[]): boolean | void {\n      throw new Error(`LineParser:useMatches not implemented`);\n   }\n\n   protected resetMatches() {\n      this.matches.length = 0;\n   }\n\n   protected prepareMatches() {\n      return this.matches;\n   }\n\n   protected addMatch(reg: RegExp, index: number, line?: string) {\n      const matched = line && reg.exec(line);\n      if (matched) {\n         this.pushMatch(index, matched);\n      }\n\n      return !!matched;\n   }\n\n   protected pushMatch(_index: number, matched: string[]) {\n      this.matches.push(...matched.slice(1));\n   }\n\n}\n\nexport class RemoteLineParser<T> extends LineParser<T> {\n\n   protected addMatch(reg: RegExp, index: number, line?: string): boolean {\n      return /^remote:\\s/.test(String(line)) && super.addMatch(reg, index, line);\n   }\n\n   protected pushMatch(index: number, matched: string[]) {\n      if (index > 0 || matched.length > 1) {\n         super.pushMatch(index, matched);\n      }\n   }\n\n}\n", "import { SimpleGitOptions } from '../types';\n\nconst defaultOptions: Omit<SimpleGitOptions, 'baseDir'> = {\n   binary: 'git',\n   maxConcurrentProcesses: 5,\n   config: [],\n};\n\nexport function createInstanceConfig(...options: Array<Partial<SimpleGitOptions> | undefined>): SimpleGitOptions {\n   const baseDir = process.cwd();\n   const config: SimpleGitOptions = Object.assign({baseDir, ...defaultOptions},\n      ...(options.filter(o => typeof o === 'object' && o))\n   );\n\n   config.baseDir = config.baseDir || baseDir;\n\n   return config;\n}\n", "import { filterArray, filterFunction, filterPlainObject, filterPrimitives, filterType } from './argument-filters';\nimport { asFunction, isUserFunction, last } from './util';\nimport { Maybe, Options, OptionsValues } from '../types';\n\nexport function appendTaskOptions<T extends Options = Options>(options: Maybe<T>, commands: string[] = []): string[] {\n   if (!filterPlainObject<Options>(options)) {\n      return commands;\n   }\n\n   return Object.keys(options).reduce((commands: string[], key: string) => {\n      const value: OptionsValues = options[key];\n\n      if (filterPrimitives(value, ['boolean'])) {\n         commands.push(key + '=' + value);\n      } else {\n         commands.push(key);\n      }\n\n      return commands;\n   }, commands);\n}\n\nexport function getTrailingOptions(args: IArguments, initialPrimitive = 0, objectOnly = false): string[] {\n   const command: string[] = [];\n\n   for (let i = 0, max = initialPrimitive < 0 ? args.length : initialPrimitive; i < max; i++) {\n      if ('string|number'.includes(typeof args[i])) {\n         command.push(String(args[i]));\n      }\n   }\n\n   appendTaskOptions(trailingOptionsArgument(args), command);\n   if (!objectOnly) {\n      command.push(...trailingArrayArgument(args));\n   }\n\n   return command;\n}\n\nfunction trailingArrayArgument(args: IArguments) {\n   const hasTrailingCallback = typeof last(args) === 'function';\n   return filterType(\n      last(args, hasTrailingCallback ? 1 : 0), filterArray, []\n   );\n}\n\n/**\n * Given any number of arguments, returns the trailing options argument, ignoring a trailing function argument\n * if there is one. When not found, the return value is null.\n */\nexport function trailingOptionsArgument(args: IArguments): Maybe<Options> {\n   const hasTrailingCallback = filterFunction(last(args));\n   return filterType(last(args, hasTrailingCallback ? 1 : 0), filterPlainObject);\n}\n\n/**\n * Returns either the source argument when it is a `Function`, or the default\n * `NOOP` function constant\n */\nexport function trailingFunctionArgument(args: unknown[] | IArguments | unknown, includeNoop = true): Maybe<(...args: any[]) => unknown> {\n   const callback = asFunction(last(args));\n   return includeNoop || isUserFunction(callback) ? callback : undefined;\n}\n", "import type { MaybeArray, TaskParser, TaskResponseFormat } from '../types';\nimport { GitOutputStreams } from './git-output-streams';\nimport { LineParser } from './line-parser';\nimport { asArray, toLinesWithContent } from './util';\n\nexport function callTaskParser<INPUT extends TaskResponseFormat, RESPONSE>(parser: TaskParser<INPUT, RESPONSE>, streams: GitOutputStreams<INPUT>) {\n   return parser(streams.stdOut, streams.stdErr);\n}\n\nexport function parseStringResponse<T>(result: T, parsers: LineParser<T>[], texts: MaybeArray<string>, trim = true): T {\n   asArray(texts).forEach(text => {\n      for (let lines = toLinesWithContent(text, trim), i = 0, max = lines.length; i < max; i++) {\n         const line = (offset = 0) => {\n            if ((i + offset) >= max) {\n               return;\n            }\n            return lines[i + offset];\n         }\n\n         parsers.some(({parse}) => parse(line, result));\n      }\n   });\n\n   return result;\n}\n", "\nexport * from './argument-filters';\nexport * from './exit-codes';\nexport * from './git-output-streams';\nexport * from './line-parser';\nexport * from './simple-git-options';\nexport * from './task-options';\nexport * from './task-parser';\nexport * from './util';\n", "import { ExitCodes } from '../utils';\nimport { Maybe, StringTask } from '../types';\n\nexport enum CheckRepoActions {\n   BARE = 'bare',\n   IN_TREE = 'tree',\n   IS_REPO_ROOT = 'root',\n}\n\nconst onError: StringTask<boolean>['onError'] = ({exitCode}, error, done, fail) => {\n   if (exitCode === ExitCodes.UNCLEAN && isNotRepoMessage(error)) {\n      return done(Buffer.from('false'));\n   }\n\n   fail(error);\n}\n\nconst parser: StringTask<boolean>['parser'] = (text) => {\n   return text.trim() === 'true';\n}\n\nexport function checkIsRepoTask(action: Maybe<CheckRepoActions>): StringTask<boolean> {\n   switch (action) {\n      case CheckRepoActions.BARE:\n         return checkIsBareRepoTask();\n      case CheckRepoActions.IS_REPO_ROOT:\n         return checkIsRepoRootTask();\n   }\n\n   const commands = ['rev-parse', '--is-inside-work-tree'];\n\n   return {\n      commands,\n      format: 'utf-8',\n      onError,\n      parser,\n   }\n}\n\n\nexport function checkIsRepoRootTask(): StringTask<boolean> {\n   const commands = ['rev-parse', '--git-dir'];\n\n   return {\n      commands,\n      format: 'utf-8',\n      onError,\n      parser(path) {\n         return /^\\.(git)?$/.test(path.trim());\n      },\n   }\n}\n\n\nexport function checkIsBareRepoTask(): StringTask<boolean> {\n   const commands = ['rev-parse', '--is-bare-repository'];\n\n   return {\n      commands,\n      format: 'utf-8',\n      onError,\n      parser,\n   }\n}\n\n\nfunction isNotRepoMessage(error: Error): boolean {\n   return /(Not a git repository|Kein Git-Repository)/i.test(String(error));\n}\n", "import { CleanSummary } from '../../../typings';\nimport { toLinesWithContent } from '../utils';\n\nexport class CleanResponse implements CleanSummary {\n\n   public paths: string[] = [];\n   public files: string[] = [];\n   public folders: string[] = [];\n\n   constructor(\n      public readonly dryRun: boolean,\n   ) {}\n\n}\n\nconst removalRegexp = /^[a-z]+\\s*/i;\nconst dryRunRemovalRegexp = /^[a-z]+\\s+[a-z]+\\s*/i;\nconst isFolderRegexp = /\\/$/;\n\nexport function cleanSummaryParser (dryRun: boolean, text: string): CleanSummary {\n   const summary = new CleanResponse(dryRun);\n   const regexp = dryRun ? dryRunRemovalRegexp : removalRegexp;\n\n   toLinesWithContent(text).forEach(line => {\n      const removed = line.replace(regexp, '');\n\n      summary.paths.push(removed);\n      (isFolderRegexp.test(removed) ? summary.folders : summary.files).push(removed);\n   });\n\n   return summary;\n}\n", "import { TaskConfigurationError } from '../errors/task-configuration-error';\nimport type { BufferTask, EmptyTaskParser, SimpleGitTask, StringTask } from '../types';\n\nexport const EMPTY_COMMANDS: [] = [];\n\nexport type EmptyTask = {\n   commands: typeof EMPTY_COMMANDS;\n   format: 'empty',\n   parser: EmptyTaskParser;\n   onError?: undefined;\n};\n\n\nexport function adhocExecTask(parser: EmptyTaskParser): EmptyTask {\n   return {\n      commands: EMPTY_COMMANDS,\n      format: 'empty',\n      parser,\n   };\n}\n\nexport function configurationErrorTask(error: Error | string): EmptyTask {\n   return {\n      commands: EMPTY_COMMANDS,\n      format: 'empty',\n      parser() {\n         throw typeof error === 'string' ? new TaskConfigurationError(error) : error;\n      }\n   }\n}\n\nexport function straightThroughStringTask(commands: string[], trimmed = false): StringTask<string> {\n   return {\n      commands,\n      format: 'utf-8',\n      parser(text) {\n         return trimmed ? String(text).trim() : text;\n      },\n   }\n}\n\nexport function straightThroughBufferTask(commands: string[]): BufferTask<any> {\n   return {\n      commands,\n      format: 'buffer',\n      parser(buffer) {\n         return buffer;\n      },\n   }\n}\n\nexport function isBufferTask<R>(task: SimpleGitTask<R>): task is BufferTask<R> {\n   return task.format === 'buffer';\n}\n\nexport function isEmptyTask<R>(task: SimpleGitTask<R>): task is EmptyTask {\n   return task.format === 'empty' || !task.commands.length;\n}\n", "import { CleanSummary } from '../../../typings';\nimport { cleanSummaryParser } from '../responses/CleanSummary';\nimport { Maybe, StringTask } from '../types';\nimport { asStringArray } from '../utils';\nimport { configurationErrorTask } from './task';\n\nexport const CONFIG_ERROR_INTERACTIVE_MODE = 'Git clean interactive mode is not supported';\nexport const CONFIG_ERROR_MODE_REQUIRED = 'Git clean mode parameter (\"n\" or \"f\") is required';\nexport const CONFIG_ERROR_UNKNOWN_OPTION = 'Git clean unknown option found in: ';\n\n/**\n * All supported option switches available for use in a `git.clean` operation\n */\nexport enum CleanOptions {\n   DRY_RUN = 'n',\n   FORCE = 'f',\n   IGNORED_INCLUDED = 'x',\n   IGNORED_ONLY = 'X',\n   EXCLUDING = 'e',\n   QUIET = 'q',\n   RECURSIVE = 'd',\n}\n\n/**\n * The two modes `git.clean` can run in - one of these must be supplied in order\n * for the command to not throw a `TaskConfigurationError`\n */\nexport type CleanMode = CleanOptions.FORCE | CleanOptions.DRY_RUN;\n\nconst CleanOptionValues: Set<string> = new Set(['i', ...asStringArray(Object.values(CleanOptions as any))]);\n\nexport function cleanWithOptionsTask(mode: CleanMode | string, customArgs: string[]) {\n   const {cleanMode, options, valid} = getCleanOptions(mode);\n\n   if (!cleanMode) {\n      return configurationErrorTask(CONFIG_ERROR_MODE_REQUIRED);\n   }\n\n   if (!valid.options) {\n      return configurationErrorTask(CONFIG_ERROR_UNKNOWN_OPTION + JSON.stringify(mode));\n   }\n\n   options.push(...customArgs);\n\n   if (options.some(isInteractiveMode)) {\n      return configurationErrorTask(CONFIG_ERROR_INTERACTIVE_MODE);\n   }\n\n   return cleanTask(cleanMode, options);\n}\n\nexport function cleanTask(mode: CleanMode, customArgs: string[]): StringTask<CleanSummary> {\n   const commands: string[] = ['clean', `-${mode}`, ...customArgs];\n\n   return {\n      commands,\n      format: 'utf-8',\n      parser(text: string): CleanSummary {\n         return cleanSummaryParser(mode === CleanOptions.DRY_RUN, text);\n      }\n   }\n}\n\nexport function isCleanOptionsArray (input: string[]): input is CleanOptions[] {\n   return Array.isArray(input) && input.every(test => CleanOptionValues.has(test));\n}\n\nfunction getCleanOptions(input: string) {\n   let cleanMode: Maybe<CleanMode>;\n   let options: string[] = [];\n   let valid = {cleanMode: false, options: true};\n\n   input.replace(/[^a-z]i/g, '').split('').forEach(char => {\n      if (isCleanMode(char)) {\n         cleanMode = char;\n         valid.cleanMode = true;\n      }\n      else {\n         valid.options = valid.options && isKnownOption(options[options.length] = (`-${char}`));\n      }\n   });\n\n   return {\n      cleanMode,\n      options,\n      valid,\n   }\n}\n\nfunction isCleanMode(cleanMode?: string): cleanMode is CleanMode {\n   return cleanMode === CleanOptions.FORCE || cleanMode === CleanOptions.DRY_RUN;\n}\n\nfunction isKnownOption(option: string): boolean {\n   return /^-[a-z]$/i.test(option) && CleanOptionValues.has(option.charAt(1));\n}\n\nfunction isInteractiveMode(option: string): boolean {\n   if (/^-[^\\-]/.test(option)) {\n      return option.indexOf('i') > 0;\n   }\n\n   return option === '--interactive';\n}\n", "import { ConfigGetResult, ConfigListSummary, ConfigValues } from '../../../typings';\nimport { last, splitOn } from '../utils';\n\nexport class ConfigList implements ConfigListSummary {\n\n   public files: string[] = [];\n   public values: { [fileName: string]: ConfigValues } = Object.create(null);\n\n   private _all: ConfigValues | undefined;\n\n   public get all(): ConfigValues {\n      if (!this._all) {\n         this._all = this.files.reduce((all: ConfigValues, file: string) => {\n            return Object.assign(all, this.values[file]);\n         }, {});\n      }\n\n      return this._all;\n   }\n\n   public addFile(file: string): ConfigValues {\n      if (!(file in this.values)) {\n         const latest = last(this.files);\n         this.values[file] = latest ? Object.create(this.values[latest]) : {}\n\n         this.files.push(file);\n      }\n\n      return this.values[file];\n   }\n\n   public addValue(file: string, key: string, value: string) {\n      const values = this.addFile(file);\n\n      if (!values.hasOwnProperty(key)) {\n         values[key] = value;\n      } else if (Array.isArray(values[key])) {\n         (values[key] as string[]).push(value);\n      } else {\n         values[key] = [values[key] as string, value];\n      }\n\n      this._all = undefined;\n   }\n\n}\n\nexport function configListParser(text: string): ConfigList {\n   const config = new ConfigList();\n\n   for (const item of configParser(text)) {\n      config.addValue(item.file, String(item.key), item.value);\n   }\n\n   return config;\n}\n\nexport function configGetParser(text: string, key: string): ConfigGetResult {\n   let value: string | null = null;\n   const values: string[] = [];\n   const scopes: Map<string, string[]> = new Map();\n\n   for (const item of configParser(text, key)) {\n      if (item.key !== key) {\n         continue;\n      }\n\n      values.push(value = item.value);\n\n      if (!scopes.has(item.file)) {\n         scopes.set(item.file, []);\n      }\n\n      scopes.get(item.file)!.push(value);\n   }\n\n   return {\n      key,\n      paths: Array.from(scopes.keys()),\n      scopes,\n      value,\n      values\n   };\n}\n\nfunction configFilePath(filePath: string): string {\n   return filePath.replace(/^(file):/, '');\n}\n\nfunction* configParser(text: string, requestedKey: string | null = null) {\n   const lines = text.split('\\0');\n\n   for (let i = 0, max = lines.length - 1; i < max;) {\n      const file = configFilePath(lines[i++]);\n\n      let value = lines[i++];\n      let key = requestedKey;\n\n      if (value.includes('\\n')) {\n         const line = splitOn(value, '\\n');\n         key = line[0];\n         value = line[1];\n      }\n\n      yield {file, key, value};\n   }\n}\n", "import { ConfigGetResult, ConfigListSummary, SimpleGit } from '../../../typings';\nimport { configGetParser, configListParser } from '../responses/ConfigList';\nimport { SimpleGitApi } from '../simple-git-api';\nimport { StringTask } from '../types';\nimport { trailingFunctionArgument } from '../utils';\n\nexport enum GitConfigScope {\n   system = 'system',\n   global = 'global',\n   local = 'local',\n   worktree = 'worktree',\n}\n\nfunction asConfigScope<T extends GitConfigScope | undefined>(scope: GitConfigScope | unknown, fallback: T): GitConfigScope | T {\n   if (typeof scope === 'string' && GitConfigScope.hasOwnProperty(scope)) {\n      return scope as GitConfigScope;\n   }\n   return fallback;\n}\n\nfunction addConfigTask(key: string, value: string, append: boolean, scope: GitConfigScope): StringTask<string> {\n   const commands: string[] = ['config', `--${scope}`];\n\n   if (append) {\n      commands.push('--add');\n   }\n\n   commands.push(key, value);\n\n   return {\n      commands,\n      format: 'utf-8',\n      parser(text: string): string {\n         return text;\n      }\n   }\n}\n\nfunction getConfigTask(key: string, scope?: GitConfigScope): StringTask<ConfigGetResult> {\n   const commands: string[] = ['config', '--null', '--show-origin', '--get-all', key];\n\n   if (scope) {\n      commands.splice(1, 0, `--${scope}`);\n   }\n\n   return {\n      commands,\n      format: 'utf-8',\n      parser(text) {\n         return configGetParser(text, key);\n      }\n   };\n}\n\nfunction listConfigTask(scope?: GitConfigScope): StringTask<ConfigListSummary> {\n   const commands = ['config', '--list', '--show-origin', '--null'];\n\n   if (scope) {\n      commands.push(`--${scope}`);\n   }\n\n   return {\n      commands,\n      format: 'utf-8',\n      parser(text: string) {\n         return configListParser(text);\n      },\n   }\n}\n\nexport default function (): Pick<SimpleGit, 'addConfig' | 'getConfig' | 'listConfig'> {\n   return {\n      addConfig(this: SimpleGitApi, key: string, value: string, ...rest: unknown[]) {\n         return this._runTask(\n            addConfigTask(key, value, rest[0] === true, asConfigScope(rest[1], GitConfigScope.local)),\n            trailingFunctionArgument(arguments),\n         );\n      },\n\n      getConfig(this: SimpleGitApi, key: string, scope?: GitConfigScope) {\n         return this._runTask(\n            getConfigTask(key, asConfigScope(scope, undefined)),\n            trailingFunctionArgument(arguments),\n         )\n      },\n\n      listConfig(this: SimpleGitApi, ...rest: unknown[]) {\n         return this._runTask(\n            listConfigTask(asConfigScope(rest[0], undefined)),\n            trailingFunctionArgument(arguments),\n         );\n      },\n   };\n}\n", "import { GrepResult, SimpleGit } from '../../../typings';\nimport { SimpleGitApi } from '../simple-git-api';\nimport {\n   asNumber,\n   forEachLineWithContent,\n   getTrailingOptions,\n   NULL,\n   prefixedArray,\n   trailingFunctionArgument\n} from '../utils';\n\nimport { configurationErrorTask } from './task';\n\nconst disallowedOptions = ['-h'];\n\nconst Query = Symbol('grepQuery');\n\nexport interface GitGrepQuery extends Iterable<string> {\n   /** Adds one or more terms to be grouped as an \"and\" to any other terms */\n   and(...and: string[]): this;\n\n   /** Adds one or more search terms - git.grep will \"or\" this to other terms */\n   param(...param: string[]): this;\n}\n\nclass GrepQuery implements GitGrepQuery {\n   private [Query]: string[] = [];\n\n   * [Symbol.iterator]() {\n      for (const query of this[Query]) {\n         yield query;\n      }\n   }\n\n   and(...and: string[]) {\n      and.length && this[Query].push('--and', '(', ...prefixedArray(and, '-e'), ')');\n      return this;\n   }\n\n   param(...param: string[]) {\n      this[Query].push(...prefixedArray(param, '-e'));\n      return this;\n   }\n}\n\n/**\n * Creates a new builder for a `git.grep` query with optional params\n */\nexport function grepQueryBuilder(...params: string[]): GitGrepQuery {\n   return new GrepQuery().param(...params);\n}\n\nfunction parseGrep(grep: string): GrepResult {\n   const paths: GrepResult['paths'] = new Set<string>();\n   const results: GrepResult['results'] = {};\n\n   forEachLineWithContent(grep, (input) => {\n      const [path, line, preview] = input.split(NULL);\n      paths.add(path);\n      (results[path] = results[path] || []).push({\n         line: asNumber(line),\n         path,\n         preview,\n      });\n   });\n\n   return {\n      paths,\n      results,\n   };\n}\n\nexport default function (): Pick<SimpleGit, 'grep'> {\n   return {\n      grep(this: SimpleGitApi, searchTerm: string | GitGrepQuery) {\n         const then = trailingFunctionArgument(arguments);\n         const options = getTrailingOptions(arguments);\n\n         for (const option of disallowedOptions) {\n            if (options.includes(option)) {\n               return this._runTask(\n                  configurationErrorTask(`git.grep: use of \"${option}\" is not supported.`),\n                  then,\n               );\n            }\n         }\n\n         if (typeof searchTerm === 'string') {\n            searchTerm = grepQueryBuilder().param(searchTerm);\n         }\n\n         const commands = ['grep', '--null', '-n', '--full-name', ...options, ...searchTerm];\n\n         return this._runTask({\n            commands,\n            format: 'utf-8',\n            parser(stdOut) {\n               return parseGrep(stdOut);\n            },\n         }, then);\n      }\n   }\n}\n", "import { straightThroughStringTask } from './task';\nimport { Maybe, OptionFlags, Options } from '../types';\n\nexport enum ResetMode {\n   MIXED = 'mixed',\n   SOFT = 'soft',\n   HARD = 'hard',\n   MERGE = 'merge',\n   KEEP = 'keep',\n}\n\nconst ResetModes = Array.from(Object.values(ResetMode));\n\nexport type ResetOptions = Options &\n   OptionFlags<'-q' | '--quiet' | '--no-quiet' | '--pathspec-from-nul'> &\n   OptionFlags<'--pathspec-from-file', string>;\n\nexport function resetTask(mode: Maybe<ResetMode>, customArgs: string[]) {\n   const commands: string[] = ['reset'];\n   if (isValidResetMode(mode)) {\n      commands.push(`--${mode}`);\n   }\n   commands.push(...customArgs);\n\n   return straightThroughStringTask(commands);\n}\n\nexport function getResetMode(mode: ResetMode | any): Maybe<ResetMode> {\n   if (isValidResetMode(mode)) {\n      return mode;\n   }\n\n   switch (typeof mode) {\n      case 'string':\n      case 'undefined':\n         return ResetMode.SOFT;\n   }\n\n   return;\n}\n\nfunction isValidResetMode(mode: ResetMode | any): mode is ResetMode {\n   return ResetModes.includes(mode);\n}\n", "import { GitConstructError } from './errors/git-construct-error';\nimport { GitError } from './errors/git-error';\nimport { GitPluginError } from './errors/git-plugin-error';\nimport { GitResponseError } from './errors/git-response-error';\nimport { TaskConfigurationError } from './errors/task-configuration-error';\nimport { CheckRepoActions } from './tasks/check-is-repo';\nimport { CleanOptions } from './tasks/clean';\nimport { GitConfigScope } from './tasks/config';\nimport { grepQueryBuilder } from './tasks/grep';\nimport { ResetMode } from './tasks/reset';\n\nexport {\n   CheckRepoActions,\n   CleanOptions,\n   GitConfigScope,\n   GitConstructError,\n   GitError,\n   GitPluginError,\n   GitResponseError,\n   ResetMode,\n   TaskConfigurationError,\n   grepQueryBuilder,\n};\n", "import { prefixedArray } from '../utils';\nimport { SimpleGitPlugin } from './simple-git-plugin';\n\nexport function commandConfigPrefixingPlugin(configuration: string[]): SimpleGitPlugin<'spawn.args'> {\n   const prefix = prefixedArray(configuration, '-c');\n\n   return {\n      type: 'spawn.args',\n      action(data) {\n         return [...prefix, ...data];\n      },\n   };\n}\n", "import { deferred, DeferredPromise } from '@kwsites/promise-deferred';\nimport { SimpleGitPluginConfig } from '../types';\nimport { delay } from '../utils';\nimport { SimpleGitPlugin } from './simple-git-plugin';\n\nconst never = deferred().promise;\n\nexport function completionDetectionPlugin({\n                                             onClose = true,\n                                             onExit = 50\n                                          }: SimpleGitPluginConfig['completion'] = {}): SimpleGitPlugin<'spawn.after'> {\n\n   function createEvents() {\n      let exitCode = -1;\n      const events = {\n         close: deferred(),\n         closeTimeout: deferred(),\n         exit: deferred(),\n         exitTimeout: deferred(),\n      };\n\n      const result = Promise.race([\n         onClose === false ? never : events.closeTimeout.promise,\n         onExit === false ? never : events.exitTimeout.promise,\n      ]);\n\n      configureTimeout(onClose, events.close, events.closeTimeout);\n      configureTimeout(onExit, events.exit, events.exitTimeout);\n\n      return {\n         close(code: number) {\n            exitCode = code;\n            events.close.done();\n         },\n         exit(code: number) {\n            exitCode = code;\n            events.exit.done();\n         },\n         get exitCode() {\n            return exitCode;\n         },\n         result,\n      };\n   }\n\n   function configureTimeout(flag: boolean | number, event: DeferredPromise<void>, timeout: DeferredPromise<void>) {\n      if (flag === false) {\n         return;\n      }\n\n      (flag === true ? event.promise : event.promise.then(() => delay(flag))).then(timeout.done);\n   }\n\n   return {\n      type: 'spawn.after',\n      async action(_data, {spawned, close}) {\n         const events = createEvents();\n\n         let deferClose = true;\n         let quickClose = () => void (deferClose = false);\n\n         spawned.stdout?.on('data', quickClose);\n         spawned.stderr?.on('data', quickClose);\n         spawned.on('error', quickClose);\n\n         spawned.on('close', (code: number) => events.close(code));\n         spawned.on('exit', (code: number) => events.exit(code));\n\n         try{\n            await events.result;\n            if (deferClose) {\n               await delay(50);\n            }\n            close(events.exitCode);\n         }\n         catch (err) {\n            close(events.exitCode, err as Error);\n         }\n      }\n   }\n}\n", "import { GitError } from '../errors/git-error';\nimport { GitExecutorResult, SimpleGitPluginConfig } from '../types';\nimport { SimpleGitPlugin } from './simple-git-plugin';\n\ntype TaskResult = Omit<GitExecutorResult, 'rejection'>;\n\nfunction isTaskError (result: TaskResult) {\n   return !!(result.exitCode && result.stdErr.length);\n}\n\nfunction getErrorMessage (result: TaskResult) {\n   return Buffer.concat([...result.stdOut, ...result.stdErr]);\n}\n\nexport function errorDetectionHandler (overwrite = false, isError = isTaskError, errorMessage: (result: TaskResult) => Buffer | Error = getErrorMessage) {\n\n   return (error: Buffer | Error | undefined, result: TaskResult) => {\n      if ((!overwrite && error) || !isError(result)) {\n         return error;\n      }\n\n      return errorMessage(result);\n   };\n}\n\nexport function errorDetectionPlugin(config: SimpleGitPluginConfig['errors']): SimpleGitPlugin<'task.error'> {\n\n   return {\n      type: 'task.error',\n      action(data, context) {\n         const error = config(data.error, {\n            stdErr: context.stdErr,\n            stdOut: context.stdOut,\n            exitCode: context.exitCode\n         });\n\n         if (Buffer.isBuffer(error)) {\n            return {error: new GitError(undefined, error.toString('utf-8'))};\n         }\n\n         return {\n            error\n         };\n      },\n   };\n\n}\n", "import { SimpleGitPlugin, SimpleGitPluginType, SimpleGitPluginTypes } from './simple-git-plugin';\nimport { append, asArray } from '../utils';\n\nexport class PluginStore {\n\n   private plugins: Set<SimpleGitPlugin<SimpleGitPluginType>> = new Set();\n\n   public add<T extends SimpleGitPluginType>(plugin: void | SimpleGitPlugin<T> | SimpleGitPlugin<T>[]) {\n      const plugins: SimpleGitPlugin<T>[] = [];\n\n      asArray(plugin).forEach(plugin => plugin && this.plugins.add(append(plugins, plugin)));\n\n      return () => {\n         plugins.forEach(plugin => this.plugins.delete(plugin));\n      };\n   }\n\n   public exec<T extends SimpleGitPluginType>(type: T, data: SimpleGitPluginTypes[T]['data'], context: SimpleGitPluginTypes[T]['context']): typeof data {\n      let output = data;\n      const contextual = Object.freeze(Object.create(context));\n\n      for (const plugin of this.plugins) {\n         if (plugin.type === type) {\n            output = plugin.action(output, contextual);\n         }\n      }\n\n      return output;\n   }\n\n}\n", "import { SimpleGitOptions } from '../types';\nimport { asNumber, including } from '../utils';\n\nimport { SimpleGitPlugin } from './simple-git-plugin';\n\nexport function progressMonitorPlugin(progress: Exclude<SimpleGitOptions['progress'], void>) {\n   const progressCommand = '--progress';\n   const progressMethods = ['checkout', 'clone', 'fetch', 'pull', 'push'];\n\n   const onProgress: SimpleGitPlugin<'spawn.after'> = {\n      type: 'spawn.after',\n      action(_data, context) {\n         if (!context.commands.includes(progressCommand)) {\n            return;\n         }\n\n         context.spawned.stderr?.on('data', (chunk: Buffer) => {\n            const message = /^([\\s\\S]+?):\\s*(\\d+)% \\((\\d+)\\/(\\d+)\\)/.exec(chunk.toString('utf8'));\n            if (!message) {\n               return;\n            }\n\n            progress({\n               method: context.method,\n               stage: progressEventStage(message[1]),\n               progress: asNumber(message[2]),\n               processed: asNumber(message[3]),\n               total: asNumber(message[4]),\n            });\n         });\n      }\n   };\n\n   const onArgs: SimpleGitPlugin<'spawn.args'> = {\n      type: 'spawn.args',\n      action(args, context) {\n         if (!progressMethods.includes(context.method)) {\n            return args;\n         }\n\n         return including(args, progressCommand);\n      }\n   }\n\n   return [onArgs, onProgress];\n}\n\nfunction progressEventStage (input: string) {\n   return String(input.toLowerCase().split(' ', 1)) || 'unknown';\n}\n", "import { ChildProcess, SpawnOptions } from 'child_process';\nimport { GitExecutorResult } from '../types';\n\ntype SimpleGitTaskPluginContext = {\n   readonly method: string;\n   readonly commands: string[];\n}\n\nexport interface SimpleGitPluginTypes {\n   'spawn.args': {\n      data: string[];\n      context: SimpleGitTaskPluginContext & {};\n   };\n   'spawn.options': {\n      data: Partial<SpawnOptions>;\n      context: SimpleGitTaskPluginContext & {};\n   };\n   'spawn.after': {\n      data: void;\n      context: SimpleGitTaskPluginContext & {\n         spawned: ChildProcess;\n         close (exitCode: number, reason?: Error): void;\n         kill (reason: Error): void;\n      };\n   },\n   'task.error': {\n      data: { error?: Error };\n      context: SimpleGitTaskPluginContext & GitExecutorResult;\n   },\n}\n\nexport type SimpleGitPluginType = keyof SimpleGitPluginTypes;\n\nexport interface SimpleGitPlugin<T extends SimpleGitPluginType> {\n   action(data: SimpleGitPluginTypes[T]['data'], context: SimpleGitPluginTypes[T]['context']): typeof data;\n\n   type: T;\n}\n", "import { SpawnOptions } from 'child_process';\nimport { pick } from '../utils';\nimport { SimpleGitPlugin } from './simple-git-plugin';\n\nexport function spawnOptionsPlugin(spawnOptions: Partial<SpawnOptions>): SimpleGitPlugin<'spawn.options'> {\n   const options = pick(spawnOptions, ['uid', 'gid']);\n\n   return {\n      type: 'spawn.options',\n      action(data) {\n         return {...options, ...data};\n      },\n   };\n}\n", "import { SimpleGitOptions } from '../types';\n\nimport { SimpleGitPlugin } from './simple-git-plugin';\nimport { GitPluginError } from '../errors/git-plugin-error';\n\nexport function timeoutPlugin({block}: Exclude<SimpleGitOptions['timeout'], undefined>): SimpleGitPlugin<'spawn.after'> | void {\n\n   if (block > 0) {\n      return {\n         type: 'spawn.after',\n         action(_data, context) {\n            let timeout: NodeJS.Timeout;\n\n            function wait() {\n               timeout && clearTimeout(timeout);\n               timeout = setTimeout(kill, block);\n            }\n\n            function stop() {\n               context.spawned.stdout?.off('data', wait);\n               context.spawned.stderr?.off('data', wait);\n               context.spawned.off('exit', stop);\n               context.spawned.off('close', stop);\n               timeout && clearTimeout(timeout);\n            }\n\n            function kill() {\n               stop()\n               context.kill(\n                  new GitPluginError(undefined, 'timeout', `block timeout reached`)\n               );\n            }\n\n            context.spawned.stdout?.on('data', wait);\n            context.spawned.stderr?.on('data', wait);\n            context.spawned.on('exit', stop);\n            context.spawned.on('close', stop);\n\n            wait();\n         }\n      }\n   }\n\n}\n", "export * from './command-config-prefixing-plugin';\nexport * from './completion-detection.plugin';\nexport * from './error-detection.plugin';\nexport * from './plugin-store';\nexport * from './progress-monitor-plugin';\nexport * from './simple-git-plugin';\nexport * from './spawn-options-plugin';\nexport * from './timout-plugin';\n", "import debug, { Debugger } from 'debug';\nimport { append, filterHasLength, filterString, filterType, NOOP, objectToString, remove } from './utils';\nimport { Maybe } from './types';\n\ndebug.formatters.L = (value: any) => String(filterHasLength(value) ? value.length : '-');\ndebug.formatters.B = (value: Buffer) => {\n   if (Buffer.isBuffer(value)) {\n      return value.toString('utf8');\n   }\n   return objectToString(value);\n}\n\ntype OutputLoggingHandler = (message: string, ...args: any[]) => void;\n\nfunction createLog () {\n   return debug('simple-git');\n}\n\nexport interface OutputLogger extends OutputLoggingHandler {\n   readonly label: string;\n\n   info: OutputLoggingHandler;\n   step (nextStep?: string): OutputLogger;\n   sibling (name: string): OutputLogger;\n}\n\nfunction prefixedLogger (to: Debugger, prefix: string, forward?: OutputLoggingHandler): OutputLoggingHandler {\n   if (!prefix || !String(prefix).replace(/\\s*/, '')) {\n      return !forward ? to : (message, ...args) => {\n         to(message, ...args);\n         forward(message, ...args);\n      };\n   }\n\n   return (message, ...args) => {\n      to(`%s ${message}`, prefix, ...args);\n      if (forward) {\n         forward(message, ...args);\n      }\n   };\n}\n\nfunction childLoggerName (name: Maybe<string>, childDebugger: Maybe<Debugger>, {namespace: parentNamespace}: Debugger): string {\n   if (typeof name === 'string') {\n      return name;\n   }\n   const childNamespace = childDebugger && childDebugger.namespace || '';\n\n   if (childNamespace.startsWith(parentNamespace)) {\n      return childNamespace.substr(parentNamespace.length + 1);\n   }\n\n   return childNamespace || parentNamespace;\n}\n\nexport function createLogger (label: string, verbose?: string | Debugger, initialStep?: string, infoDebugger = createLog()): OutputLogger {\n   const labelPrefix = label && `[${label}]` || '';\n\n   const spawned: OutputLogger[] = [];\n   const debugDebugger: Maybe<Debugger> = (typeof verbose === 'string') ? infoDebugger.extend(verbose) : verbose;\n   const key = childLoggerName(filterType(verbose, filterString), debugDebugger, infoDebugger);\n\n   return step(initialStep);\n\n   function sibling(name: string, initial?: string) {\n      return append(spawned, createLogger(label, key.replace(/^[^:]+/, name), initial, infoDebugger));\n   }\n\n   function step(phase?: string) {\n      const stepPrefix = phase && `[${phase}]` || '';\n      const debug = debugDebugger && prefixedLogger(debugDebugger, stepPrefix) || NOOP;\n      const info = prefixedLogger(infoDebugger, `${labelPrefix} ${ stepPrefix}`, debug);\n\n      return Object.assign(debugDebugger ? debug : info, {\n         label,\n         sibling,\n         info,\n         step,\n      });\n   }\n}\n\n/**\n * The `GitLogger` is used by the main `SimpleGit` runner to handle logging\n * any warnings or errors.\n */\nexport class GitLogger {\n\n   public error: OutputLoggingHandler;\n\n   public warn: OutputLoggingHandler\n\n   constructor(private _out: Debugger = createLog()) {\n      this.error = prefixedLogger(_out, '[ERROR]');\n      this.warn = prefixedLogger(_out, '[WARN]');\n   }\n\n   silent (silence = false) {\n      if (silence !== this._out.enabled) {\n         return;\n      }\n\n      const {namespace} = this._out;\n      const env = (process.env.DEBUG || '').split(',').filter(s => !!s);\n      const hasOn = env.includes(namespace);\n      const hasOff = env.includes(`-${namespace}`);\n\n      // enabling the log\n      if (!silence) {\n         if (hasOff) {\n            remove(env, `-${namespace}`);\n         }\n         else {\n            env.push(namespace);\n         }\n      }\n      else {\n         if (hasOn) {\n            remove(env, namespace);\n         }\n         else {\n            env.push(`-${namespace}`);\n         }\n      }\n\n      debug.enable(env.join(','));\n   }\n\n}\n", "import { SimpleGitTask } from '../types';\nimport { GitError } from '../errors/git-error';\nimport { createLogger, OutputLogger } from '../git-logger';\n\ntype AnySimpleGitTask = SimpleGitTask<any>;\n\ntype TaskInProgress = {\n   name: string;\n   logger: OutputLogger;\n   task: AnySimpleGitTask;\n}\n\nexport class TasksPendingQueue {\n\n   private _queue: Map<AnySimpleGitTask, TaskInProgress> = new Map();\n\n   constructor(private logLabel = 'GitExecutor') {\n   }\n\n   private withProgress(task: AnySimpleGitTask) {\n      return this._queue.get(task);\n   }\n\n   private createProgress (task: AnySimpleGitTask): TaskInProgress {\n      const name = TasksPendingQueue.getName(task.commands[0]);\n      const logger = createLogger(this.logLabel, name);\n\n      return {\n         task,\n         logger,\n         name,\n      };\n   }\n\n   push(task: AnySimpleGitTask): TaskInProgress {\n      const progress = this.createProgress(task);\n      progress.logger('Adding task to the queue, commands = %o', task.commands);\n\n      this._queue.set(task, progress);\n\n      return progress;\n   }\n\n   fatal(err: GitError) {\n      for (const [task, {logger}] of Array.from(this._queue.entries())) {\n         if (task === err.task) {\n            logger.info(`Failed %o`, err);\n            logger(`Fatal exception, any as-yet un-started tasks run through this executor will not be attempted`);\n         } else {\n            logger.info(`A fatal exception occurred in a previous task, the queue has been purged: %o`, err.message);\n         }\n\n         this.complete(task);\n      }\n\n      if (this._queue.size !== 0) {\n         throw new Error(`Queue size should be zero after fatal: ${this._queue.size}`);\n      }\n   }\n\n   complete(task: AnySimpleGitTask) {\n      const progress = this.withProgress(task);\n      if (progress) {\n         this._queue.delete(task);\n      }\n   }\n\n   attempt(task: AnySimpleGitTask): TaskInProgress {\n      const progress = this.withProgress(task);\n      if (!progress) {\n         throw new GitError(undefined, 'TasksPendingQueue: attempt called for an unknown task');\n      }\n      progress.logger('Starting task');\n\n      return progress;\n   }\n\n   static getName (name = 'empty') {\n      return `task:${name}:${++TasksPendingQueue.counter}`;\n   }\n\n   private static counter = 0;\n}\n", "import { spawn, SpawnOptions } from 'child_process';\nimport { GitError } from '../errors/git-error';\nimport { OutputLogger } from '../git-logger';\nimport { PluginStore } from '../plugins';\nimport { EmptyTask, isBufferTask, isEmptyTask, } from '../tasks/task';\nimport { GitExecutorResult, Maybe, outputHandler, RunnableTask, SimpleGitExecutor, SimpleGitTask } from '../types';\nimport { callTaskParser, first, GitOutputStreams, objectToString } from '../utils';\nimport { Scheduler } from './scheduler';\nimport { TasksPendingQueue } from './tasks-pending-queue';\n\nexport class GitExecutorChain implements SimpleGitExecutor {\n\n   private _chain: Promise<any> = Promise.resolve();\n   private _queue = new TasksPendingQueue();\n   private _cwd: string | undefined;\n\n   public get binary() {\n      return this._executor.binary;\n   }\n\n   public get cwd() {\n      return this._cwd || this._executor.cwd;\n   }\n\n   public set cwd(cwd: string) {\n      this._cwd = cwd;\n   }\n\n   public get env() {\n      return this._executor.env;\n   }\n\n   public get outputHandler() {\n      return this._executor.outputHandler;\n   }\n\n   constructor(\n      private _executor: SimpleGitExecutor,\n      private _scheduler: Scheduler,\n      private _plugins: PluginStore\n   ) {\n   }\n\n   public chain() {\n      return this;\n   }\n\n   public push<R>(task: SimpleGitTask<R>): Promise<R> {\n      this._queue.push(task);\n\n      return this._chain = this._chain.then(() => this.attemptTask(task));\n   }\n\n   private async attemptTask<R>(task: SimpleGitTask<R>): Promise<void | R> {\n      const onScheduleComplete = await this._scheduler.next();\n      const onQueueComplete = () => this._queue.complete(task);\n\n      try {\n         const {logger} = this._queue.attempt(task);\n         return await (isEmptyTask(task)\n               ? this.attemptEmptyTask(task, logger)\n               : this.attemptRemoteTask(task, logger)\n         ) as R;\n      } catch (e) {\n         throw this.onFatalException(task, e as Error);\n      } finally {\n         onQueueComplete();\n         onScheduleComplete();\n      }\n   }\n\n   private onFatalException<R>(task: SimpleGitTask<R>, e: Error) {\n      const gitError = (e instanceof GitError) ? Object.assign(e, {task}) : new GitError(task, e && String(e));\n\n      this._chain = Promise.resolve();\n      this._queue.fatal(gitError);\n\n      return gitError;\n   }\n\n   private async attemptRemoteTask<R>(task: RunnableTask<R>, logger: OutputLogger) {\n      const args = this._plugins.exec('spawn.args', [...task.commands], pluginContext(task, task.commands));\n\n      const raw = await this.gitResponse(\n         task,\n         this.binary, args, this.outputHandler, logger.step('SPAWN'),\n      );\n      const outputStreams = await this.handleTaskData(task, args, raw, logger.step('HANDLE'));\n\n      logger(`passing response to task's parser as a %s`, task.format);\n\n      if (isBufferTask(task)) {\n         return callTaskParser(task.parser, outputStreams);\n      }\n\n      return callTaskParser(task.parser, outputStreams.asStrings());\n   }\n\n   private async attemptEmptyTask(task: EmptyTask, logger: OutputLogger) {\n      logger(`empty task bypassing child process to call to task's parser`);\n      return task.parser(this);\n   }\n\n   private handleTaskData<R>(\n      task: SimpleGitTask<R>,\n      args: string[],\n      result: GitExecutorResult, logger: OutputLogger): Promise<GitOutputStreams> {\n\n      const {exitCode, rejection, stdOut, stdErr} = result;\n\n      return new Promise((done, fail) => {\n         logger(`Preparing to handle process response exitCode=%d stdOut=`, exitCode);\n\n         const {error} = this._plugins.exec('task.error', {error: rejection}, {\n            ...pluginContext(task, args),\n            ...result,\n         });\n\n         if (error && task.onError) {\n            logger.info(`exitCode=%s handling with custom error handler`);\n\n            return task.onError(\n               result,\n               error,\n               (newStdOut) => {\n                  logger.info(`custom error handler treated as success`);\n                  logger(`custom error returned a %s`, objectToString(newStdOut));\n\n                  done(new GitOutputStreams(\n                     Array.isArray(newStdOut) ? Buffer.concat(newStdOut) : newStdOut,\n                     Buffer.concat(stdErr),\n                  ));\n               },\n               fail\n            );\n         }\n\n         if (error) {\n            logger.info(`handling as error: exitCode=%s stdErr=%s rejection=%o`, exitCode, stdErr.length, rejection);\n            return fail(error);\n         }\n\n         logger.info(`retrieving task output complete`);\n         done(new GitOutputStreams(\n            Buffer.concat(stdOut),\n            Buffer.concat(stdErr),\n         ));\n      });\n   }\n\n   private async gitResponse<R>(task: SimpleGitTask<R>, command: string, args: string[], outputHandler: Maybe<outputHandler>, logger: OutputLogger): Promise<GitExecutorResult> {\n      const outputLogger = logger.sibling('output');\n      const spawnOptions: SpawnOptions = this._plugins.exec('spawn.options', {\n         cwd: this.cwd,\n         env: this.env,\n         windowsHide: true,\n      }, pluginContext(task, task.commands));\n\n      return new Promise((done) => {\n         const stdOut: Buffer[] = [];\n         const stdErr: Buffer[] = [];\n\n         let rejection: Maybe<Error>;\n\n         logger.info(`%s %o`, command, args);\n         logger('%O', spawnOptions)\n         const spawned = spawn(command, args, spawnOptions);\n\n         spawned.stdout!.on('data', onDataReceived(stdOut, 'stdOut', logger, outputLogger.step('stdOut')));\n         spawned.stderr!.on('data', onDataReceived(stdErr, 'stdErr', logger, outputLogger.step('stdErr')));\n\n         spawned.on('error', onErrorReceived(stdErr, logger));\n\n         if (outputHandler) {\n            logger(`Passing child process stdOut/stdErr to custom outputHandler`);\n            outputHandler(command, spawned.stdout!, spawned.stderr!, [...args]);\n         }\n\n         this._plugins.exec('spawn.after', undefined, {\n            ...pluginContext(task, args),\n            spawned,\n            close(exitCode: number, reason?: Error) {\n               done({\n                  stdOut,\n                  stdErr,\n                  exitCode,\n                  rejection: rejection || reason,\n               });\n            },\n            kill(reason: Error) {\n               if (spawned.killed) {\n                  return;\n               }\n\n               rejection = reason;\n               spawned.kill('SIGINT');\n            },\n         });\n      });\n   }\n\n}\n\nfunction pluginContext<R>(task: SimpleGitTask<R>, commands: string[]) {\n   return {\n      method: first(task.commands) || '',\n      commands,\n   }\n}\n\nfunction onErrorReceived(target: Buffer[], logger: OutputLogger) {\n   return (err: Error) => {\n      logger(`[ERROR] child process exception %o`, err);\n      target.push(Buffer.from(String(err.stack), 'ascii'));\n   }\n}\n\nfunction onDataReceived(target: Buffer[], name: string, logger: OutputLogger, output: OutputLogger) {\n   return (buffer: Buffer) => {\n      logger(`%s received %L bytes`, name, buffer);\n      output(`%B`, buffer);\n      target.push(buffer)\n   }\n}\n", "import type { PluginStore } from '../plugins';\nimport type { GitExecutorEnv, outputHandler, SimpleGitExecutor, SimpleGitTask } from '../types';\n\nimport { GitExecutorChain } from './git-executor-chain';\nimport { Scheduler } from './scheduler';\n\nexport class GitExecutor implements SimpleGitExecutor {\n\n   private _chain = new GitExecutorChain(this, this._scheduler, this._plugins);\n\n   public env: GitExecutorEnv;\n   public outputHandler?: outputHandler;\n\n   constructor(\n      public binary: string = 'git',\n      public cwd: string,\n      private _scheduler: Scheduler,\n      private _plugins: PluginStore,\n   ) {\n   }\n\n   chain(): SimpleGitExecutor {\n      return new GitExecutorChain(this, this._scheduler, this._plugins);\n   }\n\n   push<R>(task: SimpleGitTask<R>): Promise<R> {\n      return this._chain.push(task);\n   }\n\n}\n\n\n", "import { GitError } from './errors/git-error';\nimport { GitResponseError } from './errors/git-response-error';\nimport { SimpleGitTask, SimpleGitTaskCallback } from './types';\nimport { NOOP } from './utils';\n\nexport function taskCallback<R>(task: SimpleGitTask<R>, response: Promise<R>, callback: SimpleGitTaskCallback<R> = NOOP) {\n\n   const onSuccess = (data: R) => {\n      callback(null, data);\n   };\n\n   const onError = (err: GitError | GitResponseError) => {\n      if (err?.task === task) {\n         callback((err instanceof GitResponseError) ? addDeprecationNoticeToError(err) : err, undefined as any);\n      }\n   };\n\n   response.then(onSuccess, onError);\n\n}\n\nfunction addDeprecationNoticeToError (err: GitResponseError) {\n   let log = (name: string) => {\n      console.warn(`simple-git deprecation notice: accessing GitResponseError.${name} should be GitResponseError.git.${name}, this will no longer be available in version 3`);\n      log = NOOP;\n   };\n\n   return Object.create(err, Object.getOwnPropertyNames(err.git).reduce(descriptorReducer, {}));\n\n   function descriptorReducer(all: PropertyDescriptorMap, name: string): typeof all {\n      if (name in err) {\n         return all;\n      }\n\n      all[name] = {\n         enumerable: false,\n         configurable: false,\n         get () {\n            log(name);\n            return err.git[name];\n         },\n      };\n\n      return all;\n   }\n}\n", "import { folderExists } from '../utils';\nimport { SimpleGitExecutor } from '../types';\nimport { adhocExecTask } from './task';\n\nexport function changeWorkingDirectoryTask (directory: string, root?: SimpleGitExecutor) {\n   return adhocExecTask((instance: SimpleGitExecutor) => {\n      if (!folderExists(directory)) {\n         throw new Error(`Git.cwd: cannot change to non-directory \"${ directory }\"`);\n      }\n\n      return ((root || instance).cwd = directory);\n   });\n}\n", "import { CommitResult } from '../../../typings';\nimport { LineParser, parseStringResponse } from '../utils';\n\nconst parsers: LineParser<CommitResult>[] = [\n   new LineParser(/^\\[([^\\s]+)( \\([^)]+\\))? ([^\\]]+)/, (result, [branch, root, commit]) => {\n      result.branch = branch;\n      result.commit = commit;\n      result.root = !!root;\n   }),\n   new LineParser(/\\s*Author:\\s(.+)/i, (result, [author]) => {\n      const parts = author.split('<');\n      const email = parts.pop();\n\n      if (!email || !email.includes('@')) {\n         return;\n      }\n\n      result.author = {\n         email: email.substr(0, email.length - 1),\n         name: parts.join('<').trim()\n      };\n   }),\n   new LineParser(/(\\d+)[^,]*(?:,\\s*(\\d+)[^,]*)(?:,\\s*(\\d+))/g, (result, [changes, insertions, deletions]) => {\n      result.summary.changes = parseInt(changes, 10) || 0;\n      result.summary.insertions = parseInt(insertions, 10) || 0;\n      result.summary.deletions = parseInt(deletions, 10) || 0;\n   }),\n   new LineParser(/^(\\d+)[^,]*(?:,\\s*(\\d+)[^(]+\\(([+-]))?/, (result, [changes, lines, direction]) => {\n      result.summary.changes = parseInt(changes, 10) || 0;\n      const count = parseInt(lines, 10) || 0;\n      if (direction === '-') {\n         result.summary.deletions = count;\n      } else if (direction === '+') {\n         result.summary.insertions = count;\n      }\n   }),\n];\n\nexport function parseCommitResult(stdOut: string): CommitResult {\n   const result: CommitResult = {\n      author: null,\n      branch: '',\n      commit: '',\n      root: false,\n      summary: {\n         changes: 0,\n         insertions: 0,\n         deletions: 0,\n      },\n   };\n   return parseStringResponse(result, parsers, stdOut);\n}\n", "import type { CommitResult, SimpleGit } from '../../../typings';\nimport type { SimpleGitApi } from '../simple-git-api';\nimport type { StringTask } from '../types';\nimport { parseCommitResult } from '../parsers/parse-commit';\nimport {\n   asArray,\n   filterArray,\n   filterStringOrStringArray,\n   filterType,\n   getTrailingOptions, prefixedArray,\n   trailingFunctionArgument\n} from '../utils';\nimport { configurationErrorTask } from './task';\n\nexport function commitTask(message: string[], files: string[], customArgs: string[]): StringTask<CommitResult> {\n   const commands: string[] = [\n      '-c',\n      'core.abbrev=40',\n      'commit',\n      ...prefixedArray(message, '-m'),\n      ...files,\n      ...customArgs,\n   ];\n\n   return {\n      commands,\n      format: 'utf-8',\n      parser: parseCommitResult,\n   };\n}\n\nexport default function (): Pick<SimpleGit, 'commit'> {\n   return {\n      commit(this: SimpleGitApi, message: string | string[], ...rest: unknown[]) {\n         const next = trailingFunctionArgument(arguments);\n         const task = rejectDeprecatedSignatures(message) ||\n            commitTask(\n               asArray(message),\n               asArray(filterType(rest[0], filterStringOrStringArray, [])),\n               [...filterType(rest[1], filterArray, []), ...getTrailingOptions(arguments, 0, true)]\n            );\n\n         return this._runTask(task, next);\n      },\n   };\n\n   function rejectDeprecatedSignatures(message?: unknown) {\n      return (\n         !filterStringOrStringArray(message) &&\n         configurationErrorTask(`git.commit: requires the commit message to be supplied as a string/string[]`)\n      );\n   }\n}\n", "import { straightThroughStringTask } from './task';\nimport { StringTask } from '../types';\n\n/**\n * Task used by `git.hashObject`\n */\nexport function hashObjectTask(filePath: string, write: boolean): StringTask<string> {\n   const commands = ['hash-object', filePath];\n   if (write) {\n      commands.push('-w');\n   }\n\n   return straightThroughStringTask(commands, true);\n}\n", "import { InitResult } from '../../../typings';\n\nexport class InitSummary implements InitResult {\n   constructor(\n      public readonly bare: boolean,\n      public readonly path: string,\n      public readonly existing: boolean,\n      public readonly gitDir: string,\n   ) {}\n}\n\nconst initResponseRegex = /^Init.+ repository in (.+)$/;\nconst reInitResponseRegex = /^Rein.+ in (.+)$/;\n\nexport function parseInit(bare: boolean, path: string, text: string) {\n   const response = String(text).trim();\n   let result;\n\n   if ((result = initResponseRegex.exec(response))) {\n      return new InitSummary(bare, path, false, result[1]);\n   }\n\n   if ((result = reInitResponseRegex.exec(response))) {\n      return new InitSummary(bare, path, true, result[1]);\n   }\n\n   let gitDir = '';\n   const tokens = response.split(' ');\n   while (tokens.length) {\n      const token = tokens.shift();\n      if (token === 'in') {\n         gitDir = tokens.join(' ');\n         break;\n      }\n   }\n\n   return new InitSummary(bare, path, /^re/i.test(response), gitDir);\n}\n", "import { InitResult } from '../../../typings';\nimport { parseInit } from '../responses/InitSummary';\nimport { StringTask } from '../types';\n\nconst bareCommand = '--bare';\n\nfunction hasBareCommand(command: string[]) {\n   return command.includes(bareCommand);\n}\n\nexport function initTask(bare = false, path: string, customArgs: string[]): StringTask<InitResult> {\n   const commands = ['init', ...customArgs];\n   if (bare && !hasBareCommand(commands)) {\n      commands.splice(1, 0, bareCommand);\n   }\n\n   return {\n      commands,\n      format: 'utf-8',\n      parser(text: string): InitResult {\n         return parseInit(commands.includes('--bare'), path, text);\n      }\n   }\n}\n", "export enum LogFormat {\n   NONE = '',\n   STAT = '--stat',\n   NUM_STAT = '--numstat',\n   NAME_ONLY = '--name-only',\n   NAME_STATUS = '--name-status',\n}\n\nconst logFormatRegex = /^--(stat|numstat|name-only|name-status)(=|$)/;\n\nexport function logFormatFromCommand(customArgs: string[]) {\n   for (let i = 0; i < customArgs.length; i++) {\n      const format = logFormatRegex.exec(customArgs[i]);\n      if (format) {\n         return `--${format[1]}` as LogFormat;\n      }\n   }\n\n   return LogFormat.NONE;\n}\n\nexport function isLogFormat(customArg: string | unknown) {\n   return logFormatRegex.test(customArg as string);\n}\n", "import { DiffResult, DiffResultBinaryFile, DiffResultTextFile } from '../../../typings';\n\n/***\n * The DiffSummary is returned as a response to getting `git().status()`\n */\nexport class DiffSummary implements DiffResult {\n   changed = 0\n   deletions = 0;\n   insertions = 0;\n\n   files: Array<DiffResultTextFile | DiffResultBinaryFile> = [];\n}\n", "import { DiffResult } from '../../../typings';\nimport { LogFormat } from '../args/log-format';\nimport { DiffSummary } from '../responses/DiffSummary';\nimport { asNumber, LineParser, parseStringResponse } from '../utils';\n\nconst statParser = [\n   new LineParser<DiffResult>(/(.+)\\s+\\|\\s+(\\d+)(\\s+[+\\-]+)?$/, (result, [file, changes, alterations = '']) => {\n      result.files.push({\n         file: file.trim(),\n         changes: asNumber(changes),\n         insertions: alterations.replace(/[^+]/g, '').length,\n         deletions: alterations.replace(/[^-]/g, '').length,\n         binary: false\n      });\n   }),\n   new LineParser<DiffResult>(/(.+) \\|\\s+Bin ([0-9.]+) -> ([0-9.]+) ([a-z]+)/, (result, [file, before, after]) => {\n      result.files.push({\n         file: file.trim(),\n         before: asNumber(before),\n         after: asNumber(after),\n         binary: true\n      });\n   }),\n   new LineParser<DiffResult>(/(\\d+) files? changed\\s*((?:, \\d+ [^,]+){0,2})/, (result, [changed, summary]) => {\n      const inserted = /(\\d+) i/.exec(summary);\n      const deleted = /(\\d+) d/.exec(summary);\n\n      result.changed = asNumber(changed);\n      result.insertions = asNumber(inserted?.[1]);\n      result.deletions = asNumber(deleted?.[1]);\n   })\n];\n\nconst numStatParser = [\n   new LineParser<DiffResult>(/(\\d+)\\t(\\d+)\\t(.+)$/, (result, [changesInsert, changesDelete, file]) => {\n      const insertions = asNumber(changesInsert);\n      const deletions = asNumber(changesDelete);\n\n      result.changed++;\n      result.insertions += insertions;\n      result.deletions += deletions;\n\n      result.files.push({\n         file,\n         changes: insertions + deletions,\n         insertions,\n         deletions,\n         binary: false,\n      });\n   }),\n   new LineParser<DiffResult>(/-\\t-\\t(.+)$/, (result, [file]) => {\n      result.changed++;\n\n      result.files.push({\n         file,\n         after: 0,\n         before: 0,\n         binary: true,\n      });\n   })\n];\n\nconst nameOnlyParser = [\n   new LineParser<DiffResult>(/(.+)$/, (result, [file]) => {\n      result.changed++;\n      result.files.push({\n         file,\n         changes: 0,\n         insertions: 0,\n         deletions: 0,\n         binary: false,\n      });\n   })\n];\n\nconst nameStatusParser = [\n   new LineParser<DiffResult>(/([ACDMRTUXB])\\s*(.+)$/, (result, [_status, file]) => {\n      result.changed++;\n      result.files.push({\n         file,\n         changes: 0,\n         insertions: 0,\n         deletions: 0,\n         binary: false,\n      });\n   })\n];\n\nconst diffSummaryParsers: Record<LogFormat, LineParser<DiffResult>[]> = {\n   [LogFormat.NONE]: statParser,\n   [LogFormat.STAT]: statParser,\n   [LogFormat.NUM_STAT]: numStatParser,\n   [LogFormat.NAME_STATUS]: nameStatusParser,\n   [LogFormat.NAME_ONLY]: nameOnlyParser,\n};\n\nexport function getDiffParser(format = LogFormat.NONE) {\n   const parser = diffSummaryParsers[format];\n\n   return (stdOut: string) => parseStringResponse(new DiffSummary(), parser, stdOut, false);\n}\n", "import { ListLogLine, LogResult } from '../../../typings';\nimport { toLinesWithContent } from '../utils';\nimport { getDiffParser } from './parse-diff-summary';\nimport { LogFormat } from '../args/log-format';\n\nexport const START_BOUNDARY = '\u00F2\u00F2\u00F2\u00F2\u00F2\u00F2 ';\n\nexport const COMMIT_BOUNDARY = ' \u00F2\u00F2';\n\nexport const SPLITTER = ' \u00F2 ';\n\nconst defaultFieldNames = ['hash', 'date', 'message', 'refs', 'author_name', 'author_email'];\n\nfunction lineBuilder(tokens: string[], fields: string[]): any {\n   return fields.reduce((line, field, index) => {\n      line[field] = tokens[index] || '';\n      return line;\n   }, Object.create({diff: null}) as any);\n}\n\nexport function createListLogSummaryParser<T = any> (splitter = SPLITTER, fields = defaultFieldNames, logFormat = LogFormat.NONE) {\n   const parseDiffResult = getDiffParser(logFormat);\n\n   return function (stdOut: string): LogResult<T> {\n      const all: ReadonlyArray<T & ListLogLine> = toLinesWithContent(stdOut, true, START_BOUNDARY)\n         .map(function (item) {\n            const lineDetail = item.trim().split(COMMIT_BOUNDARY);\n            const listLogLine: T & ListLogLine = lineBuilder(lineDetail[0].trim().split(splitter), fields);\n\n            if (lineDetail.length > 1 && !!lineDetail[1].trim()) {\n               listLogLine.diff = parseDiffResult(lineDetail[1]);\n            }\n\n            return listLogLine;\n         });\n\n      return {\n         all,\n         latest: all.length && all[0] || null,\n         total: all.length,\n      };\n   }\n}\n", "import { StringTask } from '../types';\nimport { DiffResult } from '../../../typings';\nimport { isLogFormat, LogFormat, logFormatFromCommand } from '../args/log-format';\nimport { getDiffParser } from '../parsers/parse-diff-summary';\nimport { configurationErrorTask, EmptyTask } from './task';\n\nexport function diffSummaryTask(customArgs: string[]): StringTask<DiffResult> | EmptyTask {\n   let logFormat = logFormatFromCommand(customArgs);\n\n   const commands = ['diff'];\n\n   if (logFormat === LogFormat.NONE) {\n      logFormat = LogFormat.STAT;\n      commands.push('--stat=4096');\n   }\n\n   commands.push(...customArgs);\n\n   return validateLogFormatConfig(commands) || {\n      commands,\n      format: 'utf-8',\n      parser: getDiffParser(logFormat),\n   };\n}\n\nexport function validateLogFormatConfig(customArgs: unknown[]): EmptyTask | void {\n   const flags = customArgs.filter(isLogFormat);\n\n   if (flags.length > 1) {\n      return configurationErrorTask(`Summary flags are mutually exclusive - pick one of ${flags.join(',')}`);\n   }\n\n   if (flags.length && customArgs.includes('-z')) {\n      return configurationErrorTask(`Summary flag ${flags} parsing is not compatible with null termination option '-z'`);\n   }\n}\n", "import type { Options, StringTask } from '../types';\nimport type { LogResult, SimpleGit } from '../../../typings';\nimport { logFormatFromCommand } from '../args/log-format';\nimport {\n   COMMIT_BOUNDARY,\n   createListLogSummaryParser,\n   SPLITTER,\n   START_BOUNDARY\n} from '../parsers/parse-list-log-summary';\nimport {\n   appendTaskOptions,\n   filterArray,\n   filterPrimitives,\n   filterString,\n   filterType,\n   trailingFunctionArgument,\n   trailingOptionsArgument\n} from '../utils';\nimport { SimpleGitApi } from '../simple-git-api';\nimport { configurationErrorTask } from './task';\nimport { validateLogFormatConfig } from './diff';\n\nenum excludeOptions {\n   '--pretty',\n   'max-count',\n   'maxCount',\n   'n',\n   'file',\n   'format',\n   'from',\n   'to',\n   'splitter',\n   'symmetric',\n   'mailMap',\n   'multiLine',\n   'strictDate',\n}\n\nexport interface DefaultLogFields {\n   hash: string;\n   date: string;\n   message: string;\n   refs: string;\n   body: string;\n   author_name: string;\n   author_email: string;\n}\n\nexport type LogOptions<T = DefaultLogFields> = {\n   file?: string;\n   format?: T;\n   from?: string;\n   mailMap?: boolean;\n   maxCount?: number;\n   multiLine?: boolean;\n   splitter?: string;\n   strictDate?: boolean;\n   symmetric?: boolean;\n   to?: string;\n};\n\ninterface ParsedLogOptions {\n   fields: string[];\n   splitter: string;\n   commands: string[]\n}\n\nfunction prettyFormat(format: Record<string, string | unknown>, splitter: string): [string[], string] {\n   const fields: string[] = [];\n   const formatStr: string[] = [];\n\n   Object.keys(format).forEach((field) => {\n      fields.push(field);\n      formatStr.push(String(format[field]));\n   });\n\n   return [\n      fields, formatStr.join(splitter)\n   ];\n}\n\nfunction userOptions<T extends Options>(input: T): Options {\n   return Object.keys(input).reduce((out, key) => {\n      if (!(key in excludeOptions)) {\n         out[key] = input[key];\n      }\n      return out;\n   }, {} as Options);\n}\n\nexport function parseLogOptions<T extends Options>(opt: Options | LogOptions<T> = {}, customArgs: string[] = []): ParsedLogOptions {\n   const splitter = filterType(opt.splitter, filterString, SPLITTER);\n   const format = !filterPrimitives(opt.format) && opt.format ? opt.format : {\n      hash: '%H',\n      date: opt.strictDate === false ? '%ai' : '%aI',\n      message: '%s',\n      refs: '%D',\n      body: opt.multiLine ? '%B' : '%b',\n      author_name: opt.mailMap !== false ? '%aN' : '%an',\n      author_email: opt.mailMap !== false ? '%aE' : '%ae'\n   };\n\n   const [fields, formatStr] = prettyFormat(format, splitter);\n\n   const suffix: string[] = [];\n   const command: string[] = [\n      `--pretty=format:${START_BOUNDARY}${formatStr}${COMMIT_BOUNDARY}`,\n      ...customArgs,\n   ];\n\n   const maxCount: number | undefined = (opt as any).n || (opt as any)['max-count'] || opt.maxCount;\n   if (maxCount) {\n      command.push(`--max-count=${maxCount}`);\n   }\n\n   if (opt.from && opt.to) {\n      const rangeOperator = (opt.symmetric !== false) ? '...' : '..';\n      suffix.push(`${opt.from}${rangeOperator}${opt.to}`);\n   }\n\n   if (filterString(opt.file)) {\n      suffix.push('--follow', opt.file);\n   }\n\n   appendTaskOptions(userOptions(opt as Options), command);\n\n   return {\n      fields,\n      splitter,\n      commands: [\n         ...command,\n         ...suffix,\n      ],\n   };\n}\n\nexport function logTask<T>(splitter: string, fields: string[], customArgs: string[]): StringTask<LogResult<T>> {\n   const parser = createListLogSummaryParser(splitter, fields, logFormatFromCommand(customArgs));\n\n   return {\n      commands: ['log', ...customArgs],\n      format: 'utf-8',\n      parser,\n   };\n}\n\nexport default function (): Pick<SimpleGit, 'log'> {\n   return {\n      log<T extends Options>(this: SimpleGitApi, ...rest: unknown[]) {\n         const next = trailingFunctionArgument(arguments);\n         const options = parseLogOptions<T>(trailingOptionsArgument(arguments), filterType(arguments[0], filterArray));\n         const task = rejectDeprecatedSignatures(...rest) ||\n            validateLogFormatConfig(options.commands) ||\n            createLogTask(options);\n\n         return this._runTask(task, next);\n      }\n   }\n\n   function createLogTask(options: ParsedLogOptions) {\n      return logTask(options.splitter, options.fields, options.commands);\n   }\n\n   function rejectDeprecatedSignatures(from?: unknown, to?: unknown) {\n      return (\n         filterString(from) &&\n         filterString(to) &&\n         configurationErrorTask(`git.log(string, string) should be replaced with git.log({ from: string, to: string })`)\n      );\n   }\n}\n", "import { MergeConflict, MergeConflictDeletion, MergeDetail, MergeResultStatus } from '../../../typings';\n\nexport class MergeSummaryConflict implements MergeConflict {\n   constructor(\n      public readonly reason: string,\n      public readonly file: string | null = null,\n      public readonly meta?: MergeConflictDeletion,\n   ) {\n   }\n\n   toString() {\n      return `${this.file}:${this.reason}`;\n   }\n}\n\nexport class MergeSummaryDetail implements MergeDetail {\n   public conflicts: MergeConflict[] = [];\n   public merges: string[] = [];\n   public result: MergeResultStatus = 'success';\n\n   get failed() {\n      return this.conflicts.length > 0;\n   }\n\n   get reason() {\n      return this.result;\n   }\n\n   toString() {\n      if (this.conflicts.length) {\n         return `CONFLICTS: ${this.conflicts.join(', ')}`;\n      }\n\n      return 'OK';\n   }\n}\n\n", "import { PullDetailFileChanges, PullDetailSummary, PullFailedResult, PullResult } from '../../../typings';\n\nexport class PullSummary implements PullResult {\n   public remoteMessages = {\n      all: [],\n   };\n   public created = [];\n   public deleted: string[] = [];\n   public files: string[] = [];\n   public deletions: PullDetailFileChanges = {};\n   public insertions: PullDetailFileChanges = {};\n   public summary: PullDetailSummary = {\n      changes: 0,\n      deletions: 0,\n      insertions: 0,\n   };\n}\n\nexport class PullFailedSummary implements PullFailedResult {\n   remote = '';\n   hash = {\n      local: '',\n      remote: '',\n   };\n   branch = {\n      local: '',\n      remote: '',\n   };\n   message = '';\n\n   toString() {\n      return this.message;\n   }\n}\n\n", "import { RemoteMessageResult, RemoteMessages, RemoteMessagesObjectEnumeration } from '../../../typings';\nimport { asNumber, RemoteLineParser } from '../utils';\n\nfunction objectEnumerationResult<T extends RemoteMessages = RemoteMessages>(remoteMessages: T): RemoteMessagesObjectEnumeration {\n   return (remoteMessages.objects = remoteMessages.objects || {\n      compressing: 0,\n      counting: 0,\n      enumerating: 0,\n      packReused: 0,\n      reused: {count: 0, delta: 0},\n      total: {count: 0, delta: 0}\n   });\n}\n\nfunction asObjectCount(source: string) {\n   const count = /^\\s*(\\d+)/.exec(source);\n   const delta = /delta (\\d+)/i.exec(source);\n\n   return {\n      count: asNumber(count && count[1] || '0'),\n      delta: asNumber(delta && delta[1] || '0'),\n   };\n}\n\nexport const remoteMessagesObjectParsers: RemoteLineParser<RemoteMessageResult<RemoteMessages>>[] = [\n   new RemoteLineParser(/^remote:\\s*(enumerating|counting|compressing) objects: (\\d+),/i, (result, [action, count]) => {\n      const key = action.toLowerCase();\n      const enumeration = objectEnumerationResult(result.remoteMessages);\n\n      Object.assign(enumeration, {[key]: asNumber(count)});\n   }),\n   new RemoteLineParser(/^remote:\\s*(enumerating|counting|compressing) objects: \\d+% \\(\\d+\\/(\\d+)\\),/i, (result, [action, count]) => {\n      const key = action.toLowerCase();\n      const enumeration = objectEnumerationResult(result.remoteMessages);\n\n      Object.assign(enumeration, {[key]: asNumber(count)});\n   }),\n   new RemoteLineParser(/total ([^,]+), reused ([^,]+), pack-reused (\\d+)/i, (result, [total, reused, packReused]) => {\n      const objects = objectEnumerationResult(result.remoteMessages);\n      objects.total = asObjectCount(total);\n      objects.reused = asObjectCount(reused);\n      objects.packReused = asNumber(packReused);\n   }),\n];\n", "import { PushResultRemoteMessages, RemoteMessageResult, RemoteMessages } from '../../../typings';\nimport { asNumber, parseStringResponse, RemoteLineParser } from '../utils';\nimport { remoteMessagesObjectParsers } from './parse-remote-objects';\n\nconst parsers: RemoteLineParser<RemoteMessageResult<PushResultRemoteMessages | RemoteMessages>>[] = [\n   new RemoteLineParser(/^remote:\\s*(.+)$/, (result, [text]) => {\n      result.remoteMessages.all.push(text.trim());\n      return false;\n   }),\n   ...remoteMessagesObjectParsers,\n   new RemoteLineParser([/create a (?:pull|merge) request/i, /\\s(https?:\\/\\/\\S+)$/], (result, [pullRequestUrl]) => {\n      (result.remoteMessages as PushResultRemoteMessages).pullRequestUrl = pullRequestUrl;\n   }),\n   new RemoteLineParser([/found (\\d+) vulnerabilities.+\\(([^)]+)\\)/i, /\\s(https?:\\/\\/\\S+)$/], (result, [count, summary, url]) => {\n      (result.remoteMessages as PushResultRemoteMessages).vulnerabilities = {\n         count: asNumber(count),\n         summary,\n         url,\n      };\n   }),\n];\n\nexport function parseRemoteMessages<T extends RemoteMessages = RemoteMessages>(\n   _stdOut: string, stdErr: string,\n): RemoteMessageResult {\n   return parseStringResponse({remoteMessages: new RemoteMessageSummary() as T}, parsers, stdErr);\n}\n\nexport class RemoteMessageSummary implements RemoteMessages {\n   public readonly all: string[] = [];\n}\n", "import { PullDetail, PullFailedResult, PullResult, RemoteMessages } from '../../../typings';\nimport { PullFailedSummary, PullSummary } from '../responses/PullSummary';\nimport { TaskParser } from '../types';\nimport { append, LineParser, parseStringResponse } from '../utils';\nimport { parseRemoteMessages } from './parse-remote-messages';\n\nconst FILE_UPDATE_REGEX = /^\\s*(.+?)\\s+\\|\\s+\\d+\\s*(\\+*)(-*)/;\nconst SUMMARY_REGEX = /(\\d+)\\D+((\\d+)\\D+\\(\\+\\))?(\\D+(\\d+)\\D+\\(-\\))?/;\nconst ACTION_REGEX = /^(create|delete) mode \\d+ (.+)/;\n\nconst parsers: LineParser<PullResult>[] = [\n   new LineParser(FILE_UPDATE_REGEX, (result, [file, insertions, deletions]) => {\n      result.files.push(file);\n\n      if (insertions) {\n         result.insertions[file] = insertions.length;\n      }\n\n      if (deletions) {\n         result.deletions[file] = deletions.length;\n      }\n   }),\n   new LineParser(SUMMARY_REGEX, (result, [changes, , insertions, , deletions]) => {\n      if (insertions !== undefined || deletions !== undefined) {\n         result.summary.changes = +changes || 0;\n         result.summary.insertions = +insertions || 0;\n         result.summary.deletions = +deletions || 0;\n         return true;\n      }\n      return false;\n   }),\n   new LineParser(ACTION_REGEX, (result, [action, file]) => {\n      append(result.files, file);\n      append((action === 'create') ? result.created : result.deleted, file);\n   }),\n];\n\nconst errorParsers: LineParser<PullFailedResult>[] = [\n   new LineParser(/^from\\s(.+)$/i, (result, [remote]) => void (result.remote = remote)),\n   new LineParser(/^fatal:\\s(.+)$/, (result, [message]) => void (result.message = message)),\n   new LineParser(/([a-z0-9]+)\\.\\.([a-z0-9]+)\\s+(\\S+)\\s+->\\s+(\\S+)$/, (result, [hashLocal, hashRemote, branchLocal, branchRemote]) => {\n      result.branch.local = branchLocal;\n      result.hash.local = hashLocal;\n      result.branch.remote = branchRemote;\n      result.hash.remote = hashRemote;\n   }),\n];\n\nexport const parsePullDetail: TaskParser<string, PullDetail> = (stdOut, stdErr) => {\n   return parseStringResponse(new PullSummary(), parsers, [stdOut, stdErr]);\n}\n\nexport const parsePullResult: TaskParser<string, PullResult> = (stdOut, stdErr) => {\n   return Object.assign(\n      new PullSummary(),\n      parsePullDetail(stdOut, stdErr),\n      parseRemoteMessages<RemoteMessages>(stdOut, stdErr),\n   );\n}\n\nexport function parsePullErrorResult(stdOut: string, stdErr: string) {\n   const pullError = parseStringResponse(new PullFailedSummary(), errorParsers, [stdOut, stdErr]);\n\n   return pullError.message && pullError;\n}\n", "import { MergeDetail, MergeResult } from '../../../typings';\nimport { MergeSummaryConflict, MergeSummaryDetail } from '../responses/MergeSummary';\nimport { TaskParser } from '../types';\nimport { LineParser, parseStringResponse } from '../utils';\nimport { parsePullResult } from './parse-pull';\n\nconst parsers: LineParser<MergeDetail>[] = [\n   new LineParser(/^Auto-merging\\s+(.+)$/, (summary, [autoMerge]) => {\n      summary.merges.push(autoMerge);\n   }),\n   new LineParser(/^CONFLICT\\s+\\((.+)\\): Merge conflict in (.+)$/, (summary, [reason, file]) => {\n      summary.conflicts.push(new MergeSummaryConflict(reason, file));\n   }),\n   new LineParser(/^CONFLICT\\s+\\((.+\\/delete)\\): (.+) deleted in (.+) and/, (summary, [reason, file, deleteRef]) => {\n      summary.conflicts.push(new MergeSummaryConflict(reason, file, {deleteRef}));\n   }),\n   new LineParser(/^CONFLICT\\s+\\((.+)\\):/, (summary, [reason]) => {\n      summary.conflicts.push(new MergeSummaryConflict(reason, null));\n   }),\n   new LineParser(/^Automatic merge failed;\\s+(.+)$/, (summary, [result]) => {\n      summary.result = result;\n   }),\n];\n\n/**\n * Parse the complete response from `git.merge`\n */\nexport const parseMergeResult: TaskParser<string, MergeResult> = (stdOut, stdErr) => {\n   return Object.assign(\n      parseMergeDetail(stdOut, stdErr),\n      parsePullResult(stdOut, stdErr),\n   );\n};\n\n/**\n * Parse the merge specific detail (ie: not the content also available in the pull detail) from `git.mnerge`\n * @param stdOut\n */\nexport const parseMergeDetail: TaskParser<string, MergeDetail> = (stdOut) => {\n   return parseStringResponse(new MergeSummaryDetail(), parsers, stdOut);\n}\n", "import { MergeResult } from '../../../typings';\nimport { GitResponseError } from '../errors/git-response-error';\nimport { parseMergeResult } from '../parsers/parse-merge';\nimport { StringTask } from '../types';\nimport { configurationErrorTask, EmptyTask } from './task';\n\nexport function mergeTask(customArgs: string[]): EmptyTask | StringTask<MergeResult> {\n   if (!customArgs.length) {\n      return configurationErrorTask('Git.merge requires at least one option');\n   }\n\n   return {\n      commands: ['merge', ...customArgs],\n      format: 'utf-8',\n      parser(stdOut, stdErr): MergeResult {\n         const merge = parseMergeResult(stdOut, stdErr);\n         if (merge.failed) {\n            throw new GitResponseError(merge);\n         }\n\n         return merge;\n      }\n   }\n}\n", "import { PushDetail, PushResult, PushResultPushedItem, PushResultRemoteMessages } from '../../../typings';\nimport { TaskParser } from '../types';\nimport { LineParser, parseStringResponse } from '../utils';\nimport { parseRemoteMessages } from './parse-remote-messages';\n\nfunction pushResultPushedItem(local: string, remote: string, status: string): PushResultPushedItem {\n   const deleted = status.includes('deleted');\n   const tag = status.includes('tag') || /^refs\\/tags/.test(local);\n   const alreadyUpdated = !status.includes('new');\n\n   return {\n      deleted,\n      tag,\n      branch: !tag,\n      new: !alreadyUpdated,\n      alreadyUpdated,\n      local,\n      remote,\n   };\n}\n\nconst parsers: LineParser<PushDetail>[] = [\n   new LineParser(/^Pushing to (.+)$/, (result, [repo]) => {\n      result.repo = repo;\n   }),\n   new LineParser(/^updating local tracking ref '(.+)'/, (result, [local]) => {\n      result.ref = {\n         ...(result.ref || {}),\n         local,\n      }\n   }),\n   new LineParser(/^[*-=]\\s+([^:]+):(\\S+)\\s+\\[(.+)]$/, (result, [local, remote, type]) => {\n      result.pushed.push(pushResultPushedItem(local, remote, type));\n   }),\n   new LineParser(/^Branch '([^']+)' set up to track remote branch '([^']+)' from '([^']+)'/, (result, [local, remote, remoteName]) => {\n      result.branch = {\n         ...(result.branch || {}),\n         local,\n         remote,\n         remoteName,\n      };\n   }),\n   new LineParser(/^([^:]+):(\\S+)\\s+([a-z0-9]+)\\.\\.([a-z0-9]+)$/, (result, [local, remote, from, to]) => {\n      result.update = {\n         head: {\n            local,\n            remote,\n         },\n         hash: {\n            from,\n            to,\n         },\n      };\n   }),\n];\n\nexport const parsePushResult: TaskParser<string, PushResult> = (stdOut, stdErr) => {\n   const pushDetail = parsePushDetail(stdOut, stdErr);\n   const responseDetail = parseRemoteMessages<PushResultRemoteMessages>(stdOut, stdErr);\n\n   return {\n      ...pushDetail,\n      ...responseDetail,\n   };\n}\n\nexport const parsePushDetail: TaskParser<string, PushDetail> = (stdOut, stdErr) => {\n   return parseStringResponse({pushed: []}, parsers, [stdOut, stdErr]);\n}\n", "import { PushResult } from '../../../typings';\nimport { parsePushResult as parser } from '../parsers/parse-push';\nimport { StringTask } from '../types';\nimport { append, remove } from '../utils';\n\ntype PushRef = { remote?: string, branch?: string };\n\nexport function pushTagsTask(ref: PushRef = {}, customArgs: string[]): StringTask<PushResult> {\n   append(customArgs, '--tags');\n   return pushTask(ref, customArgs);\n}\n\nexport function pushTask(ref: PushRef = {}, customArgs: string[]): StringTask<PushResult> {\n   const commands = ['push', ...customArgs];\n   if (ref.branch) {\n      commands.splice(1, 0, ref.branch);\n   }\n   if (ref.remote) {\n      commands.splice(1, 0, ref.remote);\n   }\n\n   remove(commands, '-v');\n   append(commands, '--verbose');\n   append(commands, '--porcelain');\n\n   return {\n      commands,\n      format: 'utf-8',\n      parser,\n   };\n}\n", "import { FileStatusResult } from '../../../typings';\n\nexport const fromPathRegex = /^(.+) -> (.+)$/;\n\nexport class FileStatusSummary implements FileStatusResult {\n\n   public readonly from: string | undefined;\n\n   constructor (\n      public path: string,\n      public index: string,\n      public working_dir: string) {\n\n      if ('R' === (index + working_dir)) {\n         const detail = fromPathRegex.exec(path) || [null, path, path];\n         this.from = detail[1] || '';\n         this.path = detail[2] || '';\n      }\n   }\n}\n", "import { StatusResult } from '../../../typings';\nimport { append, NULL } from '../utils';\nimport { FileStatusSummary } from './FileStatusSummary';\n\ntype StatusLineParser = (result: StatusResult, file: string) => void;\n\nexport class StatusSummary implements StatusResult {\n   public not_added = [];\n   public conflicted = [];\n   public created = [];\n   public deleted = [];\n   public ignored = undefined;\n   public modified = [];\n   public renamed = [];\n   public files = [];\n   public staged = [];\n   public ahead = 0;\n   public behind = 0;\n   public current = null;\n   public tracking = null;\n   public detached = false;\n\n   public isClean = () => {\n      return !this.files.length;\n   }\n}\n\nenum PorcelainFileStatus {\n   ADDED = 'A',\n   DELETED = 'D',\n   MODIFIED = 'M',\n   RENAMED = 'R',\n   COPIED = 'C',\n   UNMERGED = 'U',\n   UNTRACKED = '?',\n   IGNORED = '!',\n   NONE = ' ',\n}\n\nfunction renamedFile(line: string) {\n   const [to, from] = line.split(NULL);\n\n   return {\n      from: from || to,\n      to,\n   };\n}\n\nfunction parser(indexX: PorcelainFileStatus, indexY: PorcelainFileStatus, handler: StatusLineParser): [string, StatusLineParser] {\n   return [`${indexX}${indexY}`, handler];\n}\n\nfunction conflicts(indexX: PorcelainFileStatus, ...indexY: PorcelainFileStatus[]) {\n   return indexY.map(y => parser(indexX, y, (result, file) => append(result.conflicted, file)));\n}\n\nconst parsers: Map<string, StatusLineParser> = new Map([\n   parser(PorcelainFileStatus.NONE, PorcelainFileStatus.ADDED, (result, file) => append(result.created, file)),\n   parser(PorcelainFileStatus.NONE, PorcelainFileStatus.DELETED, (result, file) => append(result.deleted, file)),\n   parser(PorcelainFileStatus.NONE, PorcelainFileStatus.MODIFIED, (result, file) => append(result.modified, file)),\n\n   parser(PorcelainFileStatus.ADDED, PorcelainFileStatus.NONE, (result, file) => append(result.created, file) && append(result.staged, file)),\n   parser(PorcelainFileStatus.ADDED, PorcelainFileStatus.MODIFIED, (result, file) =>\n      append(result.created, file) && append(result.staged, file) && append(result.modified, file)),\n\n   parser(PorcelainFileStatus.DELETED, PorcelainFileStatus.NONE, (result, file) => append(result.deleted, file) && append(result.staged, file)),\n\n   parser(PorcelainFileStatus.MODIFIED, PorcelainFileStatus.NONE, (result, file) => append(result.modified, file) && append(result.staged, file)),\n   parser(PorcelainFileStatus.MODIFIED, PorcelainFileStatus.MODIFIED, (result, file) => append(result.modified, file) && append(result.staged, file)),\n\n   parser(PorcelainFileStatus.RENAMED, PorcelainFileStatus.NONE, (result, file) => {\n      append(result.renamed, renamedFile(file));\n   }),\n   parser(PorcelainFileStatus.RENAMED, PorcelainFileStatus.MODIFIED, (result, file) => {\n      const renamed = renamedFile(file);\n      append(result.renamed, renamed);\n      append(result.modified, renamed.to);\n   }),\n   parser(PorcelainFileStatus.IGNORED, PorcelainFileStatus.IGNORED, (_result, _file) => {\n      append((_result.ignored = _result.ignored || []), _file);\n   }),\n\n   parser(PorcelainFileStatus.UNTRACKED, PorcelainFileStatus.UNTRACKED, (result, file) => append(result.not_added, file)),\n\n   ...conflicts(PorcelainFileStatus.ADDED, PorcelainFileStatus.ADDED, PorcelainFileStatus.UNMERGED),\n   ...conflicts(PorcelainFileStatus.DELETED, PorcelainFileStatus.DELETED, PorcelainFileStatus.UNMERGED),\n   ...conflicts(PorcelainFileStatus.UNMERGED, PorcelainFileStatus.ADDED, PorcelainFileStatus.DELETED, PorcelainFileStatus.UNMERGED),\n\n   ['##', (result, line) => {\n      const aheadReg = /ahead (\\d+)/;\n      const behindReg = /behind (\\d+)/;\n      const currentReg = /^(.+?(?=(?:\\.{3}|\\s|$)))/;\n      const trackingReg = /\\.{3}(\\S*)/;\n      const onEmptyBranchReg = /\\son\\s([\\S]+)$/;\n      let regexResult;\n\n      regexResult = aheadReg.exec(line);\n      result.ahead = regexResult && +regexResult[1] || 0;\n\n      regexResult = behindReg.exec(line);\n      result.behind = regexResult && +regexResult[1] || 0;\n\n      regexResult = currentReg.exec(line);\n      result.current = regexResult && regexResult[1];\n\n      regexResult = trackingReg.exec(line);\n      result.tracking = regexResult && regexResult[1];\n\n      regexResult = onEmptyBranchReg.exec(line);\n      result.current = regexResult && regexResult[1] || result.current;\n\n      result.detached = /\\(no branch\\)/.test(line);\n   }]\n]);\n\nexport const parseStatusSummary = function (text: string): StatusResult {\n   const lines = text.split(NULL);\n   const status = new StatusSummary();\n\n   for (let i = 0, l = lines.length; i < l;) {\n      let line = lines[i++].trim();\n\n      if (!line) {\n         continue;\n      }\n\n      if (line.charAt(0) === PorcelainFileStatus.RENAMED) {\n         line += NULL + (lines[i++] || '');\n      }\n\n      splitLine(status, line);\n   }\n\n   return status;\n};\n\nfunction splitLine(result: StatusResult, lineStr: string) {\n   const trimmed = lineStr.trim();\n   switch (' ') {\n      case trimmed.charAt(2):\n         return data(trimmed.charAt(0), trimmed.charAt(1), trimmed.substr(3));\n      case trimmed.charAt(1):\n         return data(PorcelainFileStatus.NONE, trimmed.charAt(0), trimmed.substr(2));\n      default:\n         return;\n   }\n\n   function data(index: string, workingDir: string, path: string) {\n      const raw = `${index}${workingDir}`;\n      const handler = parsers.get(raw);\n\n      if (handler) {\n         handler(result, path);\n      }\n\n      if (raw !== '##' && raw !== '!!') {\n         result.files.push(new FileStatusSummary(path.replace(/\\0.+$/, ''), index, workingDir));\n      }\n   }\n}\n", "import { StatusResult } from '../../../typings';\nimport { parseStatusSummary } from '../responses/StatusSummary';\nimport { StringTask } from '../types';\n\nconst ignoredOptions = ['--null', '-z'];\n\nexport function statusTask(customArgs: string[]): StringTask<StatusResult> {\n   const commands = [\n      'status',\n      '--porcelain',\n      '-b',\n      '-u',\n      '--null',\n      ...customArgs.filter(arg => !ignoredOptions.includes(arg))\n   ];\n\n   return {\n      format: 'utf-8',\n      commands,\n      parser(text: string) {\n         return parseStatusSummary(text);\n      }\n   }\n}\n", "import { SimpleGitBase } from '../../typings';\nimport { taskCallback } from './task-callback';\nimport { changeWorkingDirectoryTask } from './tasks/change-working-directory';\nimport commit from './tasks/commit';\nimport config from './tasks/config';\nimport grep from './tasks/grep';\nimport { hashObjectTask } from './tasks/hash-object';\nimport { initTask } from './tasks/init';\nimport log from './tasks/log';\nimport { mergeTask } from './tasks/merge';\nimport { pushTask } from './tasks/push';\nimport { statusTask } from './tasks/status';\nimport { configurationErrorTask, straightThroughStringTask } from './tasks/task';\nimport { outputHandler, SimpleGitExecutor, SimpleGitTask, SimpleGitTaskCallback } from './types';\nimport { asArray, filterString, filterType, getTrailingOptions, trailingFunctionArgument } from './utils';\n\nexport class SimpleGitApi implements SimpleGitBase {\n\n   constructor(private _executor: SimpleGitExecutor) {\n   }\n\n   protected _runTask<T>(task: SimpleGitTask<T>, then?: SimpleGitTaskCallback<T>) {\n      const chain = this._executor.chain();\n      const promise = chain.push(task);\n\n      if (then) {\n         taskCallback(task, promise, then);\n      }\n\n      return Object.create(this, {\n         then: {value: promise.then.bind(promise)},\n         catch: {value: promise.catch.bind(promise)},\n         _executor: {value: chain},\n      });\n   }\n\n   add(files: string | string[]) {\n      return this._runTask(\n         straightThroughStringTask(['add', ...asArray(files)]),\n         trailingFunctionArgument(arguments),\n      );\n   }\n\n   cwd(directory: string | { path: string, root?: boolean }) {\n      const next = trailingFunctionArgument(arguments);\n\n      if (typeof directory === 'string') {\n         return this._runTask(changeWorkingDirectoryTask(directory, this._executor), next);\n      }\n\n      if (typeof directory?.path === 'string') {\n         return this._runTask(changeWorkingDirectoryTask(directory.path, directory.root && this._executor || undefined), next);\n      }\n\n      return this._runTask(\n         configurationErrorTask('Git.cwd: workingDirectory must be supplied as a string'),\n         next\n      );\n   }\n\n   hashObject(path: string, write: boolean | unknown) {\n      return this._runTask(\n         hashObjectTask(path, write === true),\n         trailingFunctionArgument(arguments),\n      );\n   }\n\n   init(bare?: boolean | unknown) {\n      return this._runTask(\n         initTask(bare === true, this._executor.cwd, getTrailingOptions(arguments)),\n         trailingFunctionArgument(arguments),\n      );\n   }\n\n   merge() {\n      return this._runTask(\n         mergeTask(getTrailingOptions(arguments)),\n         trailingFunctionArgument(arguments),\n      );\n   }\n\n   mergeFromTo(remote: string, branch: string) {\n      if (!(filterString(remote) && filterString(branch))) {\n         return this._runTask(configurationErrorTask(\n            `Git.mergeFromTo requires that the 'remote' and 'branch' arguments are supplied as strings`\n         ));\n      }\n\n      return this._runTask(\n         mergeTask([remote, branch, ...getTrailingOptions(arguments)]),\n         trailingFunctionArgument(arguments, false),\n      );\n   }\n\n   outputHandler(handler: outputHandler) {\n      this._executor.outputHandler = handler;\n      return this;\n   }\n\n   push() {\n      const task = pushTask(\n         {\n            remote: filterType(arguments[0], filterString),\n            branch: filterType(arguments[1], filterString),\n         },\n         getTrailingOptions(arguments),\n      );\n\n      return this._runTask(\n         task,\n         trailingFunctionArgument(arguments),\n      );\n   }\n\n   stash() {\n      return this._runTask(\n         straightThroughStringTask(['stash', ...getTrailingOptions(arguments)]),\n         trailingFunctionArgument(arguments),\n      );\n   }\n\n   status() {\n      return this._runTask(statusTask(getTrailingOptions(arguments)), trailingFunctionArgument(arguments));\n   }\n}\n\nObject.assign(SimpleGitApi.prototype, commit(), config(), grep(), log());\n", "import { append, remove } from '../utils';\nimport { createDeferred, DeferredPromise } from '@kwsites/promise-deferred';\nimport { createLogger } from '../git-logger';\n\ntype ScheduleCompleteCallback = () => void;\ntype ScheduledTask = Pick<DeferredPromise<ScheduleCompleteCallback>, 'promise' | 'done'> & {id: number};\n\nconst createScheduledTask: () => ScheduledTask = (() => {\n   let id = 0;\n   return () => {\n      id++;\n      const {promise, done} = createDeferred<ScheduleCompleteCallback>();\n\n      return {\n         promise,\n         done,\n         id,\n      };\n   }\n})();\n\nexport class Scheduler {\n   private logger = createLogger('', 'scheduler');\n   private pending: ScheduledTask[] = [];\n   private running: ScheduledTask[] = [];\n\n   constructor(private concurrency = 2) {\n      this.logger(`Constructed, concurrency=%s`, concurrency);\n   }\n\n   private schedule() {\n      if (!this.pending.length || this.running.length >= this.concurrency) {\n         this.logger(`Schedule attempt ignored, pending=%s running=%s concurrency=%s`, this.pending.length, this.running.length, this.concurrency);\n         return;\n      }\n\n      const task = append(this.running, this.pending.shift()!);\n      this.logger(`Attempting id=%s`, task.id);\n      task.done(() => {\n         this.logger(`Completing id=`, task.id);\n         remove(this.running, task);\n         this.schedule();\n      });\n   }\n\n   next(): Promise<ScheduleCompleteCallback> {\n      const {promise, id} = append(this.pending, createScheduledTask());\n      this.logger(`Scheduling id=%s`, id);\n\n      this.schedule();\n\n      return promise;\n   }\n}\n", "import { straightThroughStringTask } from './task';\nimport { OptionFlags, Options, StringTask } from '../types';\n\nexport type ApplyOptions = Options &\n   OptionFlags<\n      | '--stat'\n      | '--numstat'\n      | '--summary'\n      | '--check'\n      | '--index'\n      | '--intent-to-add'\n      | '--3way'\n      | '--apply'\n      | '--no-add'\n      | '-R'\n      | '--reverse'\n      | '--allow-binary-replacement'\n      | '--binary'\n      | '--reject'\n      | '-z'\n      | '--inaccurate-eof'\n      | '--recount'\n      | '--cached'\n      | '--ignore-space-change'\n      | '--ignore-whitespace'\n      | '--verbose'\n      | '--unsafe-paths'> &\n   OptionFlags<\n      '--whitespace',\n      'nowarn' | 'warn' | 'fix' | 'error' | 'error-all'> &\n   OptionFlags<'--build-fake-ancestor' | '--exclude' | '--include' | '--directory',\n      string> &\n   OptionFlags<'-p' | '-C', number>;\n\nexport function applyPatchTask(patches: string[], customArgs: string[]): StringTask<string> {\n   return straightThroughStringTask(['apply', ...customArgs, ...patches]);\n}\n", "import {\n   BranchMultiDeleteResult,\n   BranchSingleDeleteFailure,\n   BranchSingleDeleteResult,\n   BranchSingleDeleteSuccess\n} from '../../../typings';\n\nexport class BranchDeletionBatch implements BranchMultiDeleteResult {\n   all: BranchSingleDeleteResult[] = [];\n   branches: { [branchName: string]: BranchSingleDeleteResult } = {};\n   errors: BranchSingleDeleteResult[] = [];\n\n   get success(): boolean {\n      return !this.errors.length;\n   }\n}\n\nexport function branchDeletionSuccess (branch: string, hash: string): BranchSingleDeleteSuccess {\n   return {\n      branch, hash, success: true,\n   };\n}\n\nexport function branchDeletionFailure (branch: string): BranchSingleDeleteFailure {\n   return {\n      branch, hash: null, success: false,\n   };\n}\n\nexport function isSingleBranchDeleteFailure (test: BranchSingleDeleteResult): test is BranchSingleDeleteSuccess {\n   return test.success;\n}\n", "import { BranchMultiDeleteResult } from '../../../typings';\nimport { BranchDeletionBatch, branchDeletionFailure, branchDeletionSuccess } from '../responses/BranchDeleteSummary';\nimport { TaskParser } from '../types';\nimport { ExitCodes, LineParser, parseStringResponse } from '../utils';\n\nconst deleteSuccessRegex = /(\\S+)\\s+\\(\\S+\\s([^)]+)\\)/;\nconst deleteErrorRegex = /^error[^']+'([^']+)'/m;\n\nconst parsers: LineParser<BranchMultiDeleteResult>[] = [\n   new LineParser(deleteSuccessRegex, (result, [branch, hash]) => {\n      const deletion = branchDeletionSuccess(branch, hash);\n\n      result.all.push(deletion);\n      result.branches[branch] = deletion;\n   }),\n   new LineParser(deleteErrorRegex, (result, [branch]) => {\n      const deletion = branchDeletionFailure(branch);\n\n      result.errors.push(deletion);\n      result.all.push(deletion);\n      result.branches[branch] = deletion;\n   }),\n];\n\nexport const parseBranchDeletions: TaskParser<string, BranchMultiDeleteResult> = (stdOut, stdErr) => {\n   return parseStringResponse(new BranchDeletionBatch(), parsers, [stdOut, stdErr]);\n}\n\nexport function hasBranchDeletionError(data: string, processExitCode: ExitCodes): boolean {\n   return processExitCode === ExitCodes.ERROR && deleteErrorRegex.test(data);\n}\n", "import type { BranchSummary, BranchSummaryBranch } from '../../../typings';\n\nexport enum BranchStatusIdentifier {\n   CURRENT = '*',\n   LINKED = '+',\n}\n\nexport class BranchSummaryResult implements BranchSummary {\n   public all: string[] = [];\n   public branches: { [p: string]: BranchSummaryBranch } = {};\n   public current: string = '';\n   public detached: boolean = false;\n\n   push(status: BranchStatusIdentifier | unknown, detached: boolean, name: string, commit: string, label: string) {\n      if (status === BranchStatusIdentifier.CURRENT) {\n         this.detached = detached;\n         this.current = name;\n      }\n\n      this.all.push(name);\n      this.branches[name] = {\n         current: status === BranchStatusIdentifier.CURRENT,\n         linkedWorkTree: status === BranchStatusIdentifier.LINKED,\n         name,\n         commit,\n         label\n      };\n   }\n}\n\n", "import type { BranchSummary } from '../../../typings';\nimport { BranchSummaryResult } from '../responses/BranchSummary';\nimport { LineParser, parseStringResponse } from '../utils';\n\nconst parsers: LineParser<BranchSummaryResult>[] = [\n   new LineParser(/^([*+]\\s)?\\((?:HEAD )?detached (?:from|at) (\\S+)\\)\\s+([a-z0-9]+)\\s(.*)$/, (result, [current, name, commit, label]) => {\n      result.push(\n         branchStatus(current),\n         true,\n         name, commit, label\n      );\n   }),\n   new LineParser(/^([*+]\\s)?(\\S+)\\s+([a-z0-9]+)\\s?(.*)$/s, (result, [current, name, commit, label]) => {\n      result.push(\n         branchStatus(current),\n         false,\n         name, commit, label\n      );\n   })\n];\n\nfunction branchStatus(input?: string) {\n   return input ? input.charAt(0) : '';\n}\n\nexport function parseBranchSummary(stdOut: string): BranchSummary {\n   return parseStringResponse(new BranchSummaryResult(), parsers, stdOut);\n}\n", "import { BranchMultiDeleteResult, BranchSingleDeleteResult, BranchSummary } from '../../../typings';\nimport { StringTask } from '../types';\nimport { GitResponseError } from '../errors/git-response-error';\nimport { hasBranchDeletionError, parseBranchDeletions } from '../parsers/parse-branch-delete';\nimport { parseBranchSummary } from '../parsers/parse-branch';\nimport { bufferToString } from '../utils';\n\nexport function containsDeleteBranchCommand(commands: string[]) {\n   const deleteCommands = ['-d', '-D', '--delete'];\n   return commands.some(command => deleteCommands.includes(command));\n}\n\nexport function branchTask(customArgs: string[]): StringTask<BranchSummary | BranchSingleDeleteResult> {\n   const isDelete = containsDeleteBranchCommand(customArgs);\n   const commands = ['branch', ...customArgs];\n\n   if (commands.length === 1) {\n      commands.push('-a');\n   }\n\n   if (!commands.includes('-v')) {\n      commands.splice(1, 0, '-v');\n   }\n\n   return {\n      format: 'utf-8',\n      commands,\n      parser(stdOut, stdErr) {\n         if (isDelete) {\n            return parseBranchDeletions(stdOut, stdErr).all[0];\n         }\n\n         return parseBranchSummary(stdOut);\n      },\n   }\n}\n\nexport function branchLocalTask(): StringTask<BranchSummary> {\n   const parser = parseBranchSummary;\n\n   return {\n      format: 'utf-8',\n      commands: ['branch', '-v'],\n      parser,\n   }\n}\n\nexport function deleteBranchesTask(branches: string[], forceDelete = false): StringTask<BranchMultiDeleteResult> {\n   return {\n      format: 'utf-8',\n      commands: ['branch', '-v', forceDelete ? '-D' : '-d', ...branches],\n      parser(stdOut, stdErr) {\n         return parseBranchDeletions(stdOut, stdErr);\n      },\n      onError({exitCode, stdOut}, error, done, fail) {\n         if (!hasBranchDeletionError(String(error), exitCode)) {\n            return fail(error);\n         }\n\n         done(stdOut);\n      },\n   }\n}\n\nexport function deleteBranchTask(branch: string, forceDelete = false): StringTask<BranchSingleDeleteResult> {\n   const task: StringTask<BranchSingleDeleteResult> = {\n      format: 'utf-8',\n      commands: ['branch', '-v', forceDelete ? '-D' : '-d', branch],\n      parser(stdOut, stdErr) {\n         return parseBranchDeletions(stdOut, stdErr).branches[branch]!;\n      },\n      onError({exitCode, stdErr, stdOut}, error, _, fail) {\n         if (!hasBranchDeletionError(String(error), exitCode)) {\n            return fail(error);\n         }\n\n         throw new GitResponseError(\n            task.parser(bufferToString(stdOut), bufferToString(stdErr)),\n            String(error)\n         );\n      },\n   };\n\n   return task;\n}\n", "\n/**\n * Parser for the `check-ignore` command - returns each file as a string array\n */\nexport const parseCheckIgnore = (text: string): string[] => {\n   return text.split(/\\n/g)\n      .map(line => line.trim())\n      .filter(file => !!file);\n};\n", "import { StringTask } from '../types';\nimport { parseCheckIgnore } from '../responses/CheckIgnore';\n\nexport function checkIgnoreTask(paths: string[]): StringTask<string[]> {\n   return {\n      commands: ['check-ignore', ...paths],\n      format: 'utf-8',\n      parser: parseCheckIgnore,\n   };\n}\n", "import { configurationErrorTask, EmptyTask, straightThroughStringTask } from './task';\nimport { OptionFlags, Options, StringTask } from '../types';\nimport { append, filterString } from '../utils';\n\nexport type CloneOptions = Options &\n   OptionFlags<'--bare' |\n      '--dissociate' |\n      '--mirror' |\n      '--no-checkout' |\n      '--no-remote-submodules' |\n      '--no-shallow-submodules' |\n      '--no-single-branch' |\n      '--no-tags' |\n      '--remote-submodules' |\n      '--single-branch' |\n      '--shallow-submodules' |\n      '--verbose'> &\n   OptionFlags<'--depth' | '-j' | '--jobs', number> &\n   OptionFlags<'--branch' | '--origin' | '--recurse-submodules' | '--separate-git-dir' | '--shallow-exclude' | '--shallow-since' | '--template', string>\n\nfunction disallowedCommand(command: string) {\n   return /^--upload-pack(=|$)/.test(command);\n}\n\nexport function cloneTask(repo: string | undefined, directory: string | undefined, customArgs: string[]): StringTask<string> | EmptyTask {\n   const commands = ['clone', ...customArgs];\n\n   filterString(repo) && commands.push(repo);\n   filterString(directory) && commands.push(directory);\n\n   const banned = commands.find(disallowedCommand);\n   if (banned) {\n      return configurationErrorTask(`git.fetch: potential exploit argument blocked.`);\n   }\n\n   return straightThroughStringTask(commands);\n}\n\nexport function cloneMirrorTask(repo: string | undefined, directory: string | undefined, customArgs: string[]) {\n   append(customArgs, '--mirror');\n\n   return cloneTask(repo, directory, customArgs);\n}\n", "import { FetchResult } from '../../../typings';\nimport { LineParser, parseStringResponse } from '../utils';\n\nconst parsers: LineParser<FetchResult>[] = [\n   new LineParser(/From (.+)$/, (result, [remote]) => {\n      result.remote = remote;\n   }),\n   new LineParser(/\\* \\[new branch]\\s+(\\S+)\\s*-> (.+)$/, (result, [name, tracking]) =>{\n      result.branches.push({\n         name,\n         tracking,\n      });\n   }),\n   new LineParser(/\\* \\[new tag]\\s+(\\S+)\\s*-> (.+)$/, (result, [name, tracking]) => {\n      result.tags.push({\n         name,\n         tracking,\n      });\n   })\n];\n\nexport function parseFetchResult (stdOut: string, stdErr: string): FetchResult {\n   const result: FetchResult = {\n      raw: stdOut,\n      remote: null,\n      branches: [],\n      tags: [],\n   };\n   return parseStringResponse(result, parsers, [stdOut, stdErr]);\n}\n", "import { FetchResult } from '../../../typings';\nimport { parseFetchResult } from '../parsers/parse-fetch';\nimport { StringTask } from '../types';\n\nimport { configurationErrorTask, EmptyTask } from './task';\n\nfunction disallowedCommand(command: string) {\n   return /^--upload-pack(=|$)/.test(command);\n}\n\nexport function fetchTask(remote: string, branch: string, customArgs: string[]): StringTask<FetchResult> | EmptyTask {\n   const commands = ['fetch', ...customArgs];\n   if (remote && branch) {\n      commands.push(remote, branch);\n   }\n\n   const banned = commands.find(disallowedCommand);\n   if (banned) {\n      return configurationErrorTask(`git.fetch: potential exploit argument blocked.`);\n   }\n\n   return {\n      commands,\n      format: 'utf-8',\n      parser: parseFetchResult,\n   }\n}\n", "import { MoveResult } from '../../../typings';\nimport { LineParser, parseStringResponse } from '../utils';\n\nconst parsers: LineParser<MoveResult>[] = [\n   new LineParser(/^Renaming (.+) to (.+)$/, (result, [from, to]) => {\n      result.moves.push({from, to});\n   }),\n];\n\nexport function parseMoveResult (stdOut: string): MoveResult {\n   return parseStringResponse({moves: []}, parsers, stdOut);\n}\n", "import { MoveResult } from '../../../typings';\nimport { parseMoveResult } from '../parsers/parse-move';\nimport { StringTask } from '../types';\nimport { asArray } from '../utils';\n\nexport function moveTask(from: string | string[], to: string): StringTask<MoveResult> {\n   return {\n      commands: ['mv', '-v', ...asArray(from), to],\n      format: 'utf-8',\n      parser: parseMoveResult,\n   };\n}\n", "import { PullResult } from '../../../typings';\nimport { GitResponseError } from '../errors/git-response-error';\nimport { parsePullErrorResult, parsePullResult } from '../parsers/parse-pull';\nimport { Maybe, StringTask } from '../types';\nimport { bufferToString } from '../utils';\n\nexport function pullTask(remote: Maybe<string>, branch: Maybe<string>, customArgs: string[]): StringTask<PullResult> {\n   const commands: string[] = ['pull', ...customArgs];\n   if (remote && branch) {\n      commands.splice(1, 0, remote, branch);\n   }\n\n   return {\n      commands,\n      format: 'utf-8',\n      parser(stdOut, stdErr): PullResult {\n         return parsePullResult(stdOut, stdErr);\n      },\n      onError(result, _error, _done, fail) {\n         const pullError = parsePullErrorResult(bufferToString(result.stdOut), bufferToString(result.stdErr));\n         if (pullError) {\n            return fail(new GitResponseError(pullError));\n         }\n\n         fail(_error);\n      }\n   }\n}\n", "import { forEachLineWithContent } from '../utils';\n\nexport interface RemoteWithoutRefs {\n   name: string;\n}\n\nexport interface RemoteWithRefs extends RemoteWithoutRefs {\n   refs: {\n      fetch: string;\n      push: string;\n   };\n}\n\nexport function parseGetRemotes (text: string): RemoteWithoutRefs[] {\n   const remotes: {[name: string]: RemoteWithoutRefs} = {};\n\n   forEach(text, ([name]) => remotes[name] = { name });\n\n   return Object.values(remotes);\n}\n\nexport function parseGetRemotesVerbose (text: string): RemoteWithRefs[] {\n   const remotes: {[name: string]: RemoteWithRefs} = {};\n\n   forEach(text, ([name, url, purpose]) => {\n      if (!remotes.hasOwnProperty(name)) {\n         remotes[name] = {\n            name: name,\n            refs: { fetch: '', push: '' },\n         };\n      }\n\n      if (purpose && url) {\n         remotes[name].refs[purpose.replace(/[^a-z]/g, '') as keyof RemoteWithRefs['refs']] = url;\n      }\n   });\n\n   return Object.values(remotes);\n}\n\nfunction forEach(text: string, handler: (line: string[]) => void) {\n   forEachLineWithContent(text, (line) => handler(line.split(/\\s+/)));\n}\n", "import { parseGetRemotes, parseGetRemotesVerbose } from '../responses/GetRemoteSummary';\nimport { StringTask } from '../types';\nimport { straightThroughStringTask } from './task';\n\nexport function addRemoteTask(remoteName: string, remoteRepo: string, customArgs: string[] = []): StringTask<string> {\n   return straightThroughStringTask(['remote', 'add', ...customArgs, remoteName, remoteRepo]);\n}\n\nexport function getRemotesTask(verbose: boolean): StringTask<any> {\n   const commands = ['remote'];\n   if (verbose) {\n      commands.push('-v');\n   }\n\n   return {\n      commands,\n      format: 'utf-8',\n      parser: verbose ? parseGetRemotesVerbose : parseGetRemotes,\n   };\n}\n\nexport function listRemotesTask(customArgs: string[] = []): StringTask<string> {\n   const commands = [...customArgs];\n   if (commands[0] !== 'ls-remote') {\n      commands.unshift('ls-remote');\n   }\n\n   return straightThroughStringTask(commands);\n}\n\nexport function remoteTask(customArgs: string[] = []): StringTask<string> {\n   const commands = [...customArgs];\n   if (commands[0] !== 'remote') {\n      commands.unshift('remote');\n   }\n\n   return straightThroughStringTask(commands);\n}\n\nexport function removeRemoteTask(remoteName: string) {\n   return straightThroughStringTask(['remote', 'remove', remoteName]);\n}\n", "import { LogOptions, LogResult } from '../../../typings';\nimport { logFormatFromCommand } from '../args/log-format';\nimport { createListLogSummaryParser } from '../parsers/parse-list-log-summary';\nimport type { StringTask } from '../types';\nimport { validateLogFormatConfig } from './diff';\nimport { parseLogOptions } from './log';\nimport type { EmptyTask } from './task';\n\nexport function stashListTask(opt: LogOptions = {}, customArgs: string[]): EmptyTask | StringTask<LogResult> {\n   const options = parseLogOptions<any>(opt);\n   const commands = ['stash', 'list', ...options.commands, ...customArgs];\n   const parser = createListLogSummaryParser(options.splitter, options.fields, logFormatFromCommand(commands));\n\n   return validateLogFormatConfig(commands) || {\n      commands,\n      format: 'utf-8',\n      parser,\n   };\n}\n", "import { StringTask } from '../types';\nimport { straightThroughStringTask } from './task';\n\nexport function addSubModuleTask(repo: string, path: string): StringTask<string> {\n   return subModuleTask(['add', repo, path]);\n}\n\nexport function initSubModuleTask(customArgs: string[]): StringTask<string> {\n   return subModuleTask(['init', ...customArgs]);\n}\n\nexport function subModuleTask(customArgs: string[]): StringTask<string> {\n   const commands = [...customArgs];\n   if (commands[0] !== 'submodule') {\n      commands.unshift('submodule');\n   }\n\n   return straightThroughStringTask(commands);\n}\n\nexport function updateSubModuleTask(customArgs: string[]): StringTask<string> {\n   return subModuleTask(['update', ...customArgs]);\n}\n", "import { TagResult } from '../../../typings';\n\nexport class TagList implements TagResult {\n   constructor(\n      public readonly all: string[],\n      public readonly latest: string | undefined,\n   ) {\n   }\n}\n\nexport const parseTagList = function (data: string, customSort = false) {\n   const tags = data\n      .split('\\n')\n      .map(trimmed)\n      .filter(Boolean);\n\n   if (!customSort) {\n      tags.sort(function (tagA, tagB) {\n         const partsA = tagA.split('.');\n         const partsB = tagB.split('.');\n\n         if (partsA.length === 1 || partsB.length === 1) {\n            return singleSorted(toNumber(partsA[0]), toNumber(partsB[0]));\n         }\n\n         for (let i = 0, l = Math.max(partsA.length, partsB.length); i < l; i++) {\n            const diff = sorted(toNumber(partsA[i]), toNumber(partsB[i]));\n\n            if (diff) {\n               return diff;\n            }\n         }\n\n         return 0;\n      });\n   }\n\n   const latest = customSort ? tags[0] : [...tags].reverse().find((tag) => tag.indexOf('.') >= 0);\n\n   return new TagList(tags, latest);\n};\n\nfunction singleSorted(a: number, b:  number): number {\n   const aIsNum = isNaN(a);\n   const bIsNum = isNaN(b);\n\n   if (aIsNum !== bIsNum) {\n      return aIsNum ? 1 : -1;\n   }\n\n   return aIsNum ? sorted(a, b) : 0;\n}\n\nfunction sorted(a: number, b: number) {\n   return a === b ? 0 : a > b ? 1 : -1;\n}\n\nfunction trimmed(input: string) {\n   return input.trim();\n}\n\nfunction toNumber(input: string | undefined) {\n   if (typeof input === 'string') {\n      return parseInt(input.replace(/^\\D+/g, ''), 10) || 0;\n   }\n\n   return 0;\n}\n", "import { TagResult } from '../../../typings';\nimport { parseTagList } from '../responses/TagList';\nimport { StringTask } from '../types';\n\n/**\n * Task used by `git.tags`\n */\nexport function tagListTask (customArgs: string[] = []): StringTask<TagResult> {\n   const hasCustomSort = customArgs.some((option) => /^--sort=/.test(option));\n\n   return {\n      format: 'utf-8',\n      commands: ['tag', '-l', ...customArgs],\n      parser (text: string) {\n         return parseTagList(text, hasCustomSort);\n      },\n   }\n}\n\n/**\n * Task used by `git.addTag`\n */\nexport function addTagTask (name: string): StringTask<{name: string}> {\n   return {\n      format: 'utf-8',\n      commands: ['tag', name],\n      parser () {\n         return {name};\n      }\n   }\n}\n\n/**\n * Task used by `git.addTag`\n */\nexport function addAnnotatedTagTask (name: string, tagMessage: string): StringTask<{name: string}> {\n   return {\n      format: 'utf-8',\n      commands: ['tag', '-a', '-m', tagMessage, name],\n      parser () {\n         return {name};\n      }\n   }\n}\n", "const {GitExecutor} = require('./lib/runners/git-executor');\nconst {SimpleGitApi} = require('./lib/simple-git-api');\n\nconst {Scheduler} = require('./lib/runners/scheduler');\nconst {configurationErrorTask} = require('./lib/tasks/task');\nconst {\n   asArray,\n   filterArray,\n   filterPrimitives,\n   filterString,\n   filterStringOrStringArray,\n   filterType,\n   getTrailingOptions,\n   trailingFunctionArgument,\n   trailingOptionsArgument\n} = require('./lib/utils');\nconst {applyPatchTask} = require('./lib/tasks/apply-patch')\nconst {branchTask, branchLocalTask, deleteBranchesTask, deleteBranchTask} = require('./lib/tasks/branch');\nconst {checkIgnoreTask} = require('./lib/tasks/check-ignore');\nconst {checkIsRepoTask} = require('./lib/tasks/check-is-repo');\nconst {cloneTask, cloneMirrorTask} = require('./lib/tasks/clone');\nconst {cleanWithOptionsTask, isCleanOptionsArray} = require('./lib/tasks/clean');\nconst {commitTask} = require('./lib/tasks/commit');\nconst {diffSummaryTask} = require('./lib/tasks/diff');\nconst {fetchTask} = require('./lib/tasks/fetch');\nconst {moveTask} = require(\"./lib/tasks/move\");\nconst {pullTask} = require('./lib/tasks/pull');\nconst {pushTagsTask} = require('./lib/tasks/push');\nconst {addRemoteTask, getRemotesTask, listRemotesTask, remoteTask, removeRemoteTask} = require('./lib/tasks/remote');\nconst {getResetMode, resetTask} = require('./lib/tasks/reset');\nconst {stashListTask} = require('./lib/tasks/stash-list');\nconst {addSubModuleTask, initSubModuleTask, subModuleTask, updateSubModuleTask} = require('./lib/tasks/sub-module');\nconst {addAnnotatedTagTask, addTagTask, tagListTask} = require('./lib/tasks/tag');\nconst {straightThroughBufferTask, straightThroughStringTask} = require('./lib/tasks/task');\n\nfunction Git (options, plugins) {\n   this._executor = new GitExecutor(\n      options.binary, options.baseDir,\n      new Scheduler(options.maxConcurrentProcesses), plugins,\n   );\n}\n\n(Git.prototype = Object.create(SimpleGitApi.prototype)).constructor = Git;\n\n/**\n * Sets the path to a custom git binary, should either be `git` when there is an installation of git available on\n * the system path, or a fully qualified path to the executable.\n *\n * @param {string} command\n * @returns {Git}\n */\nGit.prototype.customBinary = function (command) {\n   this._executor.binary = command;\n   return this;\n};\n\n/**\n * Sets an environment variable for the spawned child process, either supply both a name and value as strings or\n * a single object to entirely replace the current environment variables.\n *\n * @param {string|Object} name\n * @param {string} [value]\n * @returns {Git}\n */\nGit.prototype.env = function (name, value) {\n   if (arguments.length === 1 && typeof name === 'object') {\n      this._executor.env = name;\n   } else {\n      (this._executor.env = this._executor.env || {})[name] = value;\n   }\n\n   return this;\n};\n\n/**\n * List the stash(s) of the local repo\n */\nGit.prototype.stashList = function (options) {\n   return this._runTask(\n      stashListTask(\n         trailingOptionsArgument(arguments) || {},\n         filterArray(options) && options || []\n      ),\n      trailingFunctionArgument(arguments),\n   );\n};\n\nfunction createCloneTask (api, task, repoPath, localPath) {\n   if (typeof repoPath !== 'string') {\n      return configurationErrorTask(`git.${ api }() requires a string 'repoPath'`);\n   }\n\n   return task(repoPath, filterType(localPath, filterString), getTrailingOptions(arguments));\n}\n\n\n/**\n * Clone a git repo\n */\nGit.prototype.clone = function () {\n   return this._runTask(\n      createCloneTask('clone', cloneTask, ...arguments),\n      trailingFunctionArgument(arguments),\n   );\n};\n\n/**\n * Mirror a git repo\n */\nGit.prototype.mirror = function () {\n   return this._runTask(\n      createCloneTask('mirror', cloneMirrorTask, ...arguments),\n      trailingFunctionArgument(arguments),\n   );\n};\n\n/**\n * Moves one or more files to a new destination.\n *\n * @see https://git-scm.com/docs/git-mv\n *\n * @param {string|string[]} from\n * @param {string} to\n */\nGit.prototype.mv = function (from, to) {\n   return this._runTask(moveTask(from, to), trailingFunctionArgument(arguments));\n};\n\n/**\n * Internally uses pull and tags to get the list of tags then checks out the latest tag.\n *\n * @param {Function} [then]\n */\nGit.prototype.checkoutLatestTag = function (then) {\n   var git = this;\n   return this.pull(function () {\n      git.tags(function (err, tags) {\n         git.checkout(tags.latest, then);\n      });\n   });\n};\n\n/**\n * Pull the updated contents of the current repo\n */\nGit.prototype.pull = function (remote, branch, options, then) {\n   return this._runTask(\n      pullTask(filterType(remote, filterString), filterType(branch, filterString), getTrailingOptions(arguments)),\n      trailingFunctionArgument(arguments),\n   );\n};\n\n/**\n * Fetch the updated contents of the current repo.\n *\n * @example\n *   .fetch('upstream', 'master') // fetches from master on remote named upstream\n *   .fetch(function () {}) // runs fetch against default remote and branch and calls function\n *\n * @param {string} [remote]\n * @param {string} [branch]\n */\nGit.prototype.fetch = function (remote, branch) {\n   return this._runTask(\n      fetchTask(filterType(remote, filterString), filterType(branch, filterString), getTrailingOptions(arguments)),\n      trailingFunctionArgument(arguments),\n   );\n};\n\n/**\n * Disables/enables the use of the console for printing warnings and errors, by default messages are not shown in\n * a production environment.\n *\n * @param {boolean} silence\n * @returns {Git}\n */\nGit.prototype.silent = function (silence) {\n   console.warn('simple-git deprecation notice: git.silent: logging should be configured using the `debug` library / `DEBUG` environment variable, this will be an error in version 3');\n   return this;\n};\n\n/**\n * List all tags. When using git 2.7.0 or above, include an options object with `\"--sort\": \"property-name\"` to\n * sort the tags by that property instead of using the default semantic versioning sort.\n *\n * Note, supplying this option when it is not supported by your Git version will cause the operation to fail.\n *\n * @param {Object} [options]\n * @param {Function} [then]\n */\nGit.prototype.tags = function (options, then) {\n   return this._runTask(\n      tagListTask(getTrailingOptions(arguments)),\n      trailingFunctionArgument(arguments),\n   );\n};\n\n/**\n * Rebases the current working copy. Options can be supplied either as an array of string parameters\n * to be sent to the `git rebase` command, or a standard options object.\n */\nGit.prototype.rebase = function () {\n   return this._runTask(\n      straightThroughStringTask(['rebase', ...getTrailingOptions(arguments)]),\n      trailingFunctionArgument(arguments)\n   );\n};\n\n/**\n * Reset a repo\n */\nGit.prototype.reset = function (mode) {\n   return this._runTask(\n      resetTask(getResetMode(mode), getTrailingOptions(arguments)),\n      trailingFunctionArgument(arguments),\n   );\n};\n\n/**\n * Revert one or more commits in the local working copy\n */\nGit.prototype.revert = function (commit) {\n   const next = trailingFunctionArgument(arguments);\n\n   if (typeof commit !== 'string') {\n      return this._runTask(\n         configurationErrorTask('Commit must be a string'),\n         next,\n      );\n   }\n\n   return this._runTask(\n      straightThroughStringTask(['revert', ...getTrailingOptions(arguments, 0, true), commit]),\n      next\n   );\n};\n\n/**\n * Add a lightweight tag to the head of the current branch\n */\nGit.prototype.addTag = function (name) {\n   const task = (typeof name === 'string')\n      ? addTagTask(name)\n      : configurationErrorTask('Git.addTag requires a tag name');\n\n   return this._runTask(task, trailingFunctionArgument(arguments));\n};\n\n/**\n * Add an annotated tag to the head of the current branch\n */\nGit.prototype.addAnnotatedTag = function (tagName, tagMessage) {\n   return this._runTask(\n      addAnnotatedTagTask(tagName, tagMessage),\n      trailingFunctionArgument(arguments),\n   );\n};\n\n/**\n * Check out a tag or revision, any number of additional arguments can be passed to the `git checkout` command\n * by supplying either a string or array of strings as the first argument.\n */\nGit.prototype.checkout = function () {\n   const commands = ['checkout', ...getTrailingOptions(arguments, true)];\n   return this._runTask(\n      straightThroughStringTask(commands),\n      trailingFunctionArgument(arguments),\n   );\n};\n\n/**\n * Check out a remote branch\n *\n * @param {string} branchName name of branch\n * @param {string} startPoint (e.g origin/development)\n * @param {Function} [then]\n */\nGit.prototype.checkoutBranch = function (branchName, startPoint, then) {\n   return this.checkout(['-b', branchName, startPoint], trailingFunctionArgument(arguments));\n};\n\n/**\n * Check out a local branch\n */\nGit.prototype.checkoutLocalBranch = function (branchName, then) {\n   return this.checkout(['-b', branchName], trailingFunctionArgument(arguments));\n};\n\n/**\n * Delete a local branch\n */\nGit.prototype.deleteLocalBranch = function (branchName, forceDelete, then) {\n   return this._runTask(\n      deleteBranchTask(branchName, typeof forceDelete === \"boolean\" ? forceDelete : false),\n      trailingFunctionArgument(arguments),\n   );\n};\n\n/**\n * Delete one or more local branches\n */\nGit.prototype.deleteLocalBranches = function (branchNames, forceDelete, then) {\n   return this._runTask(\n      deleteBranchesTask(branchNames, typeof forceDelete === \"boolean\" ? forceDelete : false),\n      trailingFunctionArgument(arguments),\n   );\n};\n\n/**\n * List all branches\n *\n * @param {Object | string[]} [options]\n * @param {Function} [then]\n */\nGit.prototype.branch = function (options, then) {\n   return this._runTask(\n      branchTask(getTrailingOptions(arguments)),\n      trailingFunctionArgument(arguments),\n   );\n};\n\n/**\n * Return list of local branches\n *\n * @param {Function} [then]\n */\nGit.prototype.branchLocal = function (then) {\n   return this._runTask(\n      branchLocalTask(),\n      trailingFunctionArgument(arguments),\n   );\n};\n\n/**\n * Executes any command against the git binary.\n */\nGit.prototype.raw = function (commands) {\n   const createRestCommands = !Array.isArray(commands);\n   const command = [].slice.call(createRestCommands ? arguments : commands, 0);\n\n   for (let i = 0; i < command.length && createRestCommands; i++) {\n      if (!filterPrimitives(command[i])) {\n         command.splice(i, command.length - i);\n         break;\n      }\n   }\n\n   command.push(\n      ...getTrailingOptions(arguments, 0, true),\n   );\n\n   var next = trailingFunctionArgument(arguments);\n\n   if (!command.length) {\n      return this._runTask(\n         configurationErrorTask('Raw: must supply one or more command to execute'),\n         next,\n      );\n   }\n\n   return this._runTask(straightThroughStringTask(command), next);\n};\n\nGit.prototype.submoduleAdd = function (repo, path, then) {\n   return this._runTask(\n      addSubModuleTask(repo, path),\n      trailingFunctionArgument(arguments),\n   );\n};\n\nGit.prototype.submoduleUpdate = function (args, then) {\n   return this._runTask(\n      updateSubModuleTask(getTrailingOptions(arguments, true)),\n      trailingFunctionArgument(arguments),\n   );\n};\n\nGit.prototype.submoduleInit = function (args, then) {\n   return this._runTask(\n      initSubModuleTask(getTrailingOptions(arguments, true)),\n      trailingFunctionArgument(arguments),\n   );\n};\n\nGit.prototype.subModule = function (options, then) {\n   return this._runTask(\n      subModuleTask(getTrailingOptions(arguments)),\n      trailingFunctionArgument(arguments),\n   );\n};\n\nGit.prototype.listRemote = function () {\n   return this._runTask(\n      listRemotesTask(getTrailingOptions(arguments)),\n      trailingFunctionArgument(arguments),\n   );\n};\n\n/**\n * Adds a remote to the list of remotes.\n */\nGit.prototype.addRemote = function (remoteName, remoteRepo, then) {\n   return this._runTask(\n      addRemoteTask(remoteName, remoteRepo, getTrailingOptions(arguments)),\n      trailingFunctionArgument(arguments),\n   );\n};\n\n/**\n * Removes an entry by name from the list of remotes.\n */\nGit.prototype.removeRemote = function (remoteName, then) {\n   return this._runTask(\n      removeRemoteTask(remoteName),\n      trailingFunctionArgument(arguments),\n   );\n};\n\n/**\n * Gets the currently available remotes, setting the optional verbose argument to true includes additional\n * detail on the remotes themselves.\n */\nGit.prototype.getRemotes = function (verbose, then) {\n   return this._runTask(\n      getRemotesTask(verbose === true),\n      trailingFunctionArgument(arguments),\n   );\n};\n\n/**\n * Call any `git remote` function with arguments passed as an array of strings.\n *\n * @param {string[]} options\n * @param {Function} [then]\n */\nGit.prototype.remote = function (options, then) {\n   return this._runTask(\n      remoteTask(getTrailingOptions(arguments)),\n      trailingFunctionArgument(arguments),\n   );\n};\n\n/**\n * Call any `git tag` function with arguments passed as an array of strings.\n *\n * @param {string[]} options\n * @param {Function} [then]\n */\nGit.prototype.tag = function (options, then) {\n   const command = getTrailingOptions(arguments);\n\n   if (command[0] !== 'tag') {\n      command.unshift('tag');\n   }\n\n   return this._runTask(\n      straightThroughStringTask(command),\n      trailingFunctionArgument(arguments)\n   );\n};\n\n/**\n * Updates repository server info\n *\n * @param {Function} [then]\n */\nGit.prototype.updateServerInfo = function (then) {\n   return this._runTask(\n      straightThroughStringTask(['update-server-info']),\n      trailingFunctionArgument(arguments),\n   );\n};\n\n/**\n * Pushes the current tag changes to a remote which can be either a URL or named remote. When not specified uses the\n * default configured remote spec.\n *\n * @param {string} [remote]\n * @param {Function} [then]\n */\nGit.prototype.pushTags = function (remote, then) {\n   const task = pushTagsTask({remote: filterType(remote, filterString)}, getTrailingOptions(arguments));\n\n   return this._runTask(task, trailingFunctionArgument(arguments));\n};\n\n/**\n * Removes the named files from source control.\n */\nGit.prototype.rm = function (files) {\n   return this._runTask(\n      straightThroughStringTask(['rm', '-f', ...asArray(files)]),\n      trailingFunctionArgument(arguments)\n   );\n};\n\n/**\n * Removes the named files from source control but keeps them on disk rather than deleting them entirely. To\n * completely remove the files, use `rm`.\n *\n * @param {string|string[]} files\n */\nGit.prototype.rmKeepLocal = function (files) {\n   return this._runTask(\n      straightThroughStringTask(['rm', '--cached', ...asArray(files)]),\n      trailingFunctionArgument(arguments)\n   );\n};\n\n/**\n * Returns a list of objects in a tree based on commit hash. Passing in an object hash returns the object's content,\n * size, and type.\n *\n * Passing \"-p\" will instruct cat-file to determine the object type, and display its formatted contents.\n *\n * @param {string[]} [options]\n * @param {Function} [then]\n */\nGit.prototype.catFile = function (options, then) {\n   return this._catFile('utf-8', arguments);\n};\n\nGit.prototype.binaryCatFile = function () {\n   return this._catFile('buffer', arguments);\n};\n\nGit.prototype._catFile = function (format, args) {\n   var handler = trailingFunctionArgument(args);\n   var command = ['cat-file'];\n   var options = args[0];\n\n   if (typeof options === 'string') {\n      return this._runTask(\n         configurationErrorTask('Git.catFile: options must be supplied as an array of strings'),\n         handler,\n      );\n   }\n\n   if (Array.isArray(options)) {\n      command.push.apply(command, options);\n   }\n\n   const task = format === 'buffer'\n      ? straightThroughBufferTask(command)\n      : straightThroughStringTask(command);\n\n   return this._runTask(task, handler);\n};\n\nGit.prototype.diff = function (options, then) {\n   const task = filterString(options)\n      ? configurationErrorTask('git.diff: supplying options as a single string is no longer supported, switch to an array of strings')\n      : straightThroughStringTask(['diff', ...getTrailingOptions(arguments)]);\n\n   return this._runTask(\n      task,\n      trailingFunctionArgument(arguments),\n   );\n};\n\nGit.prototype.diffSummary = function () {\n   return this._runTask(\n      diffSummaryTask(getTrailingOptions(arguments, 1)),\n      trailingFunctionArgument(arguments),\n   );\n};\n\nGit.prototype.applyPatch = function (patches) {\n   const task = !filterStringOrStringArray(patches)\n      ? configurationErrorTask(`git.applyPatch requires one or more string patches as the first argument`)\n      : applyPatchTask(asArray(patches), getTrailingOptions([].slice.call(arguments, 1)));\n\n   return this._runTask(\n      task,\n      trailingFunctionArgument(arguments),\n   );\n}\n\nGit.prototype.revparse = function () {\n   const commands = ['rev-parse', ...getTrailingOptions(arguments, true)];\n   return this._runTask(\n      straightThroughStringTask(commands, true),\n      trailingFunctionArgument(arguments),\n   );\n};\n\n/**\n * Show various types of objects, for example the file at a certain commit\n *\n * @param {string[]} [options]\n * @param {Function} [then]\n */\nGit.prototype.show = function (options, then) {\n   return this._runTask(\n      straightThroughStringTask(['show', ...getTrailingOptions(arguments, 1)]),\n      trailingFunctionArgument(arguments)\n   );\n};\n\n/**\n */\nGit.prototype.clean = function (mode, options, then) {\n   const usingCleanOptionsArray = isCleanOptionsArray(mode);\n   const cleanMode = usingCleanOptionsArray && mode.join('') || filterType(mode, filterString) || '';\n   const customArgs = getTrailingOptions([].slice.call(arguments, usingCleanOptionsArray ? 1 : 0));\n\n   return this._runTask(\n      cleanWithOptionsTask(cleanMode, customArgs),\n      trailingFunctionArgument(arguments),\n   );\n};\n\nGit.prototype.exec = function (then) {\n   const task = {\n      commands: [],\n      format: 'utf-8',\n      parser () {\n         if (typeof then === 'function') {\n            then();\n         }\n      }\n   };\n\n   return this._runTask(task);\n};\n\n/**\n * Clears the queue of pending commands and returns the wrapper instance for chaining.\n *\n * @returns {Git}\n */\nGit.prototype.clearQueue = function () {\n   // TODO:\n   // this._executor.clear();\n   return this;\n};\n\n/**\n * Check if a pathname or pathnames are excluded by .gitignore\n *\n * @param {string|string[]} pathnames\n * @param {Function} [then]\n */\nGit.prototype.checkIgnore = function (pathnames, then) {\n   return this._runTask(\n      checkIgnoreTask(asArray((filterType(pathnames, filterStringOrStringArray, [])))),\n      trailingFunctionArgument(arguments),\n   );\n};\n\nGit.prototype.checkIsRepo = function (checkType, then) {\n   return this._runTask(\n      checkIsRepoTask(filterType(checkType, filterString)),\n      trailingFunctionArgument(arguments),\n   );\n};\n\nmodule.exports = Git;\n", "import { SimpleGitFactory } from '../../typings';\n\nimport * as api from './api';\nimport {\n   commandConfigPrefixingPlugin,\n   completionDetectionPlugin,\n   errorDetectionHandler,\n   errorDetectionPlugin,\n   PluginStore,\n   progressMonitorPlugin,\n   spawnOptionsPlugin,\n   timeoutPlugin\n} from './plugins';\nimport { createInstanceConfig, folderExists } from './utils';\nimport { SimpleGitOptions } from './types';\n\nconst Git = require('../git');\n\n/**\n * Adds the necessary properties to the supplied object to enable it for use as\n * the default export of a module.\n *\n * Eg: `module.exports = esModuleFactory({ something () {} })`\n */\nexport function esModuleFactory<T>(defaultExport: T) {\n   return Object.defineProperties(defaultExport, {\n      __esModule: {value: true},\n      default: {value: defaultExport},\n   }) as T & { __esModule: true, default: T };\n}\n\nexport function gitExportFactory(factory: SimpleGitFactory) {\n   return Object.assign(factory.bind(null), api);\n}\n\nexport function gitInstanceFactory(baseDir?: string | Partial<SimpleGitOptions>, options?: Partial<SimpleGitOptions>) {\n   const plugins = new PluginStore();\n   const config = createInstanceConfig(\n      baseDir && (typeof baseDir === 'string' ? {baseDir} : baseDir) || {},\n      options\n   );\n\n   if (!folderExists(config.baseDir)) {\n      throw new api.GitConstructError(config, `Cannot use simple-git on a directory that does not exist`);\n   }\n\n   if (Array.isArray(config.config)) {\n      plugins.add(commandConfigPrefixingPlugin(config.config));\n   }\n\n   plugins.add(completionDetectionPlugin(config.completion));\n   config.progress && plugins.add(progressMonitorPlugin(config.progress));\n   config.timeout && plugins.add(timeoutPlugin(config.timeout));\n   config.spawnOptions && plugins.add(spawnOptionsPlugin(config.spawnOptions));\n\n   plugins.add(errorDetectionPlugin(errorDetectionHandler(true)));\n   config.errors && plugins.add(errorDetectionPlugin(config.errors));\n\n   return new Git(config, plugins);\n}\n", "import { SimpleGit, SimpleGitOptions } from '../../../typings';\n\nimport { GitResponseError } from '../errors/git-response-error';\nimport { gitInstanceFactory } from '../git-factory';\nimport { SimpleGitTaskCallback } from '../types';\n\nconst functionNamesBuilderApi = [\n   'customBinary', 'env', 'outputHandler', 'silent',\n];\n\nconst functionNamesPromiseApi = [\n   'add',\n   'addAnnotatedTag',\n   'addConfig',\n   'addRemote',\n   'addTag',\n   'applyPatch',\n   'binaryCatFile',\n   'branch',\n   'branchLocal',\n   'catFile',\n   'checkIgnore',\n   'checkIsRepo',\n   'checkout',\n   'checkoutBranch',\n   'checkoutLatestTag',\n   'checkoutLocalBranch',\n   'clean',\n   'clone',\n   'commit',\n   'cwd',\n   'deleteLocalBranch',\n   'deleteLocalBranches',\n   'diff',\n   'diffSummary',\n   'exec',\n   'fetch',\n   'getRemotes',\n   'init',\n   'listConfig',\n   'listRemote',\n   'log',\n   'merge',\n   'mergeFromTo',\n   'mirror',\n   'mv',\n   'pull',\n   'push',\n   'pushTags',\n   'raw',\n   'rebase',\n   'remote',\n   'removeRemote',\n   'reset',\n   'revert',\n   'revparse',\n   'rm',\n   'rmKeepLocal',\n   'show',\n   'stash',\n   'stashList',\n   'status',\n   'subModule',\n   'submoduleAdd',\n   'submoduleInit',\n   'submoduleUpdate',\n   'tag',\n   'tags',\n   'updateServerInfo'\n];\n\nexport function gitP(...args: [] | [string] | [Partial<SimpleGitOptions>] | [string, Partial<SimpleGitOptions>]): SimpleGit {\n\n   let git: any;\n\n   let chain = Promise.resolve();\n\n   try {\n      git = gitInstanceFactory(...args);\n   } catch (e) {\n      chain = Promise.reject(e);\n   }\n\n   function builderReturn() {\n      return promiseApi;\n   }\n\n   function chainReturn() {\n      return chain;\n   }\n\n   const promiseApi = [...functionNamesBuilderApi, ...functionNamesPromiseApi].reduce((api: any, name: string) => {\n      const isAsync = functionNamesPromiseApi.includes(name);\n\n      const valid = isAsync ? asyncWrapper(name, git) : syncWrapper(name, git, api);\n      const alternative = isAsync ? chainReturn : builderReturn;\n\n      Object.defineProperty(api, name, {\n         enumerable: false,\n         configurable: false,\n         value: git ? valid : alternative,\n      });\n\n      return api;\n   }, {});\n\n   return promiseApi as SimpleGit;\n\n   function asyncWrapper(fn: string, git: any): (...args: any[]) => Promise<any> {\n      return function (...args: any[]) {\n         if (typeof args[args.length] === 'function') {\n            throw new TypeError(\n               'Promise interface requires that handlers are not supplied inline, ' +\n               'trailing function not allowed in call to ' + fn);\n         }\n\n         return chain.then(function () {\n            return new Promise(function (resolve, reject) {\n               const callback: SimpleGitTaskCallback = (err: Error | null, result?: any) => {\n                  if (err) {\n                     return reject(toError(err));\n                  }\n\n                  resolve(result);\n               };\n               args.push(callback);\n\n               git[fn].apply(git, args);\n            });\n         });\n      };\n   }\n\n   function syncWrapper(fn: string, git: any, api: SimpleGit) {\n      return (...args: any[]) => {\n         git[fn](...args);\n\n         return api;\n      };\n   }\n}\n\nfunction toError(error: Error | string | any): Error {\n\n   if (error instanceof Error) {\n      return error;\n   }\n\n   if (typeof error === 'string') {\n      return new Error(error);\n   }\n\n   return new GitResponseError(error);\n}\n", "\nconst {gitP} = require('./lib/runners/promise-wrapped');\nconst {esModuleFactory, gitInstanceFactory, gitExportFactory} = require('./lib/git-factory');\n\nconst simpleGit = esModuleFactory(gitExportFactory(gitInstanceFactory));\n\nmodule.exports = Object.assign(simpleGit, {gitP, simpleGit});\n"],
-  "mappings": "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",
+  "sources": ["../../src/lib/errors/git-error.ts", "../../src/lib/errors/git-response-error.ts", "../../src/lib/errors/git-construct-error.ts", "../../src/lib/errors/git-plugin-error.ts", "../../src/lib/errors/task-configuration-error.ts", "../../src/lib/utils/util.ts", "../../src/lib/utils/argument-filters.ts", "../../src/lib/utils/exit-codes.ts", "../../src/lib/utils/git-output-streams.ts", "../../src/lib/utils/line-parser.ts", "../../src/lib/utils/simple-git-options.ts", "../../src/lib/utils/task-options.ts", "../../src/lib/utils/task-parser.ts", "../../src/lib/utils/index.ts", "../../src/lib/tasks/check-is-repo.ts", "../../src/lib/responses/CleanSummary.ts", "../../src/lib/tasks/task.ts", "../../src/lib/tasks/clean.ts", "../../src/lib/responses/ConfigList.ts", "../../src/lib/tasks/config.ts", "../../src/lib/tasks/grep.ts", "../../src/lib/tasks/reset.ts", "../../src/lib/api.ts", "../../src/lib/plugins/command-config-prefixing-plugin.ts", "../../src/lib/plugins/completion-detection.plugin.ts", "../../src/lib/plugins/error-detection.plugin.ts", "../../src/lib/plugins/plugin-store.ts", "../../src/lib/plugins/progress-monitor-plugin.ts", "../../src/lib/plugins/simple-git-plugin.ts", "../../src/lib/plugins/spawn-options-plugin.ts", "../../src/lib/plugins/timout-plugin.ts", "../../src/lib/plugins/index.ts", "../../src/lib/git-logger.ts", "../../src/lib/runners/tasks-pending-queue.ts", "../../src/lib/runners/git-executor-chain.ts", "../../src/lib/runners/git-executor.ts", "../../src/lib/task-callback.ts", "../../src/lib/tasks/change-working-directory.ts", "../../src/lib/parsers/parse-commit.ts", "../../src/lib/tasks/commit.ts", "../../src/lib/tasks/hash-object.ts", "../../src/lib/responses/InitSummary.ts", "../../src/lib/tasks/init.ts", "../../src/lib/responses/DiffSummary.ts", "../../src/lib/parsers/parse-diff-summary.ts", "../../src/lib/parsers/parse-list-log-summary.ts", "../../src/lib/tasks/log.ts", "../../src/lib/responses/MergeSummary.ts", "../../src/lib/responses/PullSummary.ts", "../../src/lib/parsers/parse-remote-objects.ts", "../../src/lib/parsers/parse-remote-messages.ts", "../../src/lib/parsers/parse-pull.ts", "../../src/lib/parsers/parse-merge.ts", "../../src/lib/tasks/merge.ts", "../../src/lib/parsers/parse-push.ts", "../../src/lib/tasks/push.ts", "../../src/lib/responses/FileStatusSummary.ts", "../../src/lib/responses/StatusSummary.ts", "../../src/lib/tasks/status.ts", "../../src/lib/simple-git-api.ts", "../../src/lib/runners/scheduler.ts", "../../src/lib/tasks/apply-patch.ts", "../../src/lib/responses/BranchDeleteSummary.ts", "../../src/lib/parsers/parse-branch-delete.ts", "../../src/lib/responses/BranchSummary.ts", "../../src/lib/parsers/parse-branch.ts", "../../src/lib/tasks/branch.ts", "../../src/lib/responses/CheckIgnore.ts", "../../src/lib/tasks/check-ignore.ts", "../../src/lib/tasks/clone.ts", "../../src/lib/tasks/diff.ts", "../../src/lib/parsers/parse-fetch.ts", "../../src/lib/tasks/fetch.ts", "../../src/lib/parsers/parse-move.ts", "../../src/lib/tasks/move.ts", "../../src/lib/tasks/pull.ts", "../../src/lib/responses/GetRemoteSummary.ts", "../../src/lib/tasks/remote.ts", "../../src/lib/tasks/stash-list.ts", "../../src/lib/tasks/sub-module.ts", "../../src/lib/responses/TagList.ts", "../../src/lib/tasks/tag.ts", "../../src/git.js", "../../src/lib/git-factory.ts", "../../src/lib/runners/promise-wrapped.ts", "../../src/index.js"],
+  "sourcesContent": ["import { SimpleGitTask } from '../types';\n\n/**\n * The `GitError` is thrown when the underlying `git` process throws a\n * fatal exception (eg an `ENOENT` exception when attempting to use a\n * non-writable directory as the root for your repo), and acts as the\n * base class for more specific errors thrown by the parsing of the\n * git response or errors in the configuration of the task about to\n * be run.\n *\n * When an exception is thrown, pending tasks in the same instance will\n * not be executed. The recommended way to run a series of tasks that\n * can independently fail without needing to prevent future tasks from\n * running is to catch them individually:\n *\n * ```typescript\n import { gitP, SimpleGit, GitError, PullResult } from 'simple-git';\n\n function catchTask (e: GitError) {\n   return e.\n }\n\n const git = gitP(repoWorkingDir);\n const pulled: PullResult | GitError = await git.pull().catch(catchTask);\n const pushed: string | GitError = await git.pushTags().catch(catchTask);\n ```\n */\nexport class GitError extends Error {\n\n   constructor (\n      public task?: SimpleGitTask<any>,\n      message?: string,\n   ) {\n      super(message);\n      Object.setPrototypeOf(this, new.target.prototype);\n   }\n\n}\n", "import { GitError } from './git-error';\n\n/**\n * The `GitResponseError` is the wrapper for a parsed response that is treated as\n * a fatal error, for example attempting a `merge` can leave the repo in a corrupted\n * state when there are conflicts so the task will reject rather than resolve.\n *\n * For example, catching the merge conflict exception:\n *\n * ```typescript\n import { gitP, SimpleGit, GitResponseError, MergeSummary } from 'simple-git';\n\n const git = gitP(repoRoot);\n const mergeOptions: string[] = ['--no-ff', 'other-branch'];\n const mergeSummary: MergeSummary = await git.merge(mergeOptions)\n      .catch((e: GitResponseError<MergeSummary>) => e.git);\n\n if (mergeSummary.failed) {\n   // deal with the error\n }\n ```\n */\nexport class GitResponseError<T = any> extends GitError {\n\n   constructor(\n      /**\n       * `.git` access the parsed response that is treated as being an error\n       */\n      public readonly git: T,\n      message?: string,\n   ) {\n      super(undefined, message || String(git));\n   }\n\n}\n", "import { GitError } from './git-error';\nimport { SimpleGitOptions } from '../types';\n\n/**\n * The `GitConstructError` is thrown when an error occurs in the constructor\n * of the `simple-git` instance itself. Most commonly as a result of using\n * a `baseDir` option that points to a folder that either does not exist,\n * or cannot be read by the user the node script is running as.\n *\n * Check the `.message` property for more detail including the properties\n * passed to the constructor.\n */\nexport class GitConstructError extends GitError {\n\n   constructor (\n      public readonly config: SimpleGitOptions,\n      message: string,\n   ) {\n      super(undefined, message);\n   }\n\n}\n", "import { SimpleGitOptions, SimpleGitTask } from '../types';\nimport { GitError } from './git-error';\n\nexport class GitPluginError extends GitError {\n\n   constructor (\n      public task?: SimpleGitTask<any>,\n      public readonly plugin?: keyof SimpleGitOptions,\n      message?: string,\n   ) {\n      super(task, message);\n      Object.setPrototypeOf(this, new.target.prototype);\n   }\n\n}\n", "import { GitError } from './git-error';\n\n/**\n * The `TaskConfigurationError` is thrown when a command was incorrectly\n * configured. An error of this kind means that no attempt was made to\n * run your command through the underlying `git` binary.\n *\n * Check the `.message` property for more detail on why your configuration\n * resulted in an error.\n */\nexport class TaskConfigurationError extends GitError {\n\n   constructor (\n      message?: string,\n   ) {\n      super(undefined, message);\n   }\n\n}\n", "import { exists, FOLDER } from '@kwsites/file-exists';\nimport { Maybe } from '../types';\n\nexport const NULL = '\\0';\n\nexport const NOOP: (...args: any[]) => void = () => {\n};\n\n/**\n * Returns either the source argument when it is a `Function`, or the default\n * `NOOP` function constant\n */\nexport function asFunction<T extends () => any>(source: T | any): T {\n   return typeof source === 'function' ? source : NOOP;\n}\n\n/**\n * Determines whether the supplied argument is both a function, and is not\n * the `NOOP` function.\n */\nexport function isUserFunction<T extends Function>(source: T | any): source is T {\n   return (typeof source === 'function' && source !== NOOP);\n}\n\nexport function splitOn(input: string, char: string): [string, string] {\n   const index = input.indexOf(char);\n   if (index <= 0) {\n      return [input, ''];\n   }\n\n   return [\n      input.substr(0, index),\n      input.substr(index + 1),\n   ];\n}\n\nexport function first<T extends any[]>(input: T, offset?: number): Maybe<T[number]>;\nexport function first<T extends IArguments>(input: T, offset?: number): Maybe<unknown>;\nexport function first(input: any[] | IArguments, offset = 0): Maybe<unknown> {\n   return isArrayLike(input) && input.length > offset ? input[offset] : undefined;\n}\n\nexport function last<T extends any[]>(input: T, offset?: number): Maybe<T[number]>;\nexport function last<T extends IArguments>(input: T, offset?: number): Maybe<unknown>;\nexport function last<T>(input: T, offset?: number): Maybe<unknown>;\nexport function last(input: unknown, offset = 0) {\n   if (isArrayLike(input) && input.length > offset) {\n      return input[input.length - 1 - offset];\n   }\n}\n\ntype ArrayLike<T = any> = T[] | IArguments | { [index: number]: T; length: number };\n\nfunction isArrayLike(input: any): input is ArrayLike {\n   return !!(input && typeof input.length === 'number');\n}\n\nexport function toLinesWithContent(input = '', trimmed = true, separator = '\\n'): string[] {\n   return input.split(separator)\n      .reduce((output, line) => {\n         const lineContent = trimmed ? line.trim() : line;\n         if (lineContent) {\n            output.push(lineContent);\n         }\n         return output;\n      }, [] as string[]);\n}\n\ntype LineWithContentCallback<T = void> = (line: string) => T;\n\nexport function forEachLineWithContent<T>(input: string, callback: LineWithContentCallback<T>): T[] {\n   return toLinesWithContent(input, true).map(line => callback(line));\n}\n\nexport function folderExists(path: string): boolean {\n   return exists(path, FOLDER);\n}\n\n/**\n * Adds `item` into the `target` `Array` or `Set` when it is not already present and returns the `item`.\n */\nexport function append<T>(target: T[] | Set<T>, item: T): typeof item {\n   if (Array.isArray(target)) {\n      if (!target.includes(item)) {\n         target.push(item);\n      }\n   } else {\n      target.add(item);\n   }\n   return item;\n}\n\n/**\n * Adds `item` into the `target` `Array` when it is not already present and returns the `target`.\n */\nexport function including<T>(target: T[], item: T): typeof target {\n   if (Array.isArray(target) && !target.includes(item)) {\n      target.push(item);\n   }\n\n   return target;\n}\n\nexport function remove<T>(target: Set<T> | T[], item: T): T {\n   if (Array.isArray(target)) {\n      const index = target.indexOf(item);\n      if (index >= 0) {\n         target.splice(index, 1);\n      }\n   } else {\n      target.delete(item);\n   }\n   return item;\n}\n\nexport const objectToString = Object.prototype.toString.call.bind(Object.prototype.toString) as (input: any) => string;\n\nexport function asArray<T>(source: T | T[]): T[] {\n   return Array.isArray(source) ? source : [source];\n}\n\nexport function asStringArray<T>(source: T | T[]): string[] {\n   return asArray(source).map(String);\n}\n\nexport function asNumber(source: string | null | undefined, onNaN = 0) {\n   if (source == null) {\n      return onNaN;\n   }\n\n   const num = parseInt(source, 10);\n   return isNaN(num) ? onNaN : num;\n}\n\nexport function prefixedArray<T>(input: T[], prefix: T): T[] {\n   const output: T[] = [];\n   for (let i = 0, max = input.length; i < max; i++) {\n      output.push(prefix, input[i]);\n   }\n   return output;\n}\n\nexport function bufferToString(input: Buffer | Buffer[]): string {\n   return (Array.isArray(input) ? Buffer.concat(input) : input).toString('utf-8');\n}\n\n/**\n * Get a new object from a source object with only the listed properties.\n */\nexport function pick(source: Record<string, any>, properties: string[]) {\n   return Object.assign({}, ...properties.map((property) => property in source ? {[property]: source[property]} : {}));\n}\n\nexport function delay(duration = 0): Promise<void> {\n   return new Promise(done => setTimeout(done, duration));\n}\n", "import { Maybe, Options, Primitives } from '../types';\nimport { objectToString } from './util';\n\nexport interface ArgumentFilterPredicate<T> {\n   (input: any): input is T;\n}\n\nexport function filterType<T, K>(input: K, filter: ArgumentFilterPredicate<T>): K extends T ? T : undefined;\nexport function filterType<T, K>(input: K, filter: ArgumentFilterPredicate<T>, def: T): T;\nexport function filterType<T, K>(input: K, filter: ArgumentFilterPredicate<T>, def?: T): Maybe<T> {\n   if (filter(input)) {\n      return input;\n   }\n   return (arguments.length > 2) ? def : undefined\n}\n\nexport const filterArray: ArgumentFilterPredicate<Array<any>> = (input): input is Array<any> => {\n   return Array.isArray(input);\n}\n\nexport function filterPrimitives(input: unknown, omit?: Array<'boolean' | 'string' | 'number'>): input is Primitives {\n   return /number|string|boolean/.test(typeof input) && (!omit || !omit.includes((typeof input) as 'boolean' | 'string' | 'number'));\n}\n\nexport const filterString: ArgumentFilterPredicate<string> = (input): input is string => {\n   return typeof input === 'string';\n};\n\nexport const filterStringArray: ArgumentFilterPredicate<string[]> = (input): input is string[] => {\n   return Array.isArray(input) && input.every(filterString);\n};\n\nexport const filterStringOrStringArray: ArgumentFilterPredicate<string | string[]> = (input): input is string | string[] => {\n   return filterString(input) || (Array.isArray(input) && input.every(filterString));\n};\n\nexport function filterPlainObject<T extends Options>(input: T | unknown): input is T;\nexport function filterPlainObject<T extends Object>(input: T | unknown): input is T {\n   return !!input && objectToString(input) === '[object Object]';\n}\n\nexport function filterFunction(input: unknown): input is Function {\n   return typeof input === 'function';\n}\n\nexport const filterHasLength: ArgumentFilterPredicate<{ length: number }> = (input): input is { length: number } => {\n   if (input == null || 'number|boolean|function'.includes(typeof input)) {\n      return false;\n   }\n   return Array.isArray(input) || typeof input === 'string' || typeof input.length === 'number';\n}\n", "/**\n * Known process exit codes used by the task parsers to determine whether an error\n * was one they can automatically handle\n */\nexport enum ExitCodes {\n   SUCCESS,\n   ERROR,\n   UNCLEAN = 128,\n}\n", "import { TaskResponseFormat } from '../types';\n\nexport class GitOutputStreams<T extends TaskResponseFormat = Buffer> {\n\n   constructor(public readonly stdOut: T, public readonly stdErr: T) {\n   }\n\n   asStrings(): GitOutputStreams<string> {\n      return new GitOutputStreams(this.stdOut.toString('utf8'), this.stdErr.toString('utf8'));\n   }\n}\n", "export class LineParser<T> {\n\n   protected matches: string[] = [];\n\n   private _regExp: RegExp[];\n\n   constructor(\n      regExp: RegExp | RegExp[],\n      useMatches?: (target: T, match: string[]) => boolean | void,\n   ) {\n      this._regExp = Array.isArray(regExp) ? regExp : [regExp];\n      if (useMatches) {\n         this.useMatches = useMatches;\n      }\n   }\n\n   parse = (line: (offset: number) => (string | undefined), target: T): boolean => {\n      this.resetMatches();\n\n      if (!this._regExp.every((reg, index) => this.addMatch(reg, index, line(index)))) {\n         return false;\n      }\n\n      return this.useMatches(target, this.prepareMatches()) !== false;\n   }\n\n   // @ts-ignore\n   protected useMatches(target: T, match: string[]): boolean | void {\n      throw new Error(`LineParser:useMatches not implemented`);\n   }\n\n   protected resetMatches() {\n      this.matches.length = 0;\n   }\n\n   protected prepareMatches() {\n      return this.matches;\n   }\n\n   protected addMatch(reg: RegExp, index: number, line?: string) {\n      const matched = line && reg.exec(line);\n      if (matched) {\n         this.pushMatch(index, matched);\n      }\n\n      return !!matched;\n   }\n\n   protected pushMatch(_index: number, matched: string[]) {\n      this.matches.push(...matched.slice(1));\n   }\n\n}\n\nexport class RemoteLineParser<T> extends LineParser<T> {\n\n   protected addMatch(reg: RegExp, index: number, line?: string): boolean {\n      return /^remote:\\s/.test(String(line)) && super.addMatch(reg, index, line);\n   }\n\n   protected pushMatch(index: number, matched: string[]) {\n      if (index > 0 || matched.length > 1) {\n         super.pushMatch(index, matched);\n      }\n   }\n\n}\n", "import { SimpleGitOptions } from '../types';\n\nconst defaultOptions: Omit<SimpleGitOptions, 'baseDir'> = {\n   binary: 'git',\n   maxConcurrentProcesses: 5,\n   config: [],\n};\n\nexport function createInstanceConfig(...options: Array<Partial<SimpleGitOptions> | undefined>): SimpleGitOptions {\n   const baseDir = process.cwd();\n   const config: SimpleGitOptions = Object.assign({baseDir, ...defaultOptions},\n      ...(options.filter(o => typeof o === 'object' && o))\n   );\n\n   config.baseDir = config.baseDir || baseDir;\n\n   return config;\n}\n", "import { filterArray, filterFunction, filterPlainObject, filterPrimitives, filterType } from './argument-filters';\nimport { asFunction, isUserFunction, last } from './util';\nimport { Maybe, Options, OptionsValues } from '../types';\n\nexport function appendTaskOptions<T extends Options = Options>(options: Maybe<T>, commands: string[] = []): string[] {\n   if (!filterPlainObject<Options>(options)) {\n      return commands;\n   }\n\n   return Object.keys(options).reduce((commands: string[], key: string) => {\n      const value: OptionsValues = options[key];\n\n      if (filterPrimitives(value, ['boolean'])) {\n         commands.push(key + '=' + value);\n      } else {\n         commands.push(key);\n      }\n\n      return commands;\n   }, commands);\n}\n\nexport function getTrailingOptions(args: IArguments, initialPrimitive = 0, objectOnly = false): string[] {\n   const command: string[] = [];\n\n   for (let i = 0, max = initialPrimitive < 0 ? args.length : initialPrimitive; i < max; i++) {\n      if ('string|number'.includes(typeof args[i])) {\n         command.push(String(args[i]));\n      }\n   }\n\n   appendTaskOptions(trailingOptionsArgument(args), command);\n   if (!objectOnly) {\n      command.push(...trailingArrayArgument(args));\n   }\n\n   return command;\n}\n\nfunction trailingArrayArgument(args: IArguments) {\n   const hasTrailingCallback = typeof last(args) === 'function';\n   return filterType(\n      last(args, hasTrailingCallback ? 1 : 0), filterArray, []\n   );\n}\n\n/**\n * Given any number of arguments, returns the trailing options argument, ignoring a trailing function argument\n * if there is one. When not found, the return value is null.\n */\nexport function trailingOptionsArgument(args: IArguments): Maybe<Options> {\n   const hasTrailingCallback = filterFunction(last(args));\n   return filterType(last(args, hasTrailingCallback ? 1 : 0), filterPlainObject);\n}\n\n/**\n * Returns either the source argument when it is a `Function`, or the default\n * `NOOP` function constant\n */\nexport function trailingFunctionArgument(args: unknown[] | IArguments | unknown, includeNoop = true): Maybe<(...args: any[]) => unknown> {\n   const callback = asFunction(last(args));\n   return includeNoop || isUserFunction(callback) ? callback : undefined;\n}\n", "import { TaskParser, TaskResponseFormat } from '../types';\nimport { GitOutputStreams } from './git-output-streams';\nimport { LineParser } from './line-parser';\nimport { toLinesWithContent } from './util';\n\nexport function callTaskParser<INPUT extends TaskResponseFormat, RESPONSE>(parser: TaskParser<INPUT, RESPONSE>, streams: GitOutputStreams<INPUT>) {\n   return parser(streams.stdOut, streams.stdErr);\n}\n\nexport function parseStringResponse<T>(result: T, parsers: LineParser<T>[], ...texts: string[]): T {\n   texts.forEach(text => {\n      for (let lines = toLinesWithContent(text), i = 0, max = lines.length; i < max; i++) {\n         const line = (offset = 0) => {\n            if ((i + offset) >= max) {\n               return;\n            }\n            return lines[i + offset];\n         }\n\n         parsers.some(({parse}) => parse(line, result));\n      }\n   });\n\n   return result;\n}\n", "\nexport * from './argument-filters';\nexport * from './exit-codes';\nexport * from './git-output-streams';\nexport * from './line-parser';\nexport * from './simple-git-options';\nexport * from './task-options';\nexport * from './task-parser';\nexport * from './util';\n", "import { ExitCodes } from '../utils';\nimport { Maybe, StringTask } from '../types';\n\nexport enum CheckRepoActions {\n   BARE = 'bare',\n   IN_TREE = 'tree',\n   IS_REPO_ROOT = 'root',\n}\n\nconst onError: StringTask<boolean>['onError'] = ({exitCode}, error, done, fail) => {\n   if (exitCode === ExitCodes.UNCLEAN && isNotRepoMessage(error)) {\n      return done(Buffer.from('false'));\n   }\n\n   fail(error);\n}\n\nconst parser: StringTask<boolean>['parser'] = (text) => {\n   return text.trim() === 'true';\n}\n\nexport function checkIsRepoTask(action: Maybe<CheckRepoActions>): StringTask<boolean> {\n   switch (action) {\n      case CheckRepoActions.BARE:\n         return checkIsBareRepoTask();\n      case CheckRepoActions.IS_REPO_ROOT:\n         return checkIsRepoRootTask();\n   }\n\n   const commands = ['rev-parse', '--is-inside-work-tree'];\n\n   return {\n      commands,\n      format: 'utf-8',\n      onError,\n      parser,\n   }\n}\n\n\nexport function checkIsRepoRootTask(): StringTask<boolean> {\n   const commands = ['rev-parse', '--git-dir'];\n\n   return {\n      commands,\n      format: 'utf-8',\n      onError,\n      parser(path) {\n         return /^\\.(git)?$/.test(path.trim());\n      },\n   }\n}\n\n\nexport function checkIsBareRepoTask(): StringTask<boolean> {\n   const commands = ['rev-parse', '--is-bare-repository'];\n\n   return {\n      commands,\n      format: 'utf-8',\n      onError,\n      parser,\n   }\n}\n\n\nfunction isNotRepoMessage(error: Error): boolean {\n   return /(Not a git repository|Kein Git-Repository)/i.test(String(error));\n}\n", "import { CleanSummary } from '../../../typings';\nimport { toLinesWithContent } from '../utils';\n\nexport class CleanResponse implements CleanSummary {\n\n   public paths: string[] = [];\n   public files: string[] = [];\n   public folders: string[] = [];\n\n   constructor(\n      public readonly dryRun: boolean,\n   ) {}\n\n}\n\nconst removalRegexp = /^[a-z]+\\s*/i;\nconst dryRunRemovalRegexp = /^[a-z]+\\s+[a-z]+\\s*/i;\nconst isFolderRegexp = /\\/$/;\n\nexport function cleanSummaryParser (dryRun: boolean, text: string): CleanSummary {\n   const summary = new CleanResponse(dryRun);\n   const regexp = dryRun ? dryRunRemovalRegexp : removalRegexp;\n\n   toLinesWithContent(text).forEach(line => {\n      const removed = line.replace(regexp, '');\n\n      summary.paths.push(removed);\n      (isFolderRegexp.test(removed) ? summary.folders : summary.files).push(removed);\n   });\n\n   return summary;\n}\n", "import { TaskConfigurationError } from '../errors/task-configuration-error';\nimport { BufferTask, EmptyTaskParser, SimpleGitTask, StringTask } from '../types';\n\nexport const EMPTY_COMMANDS: [] = [];\n\nexport type EmptyTask = {\n   commands: typeof EMPTY_COMMANDS;\n   format: 'empty',\n   parser: EmptyTaskParser;\n   onError?: undefined;\n};\n\n\nexport function adhocExecTask(parser: EmptyTaskParser): EmptyTask {\n   return {\n      commands: EMPTY_COMMANDS,\n      format: 'empty',\n      parser,\n   };\n}\n\nexport function configurationErrorTask(error: Error | string): EmptyTask {\n   return {\n      commands: EMPTY_COMMANDS,\n      format: 'empty',\n      parser() {\n         throw typeof error === 'string' ? new TaskConfigurationError(error) : error;\n      }\n   }\n}\n\nexport function straightThroughStringTask(commands: string[], trimmed = false): StringTask<string> {\n   return {\n      commands,\n      format: 'utf-8',\n      parser(text) {\n         return trimmed ? String(text).trim() : text;\n      },\n   }\n}\n\nexport function straightThroughBufferTask(commands: string[]): BufferTask<any> {\n   return {\n      commands,\n      format: 'buffer',\n      parser(buffer) {\n         return buffer;\n      },\n   }\n}\n\nexport function isBufferTask<R>(task: SimpleGitTask<R>): task is BufferTask<R> {\n   return task.format === 'buffer';\n}\n\nexport function isEmptyTask<R>(task: SimpleGitTask<R>): task is EmptyTask {\n   return task.format === 'empty' || !task.commands.length;\n}\n", "import { CleanSummary } from '../../../typings';\nimport { cleanSummaryParser } from '../responses/CleanSummary';\nimport { Maybe, StringTask } from '../types';\nimport { asStringArray } from '../utils';\nimport { configurationErrorTask } from './task';\n\nexport const CONFIG_ERROR_INTERACTIVE_MODE = 'Git clean interactive mode is not supported';\nexport const CONFIG_ERROR_MODE_REQUIRED = 'Git clean mode parameter (\"n\" or \"f\") is required';\nexport const CONFIG_ERROR_UNKNOWN_OPTION = 'Git clean unknown option found in: ';\n\n/**\n * All supported option switches available for use in a `git.clean` operation\n */\nexport enum CleanOptions {\n   DRY_RUN = 'n',\n   FORCE = 'f',\n   IGNORED_INCLUDED = 'x',\n   IGNORED_ONLY = 'X',\n   EXCLUDING = 'e',\n   QUIET = 'q',\n   RECURSIVE = 'd',\n}\n\n/**\n * The two modes `git.clean` can run in - one of these must be supplied in order\n * for the command to not throw a `TaskConfigurationError`\n */\nexport type CleanMode = CleanOptions.FORCE | CleanOptions.DRY_RUN;\n\nconst CleanOptionValues: Set<string> = new Set(['i', ...asStringArray(Object.values(CleanOptions as any))]);\n\nexport function cleanWithOptionsTask(mode: CleanMode | string, customArgs: string[]) {\n   const {cleanMode, options, valid} = getCleanOptions(mode);\n\n   if (!cleanMode) {\n      return configurationErrorTask(CONFIG_ERROR_MODE_REQUIRED);\n   }\n\n   if (!valid.options) {\n      return configurationErrorTask(CONFIG_ERROR_UNKNOWN_OPTION + JSON.stringify(mode));\n   }\n\n   options.push(...customArgs);\n\n   if (options.some(isInteractiveMode)) {\n      return configurationErrorTask(CONFIG_ERROR_INTERACTIVE_MODE);\n   }\n\n   return cleanTask(cleanMode, options);\n}\n\nexport function cleanTask(mode: CleanMode, customArgs: string[]): StringTask<CleanSummary> {\n   const commands: string[] = ['clean', `-${mode}`, ...customArgs];\n\n   return {\n      commands,\n      format: 'utf-8',\n      parser(text: string): CleanSummary {\n         return cleanSummaryParser(mode === CleanOptions.DRY_RUN, text);\n      }\n   }\n}\n\nexport function isCleanOptionsArray (input: string[]): input is CleanOptions[] {\n   return Array.isArray(input) && input.every(test => CleanOptionValues.has(test));\n}\n\nfunction getCleanOptions(input: string) {\n   let cleanMode: Maybe<CleanMode>;\n   let options: string[] = [];\n   let valid = {cleanMode: false, options: true};\n\n   input.replace(/[^a-z]i/g, '').split('').forEach(char => {\n      if (isCleanMode(char)) {\n         cleanMode = char;\n         valid.cleanMode = true;\n      }\n      else {\n         valid.options = valid.options && isKnownOption(options[options.length] = (`-${char}`));\n      }\n   });\n\n   return {\n      cleanMode,\n      options,\n      valid,\n   }\n}\n\nfunction isCleanMode(cleanMode?: string): cleanMode is CleanMode {\n   return cleanMode === CleanOptions.FORCE || cleanMode === CleanOptions.DRY_RUN;\n}\n\nfunction isKnownOption(option: string): boolean {\n   return /^-[a-z]$/i.test(option) && CleanOptionValues.has(option.charAt(1));\n}\n\nfunction isInteractiveMode(option: string): boolean {\n   if (/^-[^\\-]/.test(option)) {\n      return option.indexOf('i') > 0;\n   }\n\n   return option === '--interactive';\n}\n", "import { ConfigGetResult, ConfigListSummary, ConfigValues } from '../../../typings';\nimport { last, splitOn } from '../utils';\n\nexport class ConfigList implements ConfigListSummary {\n\n   public files: string[] = [];\n   public values: { [fileName: string]: ConfigValues } = Object.create(null);\n\n   private _all: ConfigValues | undefined;\n\n   public get all(): ConfigValues {\n      if (!this._all) {\n         this._all = this.files.reduce((all: ConfigValues, file: string) => {\n            return Object.assign(all, this.values[file]);\n         }, {});\n      }\n\n      return this._all;\n   }\n\n   public addFile(file: string): ConfigValues {\n      if (!(file in this.values)) {\n         const latest = last(this.files);\n         this.values[file] = latest ? Object.create(this.values[latest]) : {}\n\n         this.files.push(file);\n      }\n\n      return this.values[file];\n   }\n\n   public addValue(file: string, key: string, value: string) {\n      const values = this.addFile(file);\n\n      if (!values.hasOwnProperty(key)) {\n         values[key] = value;\n      } else if (Array.isArray(values[key])) {\n         (values[key] as string[]).push(value);\n      } else {\n         values[key] = [values[key] as string, value];\n      }\n\n      this._all = undefined;\n   }\n\n}\n\nexport function configListParser(text: string): ConfigList {\n   const config = new ConfigList();\n\n   for (const item of configParser(text)) {\n      config.addValue(item.file, String(item.key), item.value);\n   }\n\n   return config;\n}\n\nexport function configGetParser(text: string, key: string): ConfigGetResult {\n   let value: string | null = null;\n   const values: string[] = [];\n   const scopes: Map<string, string[]> = new Map();\n\n   for (const item of configParser(text, key)) {\n      if (item.key !== key) {\n         continue;\n      }\n\n      values.push(value = item.value);\n\n      if (!scopes.has(item.file)) {\n         scopes.set(item.file, []);\n      }\n\n      scopes.get(item.file)!.push(value);\n   }\n\n   return {\n      key,\n      paths: Array.from(scopes.keys()),\n      scopes,\n      value,\n      values\n   };\n}\n\nfunction configFilePath(filePath: string): string {\n   return filePath.replace(/^(file):/, '');\n}\n\nfunction* configParser(text: string, requestedKey: string | null = null) {\n   const lines = text.split('\\0');\n\n   for (let i = 0, max = lines.length - 1; i < max;) {\n      const file = configFilePath(lines[i++]);\n\n      let value = lines[i++];\n      let key = requestedKey;\n\n      if (value.includes('\\n')) {\n         const line = splitOn(value, '\\n');\n         key = line[0];\n         value = line[1];\n      }\n\n      yield {file, key, value};\n   }\n}\n", "import { ConfigGetResult, ConfigListSummary, SimpleGit } from '../../../typings';\nimport { configGetParser, configListParser } from '../responses/ConfigList';\nimport { SimpleGitApi } from '../simple-git-api';\nimport { StringTask } from '../types';\nimport { trailingFunctionArgument } from '../utils';\n\nexport enum GitConfigScope {\n   system = 'system',\n   global = 'global',\n   local = 'local',\n   worktree = 'worktree',\n}\n\nfunction asConfigScope<T extends GitConfigScope | undefined>(scope: GitConfigScope | unknown, fallback: T): GitConfigScope | T {\n   if (typeof scope === 'string' && GitConfigScope.hasOwnProperty(scope)) {\n      return scope as GitConfigScope;\n   }\n   return fallback;\n}\n\nfunction addConfigTask(key: string, value: string, append: boolean, scope: GitConfigScope): StringTask<string> {\n   const commands: string[] = ['config', `--${scope}`];\n\n   if (append) {\n      commands.push('--add');\n   }\n\n   commands.push(key, value);\n\n   return {\n      commands,\n      format: 'utf-8',\n      parser(text: string): string {\n         return text;\n      }\n   }\n}\n\nfunction getConfigTask(key: string, scope?: GitConfigScope): StringTask<ConfigGetResult> {\n   const commands: string[] = ['config', '--null', '--show-origin', '--get-all', key];\n\n   if (scope) {\n      commands.splice(1, 0, `--${scope}`);\n   }\n\n   return {\n      commands,\n      format: 'utf-8',\n      parser(text) {\n         return configGetParser(text, key);\n      }\n   };\n}\n\nfunction listConfigTask(scope?: GitConfigScope): StringTask<ConfigListSummary> {\n   const commands = ['config', '--list', '--show-origin', '--null'];\n\n   if (scope) {\n      commands.push(`--${scope}`);\n   }\n\n   return {\n      commands,\n      format: 'utf-8',\n      parser(text: string) {\n         return configListParser(text);\n      },\n   }\n}\n\nexport default function (): Pick<SimpleGit, 'addConfig' | 'getConfig' | 'listConfig'> {\n   return {\n      addConfig(this: SimpleGitApi, key: string, value: string, ...rest: unknown[]) {\n         return this._runTask(\n            addConfigTask(key, value, rest[0] === true, asConfigScope(rest[1], GitConfigScope.local)),\n            trailingFunctionArgument(arguments),\n         );\n      },\n\n      getConfig(this: SimpleGitApi, key: string, scope?: GitConfigScope) {\n         return this._runTask(\n            getConfigTask(key, asConfigScope(scope, undefined)),\n            trailingFunctionArgument(arguments),\n         )\n      },\n\n      listConfig(this: SimpleGitApi, ...rest: unknown[]) {\n         return this._runTask(\n            listConfigTask(asConfigScope(rest[0], undefined)),\n            trailingFunctionArgument(arguments),\n         );\n      },\n   };\n}\n", "import { GrepResult, SimpleGit } from '../../../typings';\nimport { SimpleGitApi } from '../simple-git-api';\nimport {\n   asNumber,\n   forEachLineWithContent,\n   getTrailingOptions,\n   NULL,\n   prefixedArray,\n   trailingFunctionArgument\n} from '../utils';\n\nimport { configurationErrorTask } from './task';\n\nconst disallowedOptions = ['-h'];\n\nconst Query = Symbol('grepQuery');\n\nexport interface GitGrepQuery extends Iterable<string> {\n   /** Adds one or more terms to be grouped as an \"and\" to any other terms */\n   and(...and: string[]): this;\n\n   /** Adds one or more search terms - git.grep will \"or\" this to other terms */\n   param(...param: string[]): this;\n}\n\nclass GrepQuery implements GitGrepQuery {\n   private [Query]: string[] = [];\n\n   * [Symbol.iterator]() {\n      for (const query of this[Query]) {\n         yield query;\n      }\n   }\n\n   and(...and: string[]) {\n      and.length && this[Query].push('--and', '(', ...prefixedArray(and, '-e'), ')');\n      return this;\n   }\n\n   param(...param: string[]) {\n      this[Query].push(...prefixedArray(param, '-e'));\n      return this;\n   }\n}\n\n/**\n * Creates a new builder for a `git.grep` query with optional params\n */\nexport function grepQueryBuilder(...params: string[]): GitGrepQuery {\n   return new GrepQuery().param(...params);\n}\n\nfunction parseGrep(grep: string): GrepResult {\n   const paths: GrepResult['paths'] = new Set<string>();\n   const results: GrepResult['results'] = {};\n\n   forEachLineWithContent(grep, (input) => {\n      const [path, line, preview] = input.split(NULL);\n      paths.add(path);\n      (results[path] = results[path] || []).push({\n         line: asNumber(line),\n         path,\n         preview,\n      });\n   });\n\n   return {\n      paths,\n      results,\n   };\n}\n\nexport default function (): Pick<SimpleGit, 'grep'> {\n   return {\n      grep(this: SimpleGitApi, searchTerm: string | GitGrepQuery) {\n         const then = trailingFunctionArgument(arguments);\n         const options = getTrailingOptions(arguments);\n\n         for (const option of disallowedOptions) {\n            if (options.includes(option)) {\n               return this._runTask(\n                  configurationErrorTask(`git.grep: use of \"${option}\" is not supported.`),\n                  then,\n               );\n            }\n         }\n\n         if (typeof searchTerm === 'string') {\n            searchTerm = grepQueryBuilder().param(searchTerm);\n         }\n\n         const commands = ['grep', '--null', '-n', '--full-name', ...options, ...searchTerm];\n\n         return this._runTask({\n            commands,\n            format: 'utf-8',\n            parser(stdOut) {\n               return parseGrep(stdOut);\n            },\n         }, then);\n      }\n   }\n}\n", "import { straightThroughStringTask } from './task';\nimport { Maybe, OptionFlags, Options } from '../types';\n\nexport enum ResetMode {\n   MIXED = 'mixed',\n   SOFT = 'soft',\n   HARD = 'hard',\n   MERGE = 'merge',\n   KEEP = 'keep',\n}\n\nconst ResetModes = Array.from(Object.values(ResetMode));\n\nexport type ResetOptions = Options &\n   OptionFlags<'-q' | '--quiet' | '--no-quiet' | '--pathspec-from-nul'> &\n   OptionFlags<'--pathspec-from-file', string>;\n\nexport function resetTask(mode: Maybe<ResetMode>, customArgs: string[]) {\n   const commands: string[] = ['reset'];\n   if (isValidResetMode(mode)) {\n      commands.push(`--${mode}`);\n   }\n   commands.push(...customArgs);\n\n   return straightThroughStringTask(commands);\n}\n\nexport function getResetMode(mode: ResetMode | any): Maybe<ResetMode> {\n   if (isValidResetMode(mode)) {\n      return mode;\n   }\n\n   switch (typeof mode) {\n      case 'string':\n      case 'undefined':\n         return ResetMode.SOFT;\n   }\n\n   return;\n}\n\nfunction isValidResetMode(mode: ResetMode | any): mode is ResetMode {\n   return ResetModes.includes(mode);\n}\n", "import { GitConstructError } from './errors/git-construct-error';\nimport { GitError } from './errors/git-error';\nimport { GitPluginError } from './errors/git-plugin-error';\nimport { GitResponseError } from './errors/git-response-error';\nimport { TaskConfigurationError } from './errors/task-configuration-error';\nimport { CheckRepoActions } from './tasks/check-is-repo';\nimport { CleanOptions } from './tasks/clean';\nimport { GitConfigScope } from './tasks/config';\nimport { grepQueryBuilder } from './tasks/grep';\nimport { ResetMode } from './tasks/reset';\n\nexport {\n   CheckRepoActions,\n   CleanOptions,\n   GitConfigScope,\n   GitConstructError,\n   GitError,\n   GitPluginError,\n   GitResponseError,\n   ResetMode,\n   TaskConfigurationError,\n   grepQueryBuilder,\n};\n\n// export const api = {\n//    CheckRepoActions,\n//    CleanOptions,\n//    GitConfigScope,\n//    GitConstructError,\n//    GitError,\n//    GitPluginError,\n//    GitResponseError,\n//    ResetMode,\n//    TaskConfigurationError,\n//    grepQueryBuilder,\n// };\n", "import { prefixedArray } from '../utils';\nimport { SimpleGitPlugin } from './simple-git-plugin';\n\nexport function commandConfigPrefixingPlugin(configuration: string[]): SimpleGitPlugin<'spawn.args'> {\n   const prefix = prefixedArray(configuration, '-c');\n\n   return {\n      type: 'spawn.args',\n      action(data) {\n         return [...prefix, ...data];\n      },\n   };\n}\n", "import { deferred, DeferredPromise } from '@kwsites/promise-deferred';\nimport { SimpleGitPluginConfig } from '../types';\nimport { delay } from '../utils';\nimport { SimpleGitPlugin } from './simple-git-plugin';\n\nconst never = deferred().promise;\n\nexport function completionDetectionPlugin({\n                                             onClose = true,\n                                             onExit = 50\n                                          }: SimpleGitPluginConfig['completion'] = {}): SimpleGitPlugin<'spawn.after'> {\n\n   function createEvents() {\n      let exitCode = -1;\n      const events = {\n         close: deferred(),\n         closeTimeout: deferred(),\n         exit: deferred(),\n         exitTimeout: deferred(),\n      };\n\n      const result = Promise.race([\n         onClose === false ? never : events.closeTimeout.promise,\n         onExit === false ? never : events.exitTimeout.promise,\n      ]);\n\n      configureTimeout(onClose, events.close, events.closeTimeout);\n      configureTimeout(onExit, events.exit, events.exitTimeout);\n\n      return {\n         close(code: number) {\n            exitCode = code;\n            events.close.done();\n         },\n         exit(code: number) {\n            exitCode = code;\n            events.exit.done();\n         },\n         get exitCode() {\n            return exitCode;\n         },\n         result,\n      };\n   }\n\n   function configureTimeout(flag: boolean | number, event: DeferredPromise<void>, timeout: DeferredPromise<void>) {\n      if (flag === false) {\n         return;\n      }\n\n      (flag === true ? event.promise : event.promise.then(() => delay(flag))).then(timeout.done);\n   }\n\n   return {\n      type: 'spawn.after',\n      async action(_data, {spawned, close}) {\n         const events = createEvents();\n\n         let deferClose = true;\n         let quickClose = () => void (deferClose = false);\n\n         spawned.stdout?.on('data', quickClose);\n         spawned.stderr?.on('data', quickClose);\n         spawned.on('error', quickClose);\n\n         spawned.on('close', (code: number) => events.close(code));\n         spawned.on('exit', (code: number) => events.exit(code));\n\n         try{\n            await events.result;\n            if (deferClose) {\n               await delay(50);\n            }\n            close(events.exitCode);\n         }\n         catch (err) {\n            close(events.exitCode, err);\n         }\n      }\n   }\n}\n", "import { GitError } from '../errors/git-error';\nimport { GitExecutorResult, SimpleGitPluginConfig } from '../types';\nimport { SimpleGitPlugin } from './simple-git-plugin';\n\ntype TaskResult = Omit<GitExecutorResult, 'rejection'>;\n\nfunction isTaskError (result: TaskResult) {\n   return !!(result.exitCode && result.stdErr.length);\n}\n\nfunction getErrorMessage (result: TaskResult) {\n   return Buffer.concat([...result.stdOut, ...result.stdErr]);\n}\n\nexport function errorDetectionHandler (overwrite = false, isError = isTaskError, errorMessage: (result: TaskResult) => Buffer | Error = getErrorMessage) {\n\n   return (error: Buffer | Error | undefined, result: TaskResult) => {\n      if ((!overwrite && error) || !isError(result)) {\n         return error;\n      }\n\n      return errorMessage(result);\n   };\n}\n\nexport function errorDetectionPlugin(config: SimpleGitPluginConfig['errors']): SimpleGitPlugin<'task.error'> {\n\n   return {\n      type: 'task.error',\n      action(data, context) {\n         const error = config(data.error, {\n            stdErr: context.stdErr,\n            stdOut: context.stdOut,\n            exitCode: context.exitCode\n         });\n\n         if (Buffer.isBuffer(error)) {\n            return {error: new GitError(undefined, error.toString('utf-8'))};\n         }\n\n         return {\n            error\n         };\n      },\n   };\n\n}\n", "import { SimpleGitPlugin, SimpleGitPluginType, SimpleGitPluginTypes } from './simple-git-plugin';\nimport { append, asArray } from '../utils';\n\nexport class PluginStore {\n\n   private plugins: Set<SimpleGitPlugin<SimpleGitPluginType>> = new Set();\n\n   public add<T extends SimpleGitPluginType>(plugin: void | SimpleGitPlugin<T> | SimpleGitPlugin<T>[]) {\n      const plugins: SimpleGitPlugin<T>[] = [];\n\n      asArray(plugin).forEach(plugin => plugin && this.plugins.add(append(plugins, plugin)));\n\n      return () => {\n         plugins.forEach(plugin => this.plugins.delete(plugin));\n      };\n   }\n\n   public exec<T extends SimpleGitPluginType>(type: T, data: SimpleGitPluginTypes[T]['data'], context: SimpleGitPluginTypes[T]['context']): typeof data {\n      let output = data;\n      const contextual = Object.freeze(Object.create(context));\n\n      for (const plugin of this.plugins) {\n         if (plugin.type === type) {\n            output = plugin.action(output, contextual);\n         }\n      }\n\n      return output;\n   }\n\n}\n", "import { SimpleGitOptions } from '../types';\nimport { asNumber, including } from '../utils';\n\nimport { SimpleGitPlugin } from './simple-git-plugin';\n\nexport function progressMonitorPlugin(progress: Exclude<SimpleGitOptions['progress'], void>) {\n   const progressCommand = '--progress';\n   const progressMethods = ['checkout', 'clone', 'fetch', 'pull', 'push'];\n\n   const onProgress: SimpleGitPlugin<'spawn.after'> = {\n      type: 'spawn.after',\n      action(_data, context) {\n         if (!context.commands.includes(progressCommand)) {\n            return;\n         }\n\n         context.spawned.stderr?.on('data', (chunk: Buffer) => {\n            const message = /^([\\s\\S]+?):\\s*(\\d+)% \\((\\d+)\\/(\\d+)\\)/.exec(chunk.toString('utf8'));\n            if (!message) {\n               return;\n            }\n\n            progress({\n               method: context.method,\n               stage: progressEventStage(message[1]),\n               progress: asNumber(message[2]),\n               processed: asNumber(message[3]),\n               total: asNumber(message[4]),\n            });\n         });\n      }\n   };\n\n   const onArgs: SimpleGitPlugin<'spawn.args'> = {\n      type: 'spawn.args',\n      action(args, context) {\n         if (!progressMethods.includes(context.method)) {\n            return args;\n         }\n\n         return including(args, progressCommand);\n      }\n   }\n\n   return [onArgs, onProgress];\n}\n\nfunction progressEventStage (input: string) {\n   return String(input.toLowerCase().split(' ', 1)) || 'unknown';\n}\n", "import { ChildProcess, SpawnOptions } from 'child_process';\nimport { GitExecutorResult } from '../types';\n\ntype SimpleGitTaskPluginContext = {\n   readonly method: string;\n   readonly commands: string[];\n}\n\nexport interface SimpleGitPluginTypes {\n   'spawn.args': {\n      data: string[];\n      context: SimpleGitTaskPluginContext & {};\n   };\n   'spawn.options': {\n      data: Partial<SpawnOptions>;\n      context: SimpleGitTaskPluginContext & {};\n   };\n   'spawn.after': {\n      data: void;\n      context: SimpleGitTaskPluginContext & {\n         spawned: ChildProcess;\n         close (exitCode: number, reason?: Error): void;\n         kill (reason: Error): void;\n      };\n   },\n   'task.error': {\n      data: { error?: Error };\n      context: SimpleGitTaskPluginContext & GitExecutorResult;\n   },\n}\n\nexport type SimpleGitPluginType = keyof SimpleGitPluginTypes;\n\nexport interface SimpleGitPlugin<T extends SimpleGitPluginType> {\n   action(data: SimpleGitPluginTypes[T]['data'], context: SimpleGitPluginTypes[T]['context']): typeof data;\n\n   type: T;\n}\n", "import { SpawnOptions } from 'child_process';\nimport { pick } from '../utils';\nimport { SimpleGitPlugin } from './simple-git-plugin';\n\nexport function spawnOptionsPlugin(spawnOptions: Partial<SpawnOptions>): SimpleGitPlugin<'spawn.options'> {\n   const options = pick(spawnOptions, ['uid', 'gid']);\n\n   return {\n      type: 'spawn.options',\n      action(data) {\n         return {...options, ...data};\n      },\n   };\n}\n", "import { SimpleGitOptions } from '../types';\n\nimport { SimpleGitPlugin } from './simple-git-plugin';\nimport { GitPluginError } from '../errors/git-plugin-error';\n\nexport function timeoutPlugin({block}: Exclude<SimpleGitOptions['timeout'], undefined>): SimpleGitPlugin<'spawn.after'> | void {\n\n   if (block > 0) {\n      return {\n         type: 'spawn.after',\n         action(_data, context) {\n            let timeout: NodeJS.Timeout;\n\n            function wait() {\n               timeout && clearTimeout(timeout);\n               timeout = setTimeout(kill, block);\n            }\n\n            function stop() {\n               context.spawned.stdout?.off('data', wait);\n               context.spawned.stderr?.off('data', wait);\n               context.spawned.off('exit', stop);\n               context.spawned.off('close', stop);\n               timeout && clearTimeout(timeout);\n            }\n\n            function kill() {\n               stop()\n               context.kill(\n                  new GitPluginError(undefined, 'timeout', `block timeout reached`)\n               );\n            }\n\n            context.spawned.stdout?.on('data', wait);\n            context.spawned.stderr?.on('data', wait);\n            context.spawned.on('exit', stop);\n            context.spawned.on('close', stop);\n\n            wait();\n         }\n      }\n   }\n\n}\n", "export * from './command-config-prefixing-plugin';\nexport * from './completion-detection.plugin';\nexport * from './error-detection.plugin';\nexport * from './plugin-store';\nexport * from './progress-monitor-plugin';\nexport * from './simple-git-plugin';\nexport * from './spawn-options-plugin';\nexport * from './timout-plugin';\n", "import debug, { Debugger } from 'debug';\nimport { append, filterHasLength, filterString, filterType, NOOP, objectToString, remove } from './utils';\nimport { Maybe } from './types';\n\ndebug.formatters.L = (value: any) => String(filterHasLength(value) ? value.length : '-');\ndebug.formatters.B = (value: Buffer) => {\n   if (Buffer.isBuffer(value)) {\n      return value.toString('utf8');\n   }\n   return objectToString(value);\n}\n\ntype OutputLoggingHandler = (message: string, ...args: any[]) => void;\n\nfunction createLog () {\n   return debug('simple-git');\n}\n\nexport interface OutputLogger extends OutputLoggingHandler {\n   readonly label: string;\n\n   info: OutputLoggingHandler;\n   step (nextStep?: string): OutputLogger;\n   sibling (name: string): OutputLogger;\n}\n\nfunction prefixedLogger (to: Debugger, prefix: string, forward?: OutputLoggingHandler): OutputLoggingHandler {\n   if (!prefix || !String(prefix).replace(/\\s*/, '')) {\n      return !forward ? to : (message, ...args) => {\n         to(message, ...args);\n         forward(message, ...args);\n      };\n   }\n\n   return (message, ...args) => {\n      to(`%s ${message}`, prefix, ...args);\n      if (forward) {\n         forward(message, ...args);\n      }\n   };\n}\n\nfunction childLoggerName (name: Maybe<string>, childDebugger: Maybe<Debugger>, {namespace: parentNamespace}: Debugger): string {\n   if (typeof name === 'string') {\n      return name;\n   }\n   const childNamespace = childDebugger && childDebugger.namespace || '';\n\n   if (childNamespace.startsWith(parentNamespace)) {\n      return childNamespace.substr(parentNamespace.length + 1);\n   }\n\n   return childNamespace || parentNamespace;\n}\n\nexport function createLogger (label: string, verbose?: string | Debugger, initialStep?: string, infoDebugger = createLog()): OutputLogger {\n   const labelPrefix = label && `[${label}]` || '';\n\n   const spawned: OutputLogger[] = [];\n   const debugDebugger: Maybe<Debugger> = (typeof verbose === 'string') ? infoDebugger.extend(verbose) : verbose;\n   const key = childLoggerName(filterType(verbose, filterString), debugDebugger, infoDebugger);\n\n   return step(initialStep);\n\n   function sibling(name: string, initial?: string) {\n      return append(spawned, createLogger(label, key.replace(/^[^:]+/, name), initial, infoDebugger));\n   }\n\n   function step(phase?: string) {\n      const stepPrefix = phase && `[${phase}]` || '';\n      const debug = debugDebugger && prefixedLogger(debugDebugger, stepPrefix) || NOOP;\n      const info = prefixedLogger(infoDebugger, `${labelPrefix} ${ stepPrefix}`, debug);\n\n      return Object.assign(debugDebugger ? debug : info, {\n         label,\n         sibling,\n         info,\n         step,\n      });\n   }\n}\n\n/**\n * The `GitLogger` is used by the main `SimpleGit` runner to handle logging\n * any warnings or errors.\n */\nexport class GitLogger {\n\n   public error: OutputLoggingHandler;\n\n   public warn: OutputLoggingHandler\n\n   constructor(private _out: Debugger = createLog()) {\n      this.error = prefixedLogger(_out, '[ERROR]');\n      this.warn = prefixedLogger(_out, '[WARN]');\n   }\n\n   silent (silence = false) {\n      if (silence !== this._out.enabled) {\n         return;\n      }\n\n      const {namespace} = this._out;\n      const env = (process.env.DEBUG || '').split(',').filter(s => !!s);\n      const hasOn = env.includes(namespace);\n      const hasOff = env.includes(`-${namespace}`);\n\n      // enabling the log\n      if (!silence) {\n         if (hasOff) {\n            remove(env, `-${namespace}`);\n         }\n         else {\n            env.push(namespace);\n         }\n      }\n      else {\n         if (hasOn) {\n            remove(env, namespace);\n         }\n         else {\n            env.push(`-${namespace}`);\n         }\n      }\n\n      debug.enable(env.join(','));\n   }\n\n}\n", "import { SimpleGitTask } from '../types';\nimport { GitError } from '../errors/git-error';\nimport { createLogger, OutputLogger } from '../git-logger';\n\ntype AnySimpleGitTask = SimpleGitTask<any>;\n\ntype TaskInProgress = {\n   name: string;\n   logger: OutputLogger;\n   task: AnySimpleGitTask;\n}\n\nexport class TasksPendingQueue {\n\n   private _queue: Map<AnySimpleGitTask, TaskInProgress> = new Map();\n\n   constructor(private logLabel = 'GitExecutor') {\n   }\n\n   private withProgress(task: AnySimpleGitTask) {\n      return this._queue.get(task);\n   }\n\n   private createProgress (task: AnySimpleGitTask): TaskInProgress {\n      const name = TasksPendingQueue.getName(task.commands[0]);\n      const logger = createLogger(this.logLabel, name);\n\n      return {\n         task,\n         logger,\n         name,\n      };\n   }\n\n   push(task: AnySimpleGitTask): TaskInProgress {\n      const progress = this.createProgress(task);\n      progress.logger('Adding task to the queue, commands = %o', task.commands);\n\n      this._queue.set(task, progress);\n\n      return progress;\n   }\n\n   fatal(err: GitError) {\n      for (const [task, {logger}] of Array.from(this._queue.entries())) {\n         if (task === err.task) {\n            logger.info(`Failed %o`, err);\n            logger(`Fatal exception, any as-yet un-started tasks run through this executor will not be attempted`);\n         } else {\n            logger.info(`A fatal exception occurred in a previous task, the queue has been purged: %o`, err.message);\n         }\n\n         this.complete(task);\n      }\n\n      if (this._queue.size !== 0) {\n         throw new Error(`Queue size should be zero after fatal: ${this._queue.size}`);\n      }\n   }\n\n   complete(task: AnySimpleGitTask) {\n      const progress = this.withProgress(task);\n      if (progress) {\n         this._queue.delete(task);\n      }\n   }\n\n   attempt(task: AnySimpleGitTask): TaskInProgress {\n      const progress = this.withProgress(task);\n      if (!progress) {\n         throw new GitError(undefined, 'TasksPendingQueue: attempt called for an unknown task');\n      }\n      progress.logger('Starting task');\n\n      return progress;\n   }\n\n   static getName (name = 'empty') {\n      return `task:${name}:${++TasksPendingQueue.counter}`;\n   }\n\n   private static counter = 0;\n}\n", "import { spawn, SpawnOptions } from 'child_process';\nimport { GitError } from '../errors/git-error';\nimport { OutputLogger } from '../git-logger';\nimport { PluginStore } from '../plugins';\nimport { EmptyTask, isBufferTask, isEmptyTask, } from '../tasks/task';\nimport { GitExecutorResult, Maybe, outputHandler, RunnableTask, SimpleGitExecutor, SimpleGitTask } from '../types';\nimport { callTaskParser, first, GitOutputStreams, objectToString } from '../utils';\nimport { Scheduler } from './scheduler';\nimport { TasksPendingQueue } from './tasks-pending-queue';\n\nexport class GitExecutorChain implements SimpleGitExecutor {\n\n   private _chain: Promise<any> = Promise.resolve();\n   private _queue = new TasksPendingQueue();\n   private _cwd: string | undefined;\n\n   public get binary() {\n      return this._executor.binary;\n   }\n\n   public get cwd() {\n      return this._cwd || this._executor.cwd;\n   }\n\n   public set cwd(cwd: string) {\n      this._cwd = cwd;\n   }\n\n   public get env() {\n      return this._executor.env;\n   }\n\n   public get outputHandler() {\n      return this._executor.outputHandler;\n   }\n\n   constructor(\n      private _executor: SimpleGitExecutor,\n      private _scheduler: Scheduler,\n      private _plugins: PluginStore\n   ) {\n   }\n\n   public chain() {\n      return this;\n   }\n\n   public push<R>(task: SimpleGitTask<R>): Promise<R> {\n      this._queue.push(task);\n\n      return this._chain = this._chain.then(() => this.attemptTask(task));\n   }\n\n   private async attemptTask<R>(task: SimpleGitTask<R>): Promise<void | R> {\n      const onScheduleComplete = await this._scheduler.next();\n      const onQueueComplete = () => this._queue.complete(task);\n\n      try {\n         const {logger} = this._queue.attempt(task);\n         return await (isEmptyTask(task)\n               ? this.attemptEmptyTask(task, logger)\n               : this.attemptRemoteTask(task, logger)\n         ) as R;\n      } catch (e) {\n         throw this.onFatalException(task, e);\n      } finally {\n         onQueueComplete();\n         onScheduleComplete();\n      }\n   }\n\n   private onFatalException<R>(task: SimpleGitTask<R>, e: Error) {\n      const gitError = (e instanceof GitError) ? Object.assign(e, {task}) : new GitError(task, e && String(e));\n\n      this._chain = Promise.resolve();\n      this._queue.fatal(gitError);\n\n      return gitError;\n   }\n\n   private async attemptRemoteTask<R>(task: RunnableTask<R>, logger: OutputLogger) {\n      const args = this._plugins.exec('spawn.args', [...task.commands], pluginContext(task, task.commands));\n\n      const raw = await this.gitResponse(\n         task,\n         this.binary, args, this.outputHandler, logger.step('SPAWN'),\n      );\n      const outputStreams = await this.handleTaskData(task, args, raw, logger.step('HANDLE'));\n\n      logger(`passing response to task's parser as a %s`, task.format);\n\n      if (isBufferTask(task)) {\n         return callTaskParser(task.parser, outputStreams);\n      }\n\n      return callTaskParser(task.parser, outputStreams.asStrings());\n   }\n\n   private async attemptEmptyTask(task: EmptyTask, logger: OutputLogger) {\n      logger(`empty task bypassing child process to call to task's parser`);\n      return task.parser(this);\n   }\n\n   private handleTaskData<R>(\n      task: SimpleGitTask<R>,\n      args: string[],\n      result: GitExecutorResult, logger: OutputLogger): Promise<GitOutputStreams> {\n\n      const {exitCode, rejection, stdOut, stdErr} = result;\n\n      return new Promise((done, fail) => {\n         logger(`Preparing to handle process response exitCode=%d stdOut=`, exitCode);\n\n         const {error} = this._plugins.exec('task.error', {error: rejection}, {\n            ...pluginContext(task, args),\n            ...result,\n         });\n\n         if (error && task.onError) {\n            logger.info(`exitCode=%s handling with custom error handler`);\n\n            return task.onError(\n               result,\n               error,\n               (newStdOut) => {\n                  logger.info(`custom error handler treated as success`);\n                  logger(`custom error returned a %s`, objectToString(newStdOut));\n\n                  done(new GitOutputStreams(\n                     Array.isArray(newStdOut) ? Buffer.concat(newStdOut) : newStdOut,\n                     Buffer.concat(stdErr),\n                  ));\n               },\n               fail\n            );\n         }\n\n         if (error) {\n            logger.info(`handling as error: exitCode=%s stdErr=%s rejection=%o`, exitCode, stdErr.length, rejection);\n            return fail(error);\n         }\n\n         logger.info(`retrieving task output complete`);\n         done(new GitOutputStreams(\n            Buffer.concat(stdOut),\n            Buffer.concat(stdErr),\n         ));\n      });\n   }\n\n   private async gitResponse<R>(task: SimpleGitTask<R>, command: string, args: string[], outputHandler: Maybe<outputHandler>, logger: OutputLogger): Promise<GitExecutorResult> {\n      const outputLogger = logger.sibling('output');\n      const spawnOptions: SpawnOptions = this._plugins.exec('spawn.options', {\n         cwd: this.cwd,\n         env: this.env,\n         windowsHide: true,\n      }, pluginContext(task, task.commands));\n\n      return new Promise((done) => {\n         const stdOut: Buffer[] = [];\n         const stdErr: Buffer[] = [];\n\n         let rejection: Maybe<Error>;\n\n         logger.info(`%s %o`, command, args);\n         logger('%O', spawnOptions)\n         const spawned = spawn(command, args, spawnOptions);\n\n         spawned.stdout!.on('data', onDataReceived(stdOut, 'stdOut', logger, outputLogger.step('stdOut')));\n         spawned.stderr!.on('data', onDataReceived(stdErr, 'stdErr', logger, outputLogger.step('stdErr')));\n\n         spawned.on('error', onErrorReceived(stdErr, logger));\n\n         if (outputHandler) {\n            logger(`Passing child process stdOut/stdErr to custom outputHandler`);\n            outputHandler(command, spawned.stdout!, spawned.stderr!, [...args]);\n         }\n\n         this._plugins.exec('spawn.after', undefined, {\n            ...pluginContext(task, args),\n            spawned,\n            close(exitCode: number, reason?: Error) {\n               done({\n                  stdOut,\n                  stdErr,\n                  exitCode,\n                  rejection: rejection || reason,\n               });\n            },\n            kill(reason: Error) {\n               if (spawned.killed) {\n                  return;\n               }\n\n               rejection = reason;\n               spawned.kill('SIGINT');\n            },\n         });\n      });\n   }\n\n}\n\nfunction pluginContext<R>(task: SimpleGitTask<R>, commands: string[]) {\n   return {\n      method: first(task.commands) || '',\n      commands,\n   }\n}\n\nfunction onErrorReceived(target: Buffer[], logger: OutputLogger) {\n   return (err: Error) => {\n      logger(`[ERROR] child process exception %o`, err);\n      target.push(Buffer.from(String(err.stack), 'ascii'));\n   }\n}\n\nfunction onDataReceived(target: Buffer[], name: string, logger: OutputLogger, output: OutputLogger) {\n   return (buffer: Buffer) => {\n      logger(`%s received %L bytes`, name, buffer);\n      output(`%B`, buffer);\n      target.push(buffer)\n   }\n}\n", "import type { PluginStore } from '../plugins';\nimport type { GitExecutorEnv, outputHandler, SimpleGitExecutor, SimpleGitTask } from '../types';\n\nimport { GitExecutorChain } from './git-executor-chain';\nimport { Scheduler } from './scheduler';\n\nexport class GitExecutor implements SimpleGitExecutor {\n\n   private _chain = new GitExecutorChain(this, this._scheduler, this._plugins);\n\n   public env: GitExecutorEnv;\n   public outputHandler?: outputHandler;\n\n   constructor(\n      public binary: string = 'git',\n      public cwd: string,\n      private _scheduler: Scheduler,\n      private _plugins: PluginStore,\n   ) {\n   }\n\n   chain(): SimpleGitExecutor {\n      return new GitExecutorChain(this, this._scheduler, this._plugins);\n   }\n\n   push<R>(task: SimpleGitTask<R>): Promise<R> {\n      return this._chain.push(task);\n   }\n\n}\n\n\n", "import { GitError } from './errors/git-error';\nimport { GitResponseError } from './errors/git-response-error';\nimport { SimpleGitTask, SimpleGitTaskCallback } from './types';\nimport { NOOP } from './utils';\n\nexport function taskCallback<R>(task: SimpleGitTask<R>, response: Promise<R>, callback: SimpleGitTaskCallback<R> = NOOP) {\n\n   const onSuccess = (data: R) => {\n      callback(null, data);\n   };\n\n   const onError = (err: GitError | GitResponseError) => {\n      if (err?.task === task) {\n         callback((err instanceof GitResponseError) ? addDeprecationNoticeToError(err) : err, undefined as any);\n      }\n   };\n\n   response.then(onSuccess, onError);\n\n}\n\nfunction addDeprecationNoticeToError (err: GitResponseError) {\n   let log = (name: string) => {\n      console.warn(`simple-git deprecation notice: accessing GitResponseError.${name} should be GitResponseError.git.${name}, this will no longer be available in version 3`);\n      log = NOOP;\n   };\n\n   return Object.create(err, Object.getOwnPropertyNames(err.git).reduce(descriptorReducer, {}));\n\n   function descriptorReducer(all: PropertyDescriptorMap, name: string): typeof all {\n      if (name in err) {\n         return all;\n      }\n\n      all[name] = {\n         enumerable: false,\n         configurable: false,\n         get () {\n            log(name);\n            return err.git[name];\n         },\n      };\n\n      return all;\n   }\n}\n", "import { folderExists } from '../utils';\nimport { SimpleGitExecutor } from '../types';\nimport { adhocExecTask } from './task';\n\nexport function changeWorkingDirectoryTask (directory: string, root?: SimpleGitExecutor) {\n   return adhocExecTask((instance: SimpleGitExecutor) => {\n      if (!folderExists(directory)) {\n         throw new Error(`Git.cwd: cannot change to non-directory \"${ directory }\"`);\n      }\n\n      return ((root || instance).cwd = directory);\n   });\n}\n", "import { CommitResult } from '../../../typings';\nimport { LineParser, parseStringResponse } from '../utils';\n\nconst parsers: LineParser<CommitResult>[] = [\n   new LineParser(/^\\[([^\\s]+)( \\([^)]+\\))? ([^\\]]+)/, (result, [branch, root, commit]) => {\n      result.branch = branch;\n      result.commit = commit;\n      result.root = !!root;\n   }),\n   new LineParser(/\\s*Author:\\s(.+)/i, (result, [author]) => {\n      const parts = author.split('<');\n      const email = parts.pop();\n\n      if (!email || !email.includes('@')) {\n         return;\n      }\n\n      result.author = {\n         email: email.substr(0, email.length - 1),\n         name: parts.join('<').trim()\n      };\n   }),\n   new LineParser(/(\\d+)[^,]*(?:,\\s*(\\d+)[^,]*)(?:,\\s*(\\d+))/g, (result, [changes, insertions, deletions]) => {\n      result.summary.changes = parseInt(changes, 10) || 0;\n      result.summary.insertions = parseInt(insertions, 10) || 0;\n      result.summary.deletions = parseInt(deletions, 10) || 0;\n   }),\n   new LineParser(/^(\\d+)[^,]*(?:,\\s*(\\d+)[^(]+\\(([+-]))?/, (result, [changes, lines, direction]) => {\n      result.summary.changes = parseInt(changes, 10) || 0;\n      const count = parseInt(lines, 10) || 0;\n      if (direction === '-') {\n         result.summary.deletions = count;\n      } else if (direction === '+') {\n         result.summary.insertions = count;\n      }\n   }),\n];\n\nexport function parseCommitResult(stdOut: string): CommitResult {\n   const result: CommitResult = {\n      author: null,\n      branch: '',\n      commit: '',\n      root: false,\n      summary: {\n         changes: 0,\n         insertions: 0,\n         deletions: 0,\n      },\n   };\n   return parseStringResponse(result, parsers, stdOut);\n}\n", "import type { CommitResult, SimpleGit } from '../../../typings';\nimport type { SimpleGitApi } from '../simple-git-api';\nimport type { StringTask } from '../types';\nimport { parseCommitResult } from '../parsers/parse-commit';\nimport {\n   asArray,\n   filterArray,\n   filterStringOrStringArray,\n   filterType,\n   getTrailingOptions, prefixedArray,\n   trailingFunctionArgument\n} from '../utils';\nimport { configurationErrorTask } from './task';\n\nexport function commitTask(message: string[], files: string[], customArgs: string[]): StringTask<CommitResult> {\n   const commands: string[] = [\n      '-c',\n      'core.abbrev=40',\n      'commit',\n      ...prefixedArray(message, '-m'),\n      ...files,\n      ...customArgs,\n   ];\n\n   return {\n      commands,\n      format: 'utf-8',\n      parser: parseCommitResult,\n   };\n}\n\nexport default function (): Pick<SimpleGit, 'commit'> {\n   return {\n      commit(this: SimpleGitApi, message: string | string[], ...rest: unknown[]) {\n         const next = trailingFunctionArgument(arguments);\n         const task = rejectDeprecatedSignatures(message) ||\n            commitTask(\n               asArray(message),\n               asArray(filterType(rest[0], filterStringOrStringArray, [])),\n               [...filterType(rest[1], filterArray, []), ...getTrailingOptions(arguments, 0, true)]\n            );\n\n         return this._runTask(task, next);\n      },\n   };\n\n   function rejectDeprecatedSignatures(message?: unknown) {\n      return (\n         !filterStringOrStringArray(message) &&\n         configurationErrorTask(`git.commit: requires the commit message to be supplied as a string/string[]`)\n      );\n   }\n}\n", "import { straightThroughStringTask } from './task';\nimport { StringTask } from '../types';\n\n/**\n * Task used by `git.hashObject`\n */\nexport function hashObjectTask(filePath: string, write: boolean): StringTask<string> {\n   const commands = ['hash-object', filePath];\n   if (write) {\n      commands.push('-w');\n   }\n\n   return straightThroughStringTask(commands, true);\n}\n", "import { InitResult } from '../../../typings';\n\nexport class InitSummary implements InitResult {\n   constructor(\n      public readonly bare: boolean,\n      public readonly path: string,\n      public readonly existing: boolean,\n      public readonly gitDir: string,\n   ) {}\n}\n\nconst initResponseRegex = /^Init.+ repository in (.+)$/;\nconst reInitResponseRegex = /^Rein.+ in (.+)$/;\n\nexport function parseInit(bare: boolean, path: string, text: string) {\n   const response = String(text).trim();\n   let result;\n\n   if ((result = initResponseRegex.exec(response))) {\n      return new InitSummary(bare, path, false, result[1]);\n   }\n\n   if ((result = reInitResponseRegex.exec(response))) {\n      return new InitSummary(bare, path, true, result[1]);\n   }\n\n   let gitDir = '';\n   const tokens = response.split(' ');\n   while (tokens.length) {\n      const token = tokens.shift();\n      if (token === 'in') {\n         gitDir = tokens.join(' ');\n         break;\n      }\n   }\n\n   return new InitSummary(bare, path, /^re/i.test(response), gitDir);\n}\n", "import { InitResult } from '../../../typings';\nimport { parseInit } from '../responses/InitSummary';\nimport { StringTask } from '../types';\n\nconst bareCommand = '--bare';\n\nfunction hasBareCommand(command: string[]) {\n   return command.includes(bareCommand);\n}\n\nexport function initTask(bare = false, path: string, customArgs: string[]): StringTask<InitResult> {\n   const commands = ['init', ...customArgs];\n   if (bare && !hasBareCommand(commands)) {\n      commands.splice(1, 0, bareCommand);\n   }\n\n   return {\n      commands,\n      format: 'utf-8',\n      parser(text: string): InitResult {\n         return parseInit(commands.includes('--bare'), path, text);\n      }\n   }\n}\n", "import { DiffResult, DiffResultBinaryFile, DiffResultTextFile } from '../../../typings';\n\n/***\n * The DiffSummary is returned as a response to getting `git().status()`\n */\nexport class DiffSummary implements DiffResult {\n   changed = 0\n   deletions = 0;\n   insertions = 0;\n\n   files: Array<DiffResultTextFile | DiffResultBinaryFile> = [];\n}\n", "import { DiffResult } from '../../../typings';\nimport { DiffSummary } from '../responses/DiffSummary';\n\nexport function parseDiffResult(stdOut: string): DiffResult {\n   const lines = stdOut.trim().split('\\n');\n   const status = new DiffSummary();\n   readSummaryLine(status, lines.pop());\n\n   for (let i = 0, max = lines.length; i < max; i++) {\n      const line = lines[i];\n      textFileChange(line, status) || binaryFileChange(line, status);\n   }\n\n   return status;\n}\n\nfunction readSummaryLine(status: DiffResult, summary?: string) {\n   (summary || '')\n      .trim()\n      .split(', ')\n      .forEach(function (text: string) {\n         const summary = /(\\d+)\\s([a-z]+)/.exec(text);\n         if (!summary) {\n            return;\n         }\n\n         summaryType(status, summary[2], parseInt(summary[1], 10));\n      });\n}\n\nfunction summaryType (status: DiffResult, key: string, value: number) {\n   const match = (/([a-z]+?)s?\\b/.exec(key));\n   if (!match || !statusUpdate[match[1]]) {\n      return;\n   }\n\n   statusUpdate[match[1]](status, value);\n}\n\nconst statusUpdate: {[key: string]: (status: DiffResult, value: number) => void} = {\n   file (status, value) {\n      status.changed = value;\n   },\n   deletion (status, value) {\n      status.deletions = value;\n   },\n   insertion (status, value) {\n      status.insertions = value;\n   }\n}\n\nfunction textFileChange(input: string, {files}: DiffResult) {\n   const line = input.trim().match(/^(.+)\\s+\\|\\s+(\\d+)(\\s+[+\\-]+)?$/);\n\n   if (line) {\n      var alterations = (line[3] || '').trim();\n      files.push({\n         file: line[1].trim(),\n         changes: parseInt(line[2], 10),\n         insertions: alterations.replace(/-/g, '').length,\n         deletions: alterations.replace(/\\+/g, '').length,\n         binary: false\n      });\n\n      return true;\n   }\n\n   return false\n}\n\nfunction binaryFileChange(input: string, {files}: DiffResult) {\n   const line = input.match(/^(.+) \\|\\s+Bin ([0-9.]+) -> ([0-9.]+) ([a-z]+)$/);\n   if (line) {\n      files.push({\n         file: line[1].trim(),\n         before: +line[2],\n         after: +line[3],\n         binary: true\n      });\n      return true;\n   }\n   return false;\n}\n", "import { ListLogLine, LogResult } from '../../../typings';\nimport { toLinesWithContent } from '../utils';\nimport { parseDiffResult } from './parse-diff-summary';\n\nexport const START_BOUNDARY = '\u00F2\u00F2\u00F2\u00F2\u00F2\u00F2 ';\n\nexport const COMMIT_BOUNDARY = ' \u00F2\u00F2';\n\nexport const SPLITTER = ' \u00F2 ';\n\nconst defaultFieldNames = ['hash', 'date', 'message', 'refs', 'author_name', 'author_email'];\n\nfunction lineBuilder(tokens: string[], fields: string[]): any {\n   return fields.reduce((line, field, index) => {\n      line[field] = tokens[index] || '';\n      return line;\n   }, Object.create({diff: null}) as any);\n}\n\nexport function createListLogSummaryParser<T = any> (splitter = SPLITTER, fields = defaultFieldNames) {\n   return function (stdOut: string): LogResult<T> {\n      const all: ReadonlyArray<T & ListLogLine> = toLinesWithContent(stdOut, true, START_BOUNDARY)\n         .map(function (item) {\n            const lineDetail = item.trim().split(COMMIT_BOUNDARY);\n            const listLogLine: T & ListLogLine = lineBuilder(lineDetail[0].trim().split(splitter), fields);\n\n            if (lineDetail.length > 1 && !!lineDetail[1].trim()) {\n               listLogLine.diff = parseDiffResult(lineDetail[1]);\n            }\n\n            return listLogLine;\n         });\n\n      return {\n         all,\n         latest: all.length && all[0] || null,\n         total: all.length,\n      };\n   }\n}\n", "import { Options, StringTask } from '../types';\nimport { LogResult, SimpleGit } from '../../../typings';\nimport {\n   COMMIT_BOUNDARY,\n   createListLogSummaryParser,\n   SPLITTER,\n   START_BOUNDARY\n} from '../parsers/parse-list-log-summary';\nimport {\n   appendTaskOptions,\n   filterArray,\n   filterPrimitives,\n   filterString,\n   filterType,\n   trailingFunctionArgument,\n   trailingOptionsArgument\n} from '../utils';\nimport { SimpleGitApi } from '../simple-git-api';\nimport { configurationErrorTask } from './task';\n\nenum excludeOptions {\n   '--pretty',\n   'max-count',\n   'maxCount',\n   'n',\n   'file',\n   'format',\n   'from',\n   'to',\n   'splitter',\n   'symmetric',\n   'mailMap',\n   'multiLine',\n   'strictDate',\n}\n\nexport interface DefaultLogFields {\n   hash: string;\n   date: string;\n   message: string;\n   refs: string;\n   body: string;\n   author_name: string;\n   author_email: string;\n}\n\nexport type LogOptions<T = DefaultLogFields> = {\n   file?: string;\n   format?: T;\n   from?: string;\n   mailMap?: boolean;\n   maxCount?: number;\n   multiLine?: boolean;\n   splitter?: string;\n   strictDate?: boolean;\n   symmetric?: boolean;\n   to?: string;\n};\n\ninterface ParsedLogOptions {\n   fields: string[];\n   splitter: string;\n   commands: string[]\n}\n\nfunction prettyFormat(format: Record<string, string | unknown>, splitter: string): [string[], string] {\n   const fields: string[] = [];\n   const formatStr: string[] = [];\n\n   Object.keys(format).forEach((field) => {\n      fields.push(field);\n      formatStr.push(String(format[field]));\n   });\n\n   return [\n      fields, formatStr.join(splitter)\n   ];\n}\n\nfunction userOptions<T extends Options>(input: T): Options {\n   return Object.keys(input).reduce((out, key) => {\n      if (!(key in excludeOptions)) {\n         out[key] = input[key];\n      }\n      return out;\n   }, {} as Options);\n}\n\nexport function parseLogOptions<T extends Options>(opt: Options | LogOptions<T> = {}, customArgs: string[] = []): ParsedLogOptions {\n   const splitter = filterType(opt.splitter, filterString, SPLITTER);\n   const format = !filterPrimitives(opt.format) && opt.format ? opt.format : {\n      hash: '%H',\n      date: opt.strictDate === false ? '%ai' : '%aI',\n      message: '%s',\n      refs: '%D',\n      body: opt.multiLine ? '%B' : '%b',\n      author_name: opt.mailMap !== false ? '%aN' : '%an',\n      author_email: opt.mailMap !== false ? '%aE' : '%ae'\n   };\n\n   const [fields, formatStr] = prettyFormat(format, splitter);\n\n   const suffix: string[] = [];\n   const command: string[] = [\n      `--pretty=format:${START_BOUNDARY}${formatStr}${COMMIT_BOUNDARY}`,\n      ...customArgs,\n   ];\n\n   const maxCount: number | undefined = (opt as any).n || (opt as any)['max-count'] || opt.maxCount;\n   if (maxCount) {\n      command.push(`--max-count=${maxCount}`);\n   }\n\n   if (opt.from && opt.to) {\n      const rangeOperator = (opt.symmetric !== false) ? '...' : '..';\n      suffix.push(`${opt.from}${rangeOperator}${opt.to}`);\n   }\n\n   if (filterString(opt.file)) {\n      suffix.push('--follow', opt.file);\n   }\n\n   appendTaskOptions(userOptions(opt as Options), command);\n\n   return {\n      fields,\n      splitter,\n      commands: [\n         ...command,\n         ...suffix,\n      ],\n   };\n}\n\nexport function logTask<T>(splitter: string, fields: string[], customArgs: string[]): StringTask<LogResult<T>> {\n   return {\n      commands: ['log', ...customArgs],\n      format: 'utf-8',\n      parser: createListLogSummaryParser(splitter, fields),\n   };\n}\n\nexport default function (): Pick<SimpleGit, 'log'> {\n   return {\n      log<T extends Options>(this: SimpleGitApi, ...rest: unknown[]) {\n         const next = trailingFunctionArgument(arguments);\n         const task = rejectDeprecatedSignatures(...rest) ||\n            createLogTask(parseLogOptions<T>(trailingOptionsArgument(arguments), filterType(arguments[0], filterArray)))\n\n         return this._runTask(task, next);\n      }\n   }\n\n   function createLogTask(options: ParsedLogOptions) {\n      return logTask(options.splitter, options.fields, options.commands);\n   }\n\n   function rejectDeprecatedSignatures(from?: unknown, to?: unknown) {\n      return (\n         filterString(from) &&\n         filterString(to) &&\n         configurationErrorTask(`git.log(string, string) should be replaced with git.log({ from: string, to: string })`)\n      );\n   }\n}\n", "import { MergeConflict, MergeConflictDeletion, MergeDetail, MergeResultStatus } from '../../../typings';\n\nexport class MergeSummaryConflict implements MergeConflict {\n   constructor(\n      public readonly reason: string,\n      public readonly file: string | null = null,\n      public readonly meta?: MergeConflictDeletion,\n   ) {\n   }\n\n   toString() {\n      return `${this.file}:${this.reason}`;\n   }\n}\n\nexport class MergeSummaryDetail implements MergeDetail {\n   public conflicts: MergeConflict[] = [];\n   public merges: string[] = [];\n   public result: MergeResultStatus = 'success';\n\n   get failed() {\n      return this.conflicts.length > 0;\n   }\n\n   get reason() {\n      return this.result;\n   }\n\n   toString() {\n      if (this.conflicts.length) {\n         return `CONFLICTS: ${this.conflicts.join(', ')}`;\n      }\n\n      return 'OK';\n   }\n}\n\n", "import { PullDetailFileChanges, PullDetailSummary, PullFailedResult, PullResult } from '../../../typings';\n\nexport class PullSummary implements PullResult {\n   public remoteMessages = {\n      all: [],\n   };\n   public created = [];\n   public deleted: string[] = [];\n   public files: string[] = [];\n   public deletions: PullDetailFileChanges = {};\n   public insertions: PullDetailFileChanges = {};\n   public summary: PullDetailSummary = {\n      changes: 0,\n      deletions: 0,\n      insertions: 0,\n   };\n}\n\nexport class PullFailedSummary implements PullFailedResult {\n   remote = '';\n   hash = {\n      local: '',\n      remote: '',\n   };\n   branch = {\n      local: '',\n      remote: '',\n   };\n   message = '';\n\n   toString() {\n      return this.message;\n   }\n}\n\n", "import { RemoteMessageResult, RemoteMessages, RemoteMessagesObjectEnumeration } from '../../../typings';\nimport { asNumber, RemoteLineParser } from '../utils';\n\nfunction objectEnumerationResult<T extends RemoteMessages = RemoteMessages>(remoteMessages: T): RemoteMessagesObjectEnumeration {\n   return (remoteMessages.objects = remoteMessages.objects || {\n      compressing: 0,\n      counting: 0,\n      enumerating: 0,\n      packReused: 0,\n      reused: {count: 0, delta: 0},\n      total: {count: 0, delta: 0}\n   });\n}\n\nfunction asObjectCount(source: string) {\n   const count = /^\\s*(\\d+)/.exec(source);\n   const delta = /delta (\\d+)/i.exec(source);\n\n   return {\n      count: asNumber(count && count[1] || '0'),\n      delta: asNumber(delta && delta[1] || '0'),\n   };\n}\n\nexport const remoteMessagesObjectParsers: RemoteLineParser<RemoteMessageResult<RemoteMessages>>[] = [\n   new RemoteLineParser(/^remote:\\s*(enumerating|counting|compressing) objects: (\\d+),/i, (result, [action, count]) => {\n      const key = action.toLowerCase();\n      const enumeration = objectEnumerationResult(result.remoteMessages);\n\n      Object.assign(enumeration, {[key]: asNumber(count)});\n   }),\n   new RemoteLineParser(/^remote:\\s*(enumerating|counting|compressing) objects: \\d+% \\(\\d+\\/(\\d+)\\),/i, (result, [action, count]) => {\n      const key = action.toLowerCase();\n      const enumeration = objectEnumerationResult(result.remoteMessages);\n\n      Object.assign(enumeration, {[key]: asNumber(count)});\n   }),\n   new RemoteLineParser(/total ([^,]+), reused ([^,]+), pack-reused (\\d+)/i, (result, [total, reused, packReused]) => {\n      const objects = objectEnumerationResult(result.remoteMessages);\n      objects.total = asObjectCount(total);\n      objects.reused = asObjectCount(reused);\n      objects.packReused = asNumber(packReused);\n   }),\n];\n", "import { PushResultRemoteMessages, RemoteMessageResult, RemoteMessages } from '../../../typings';\nimport { asNumber, parseStringResponse, RemoteLineParser } from '../utils';\nimport { remoteMessagesObjectParsers } from './parse-remote-objects';\n\nconst parsers: RemoteLineParser<RemoteMessageResult<PushResultRemoteMessages | RemoteMessages>>[] = [\n   new RemoteLineParser(/^remote:\\s*(.+)$/, (result, [text]) => {\n      result.remoteMessages.all.push(text.trim());\n      return false;\n   }),\n   ...remoteMessagesObjectParsers,\n   new RemoteLineParser([/create a (?:pull|merge) request/i, /\\s(https?:\\/\\/\\S+)$/], (result, [pullRequestUrl]) => {\n      (result.remoteMessages as PushResultRemoteMessages).pullRequestUrl = pullRequestUrl;\n   }),\n   new RemoteLineParser([/found (\\d+) vulnerabilities.+\\(([^)]+)\\)/i, /\\s(https?:\\/\\/\\S+)$/], (result, [count, summary, url]) => {\n      (result.remoteMessages as PushResultRemoteMessages).vulnerabilities = {\n         count: asNumber(count),\n         summary,\n         url,\n      };\n   }),\n];\n\nexport function parseRemoteMessages<T extends RemoteMessages = RemoteMessages>(\n   _stdOut: string, stdErr: string,\n): RemoteMessageResult {\n   return parseStringResponse({remoteMessages: new RemoteMessageSummary() as T}, parsers, stdErr);\n}\n\nexport class RemoteMessageSummary implements RemoteMessages {\n   public readonly all: string[] = [];\n}\n", "import { PullDetail, PullFailedResult, PullResult, RemoteMessages } from '../../../typings';\nimport { PullFailedSummary, PullSummary } from '../responses/PullSummary';\nimport { TaskParser } from '../types';\nimport { append, LineParser, parseStringResponse } from '../utils';\nimport { parseRemoteMessages } from './parse-remote-messages';\n\nconst FILE_UPDATE_REGEX = /^\\s*(.+?)\\s+\\|\\s+\\d+\\s*(\\+*)(-*)/;\nconst SUMMARY_REGEX = /(\\d+)\\D+((\\d+)\\D+\\(\\+\\))?(\\D+(\\d+)\\D+\\(-\\))?/;\nconst ACTION_REGEX = /^(create|delete) mode \\d+ (.+)/;\n\nconst parsers: LineParser<PullResult>[] = [\n   new LineParser(FILE_UPDATE_REGEX, (result, [file, insertions, deletions]) => {\n      result.files.push(file);\n\n      if (insertions) {\n         result.insertions[file] = insertions.length;\n      }\n\n      if (deletions) {\n         result.deletions[file] = deletions.length;\n      }\n   }),\n   new LineParser(SUMMARY_REGEX, (result, [changes, , insertions, , deletions]) => {\n      if (insertions !== undefined || deletions !== undefined) {\n         result.summary.changes = +changes || 0;\n         result.summary.insertions = +insertions || 0;\n         result.summary.deletions = +deletions || 0;\n         return true;\n      }\n      return false;\n   }),\n   new LineParser(ACTION_REGEX, (result, [action, file]) => {\n      append(result.files, file);\n      append((action === 'create') ? result.created : result.deleted, file);\n   }),\n];\n\nconst errorParsers: LineParser<PullFailedResult>[] = [\n   new LineParser(/^from\\s(.+)$/i, (result, [remote]) => void (result.remote = remote)),\n   new LineParser(/^fatal:\\s(.+)$/, (result, [message]) => void (result.message = message)),\n   new LineParser(/([a-z0-9]+)\\.\\.([a-z0-9]+)\\s+(\\S+)\\s+->\\s+(\\S+)$/, (result, [hashLocal, hashRemote, branchLocal, branchRemote]) => {\n      result.branch.local = branchLocal;\n      result.hash.local = hashLocal;\n      result.branch.remote = branchRemote;\n      result.hash.remote = hashRemote;\n   }),\n];\n\nexport const parsePullDetail: TaskParser<string, PullDetail> = (stdOut, stdErr) => {\n   return parseStringResponse(new PullSummary(), parsers, stdOut, stdErr);\n}\n\nexport const parsePullResult: TaskParser<string, PullResult> = (stdOut, stdErr) => {\n   return Object.assign(\n      new PullSummary(),\n      parsePullDetail(stdOut, stdErr),\n      parseRemoteMessages<RemoteMessages>(stdOut, stdErr),\n   );\n}\n\nexport function parsePullErrorResult(stdOut: string, stdErr: string) {\n   const pullError = parseStringResponse(new PullFailedSummary(), errorParsers, stdOut, stdErr);\n\n   return pullError.message && pullError;\n}\n", "import { MergeDetail, MergeResult } from '../../../typings';\nimport { MergeSummaryConflict, MergeSummaryDetail } from '../responses/MergeSummary';\nimport { TaskParser } from '../types';\nimport { LineParser, parseStringResponse } from '../utils';\nimport { parsePullResult } from './parse-pull';\n\nconst parsers: LineParser<MergeDetail>[] = [\n   new LineParser(/^Auto-merging\\s+(.+)$/, (summary, [autoMerge]) => {\n      summary.merges.push(autoMerge);\n   }),\n   new LineParser(/^CONFLICT\\s+\\((.+)\\): Merge conflict in (.+)$/, (summary, [reason, file]) => {\n      summary.conflicts.push(new MergeSummaryConflict(reason, file));\n   }),\n   new LineParser(/^CONFLICT\\s+\\((.+\\/delete)\\): (.+) deleted in (.+) and/, (summary, [reason, file, deleteRef]) => {\n      summary.conflicts.push(new MergeSummaryConflict(reason, file, {deleteRef}));\n   }),\n   new LineParser(/^CONFLICT\\s+\\((.+)\\):/, (summary, [reason]) => {\n      summary.conflicts.push(new MergeSummaryConflict(reason, null));\n   }),\n   new LineParser(/^Automatic merge failed;\\s+(.+)$/, (summary, [result]) => {\n      summary.result = result;\n   }),\n];\n\n/**\n * Parse the complete response from `git.merge`\n */\nexport const parseMergeResult: TaskParser<string, MergeResult> = (stdOut, stdErr) => {\n   return Object.assign(\n      parseMergeDetail(stdOut, stdErr),\n      parsePullResult(stdOut, stdErr),\n   );\n};\n\n/**\n * Parse the merge specific detail (ie: not the content also available in the pull detail) from `git.mnerge`\n * @param stdOut\n */\nexport const parseMergeDetail: TaskParser<string, MergeDetail> = (stdOut) => {\n   return parseStringResponse(new MergeSummaryDetail(), parsers, stdOut);\n}\n", "import { MergeResult } from '../../../typings';\nimport { GitResponseError } from '../errors/git-response-error';\nimport { parseMergeResult } from '../parsers/parse-merge';\nimport { StringTask } from '../types';\nimport { configurationErrorTask, EmptyTask } from './task';\n\nexport function mergeTask(customArgs: string[]): EmptyTask | StringTask<MergeResult> {\n   if (!customArgs.length) {\n      return configurationErrorTask('Git.merge requires at least one option');\n   }\n\n   return {\n      commands: ['merge', ...customArgs],\n      format: 'utf-8',\n      parser(stdOut, stdErr): MergeResult {\n         const merge = parseMergeResult(stdOut, stdErr);\n         if (merge.failed) {\n            throw new GitResponseError(merge);\n         }\n\n         return merge;\n      }\n   }\n}\n", "import { PushDetail, PushResult, PushResultPushedItem, PushResultRemoteMessages } from '../../../typings';\nimport { TaskParser } from '../types';\nimport { LineParser, parseStringResponse } from '../utils';\nimport { parseRemoteMessages } from './parse-remote-messages';\n\nfunction pushResultPushedItem(local: string, remote: string, status: string): PushResultPushedItem {\n   const deleted = status.includes('deleted');\n   const tag = status.includes('tag') || /^refs\\/tags/.test(local);\n   const alreadyUpdated = !status.includes('new');\n\n   return {\n      deleted,\n      tag,\n      branch: !tag,\n      new: !alreadyUpdated,\n      alreadyUpdated,\n      local,\n      remote,\n   };\n}\n\nconst parsers: LineParser<PushDetail>[] = [\n   new LineParser(/^Pushing to (.+)$/, (result, [repo]) => {\n      result.repo = repo;\n   }),\n   new LineParser(/^updating local tracking ref '(.+)'/, (result, [local]) => {\n      result.ref = {\n         ...(result.ref || {}),\n         local,\n      }\n   }),\n   new LineParser(/^[*-=]\\s+([^:]+):(\\S+)\\s+\\[(.+)]$/, (result, [local, remote, type]) => {\n      result.pushed.push(pushResultPushedItem(local, remote, type));\n   }),\n   new LineParser(/^Branch '([^']+)' set up to track remote branch '([^']+)' from '([^']+)'/, (result, [local, remote, remoteName]) => {\n      result.branch = {\n         ...(result.branch || {}),\n         local,\n         remote,\n         remoteName,\n      };\n   }),\n   new LineParser(/^([^:]+):(\\S+)\\s+([a-z0-9]+)\\.\\.([a-z0-9]+)$/, (result, [local, remote, from, to]) => {\n      result.update = {\n         head: {\n            local,\n            remote,\n         },\n         hash: {\n            from,\n            to,\n         },\n      };\n   }),\n];\n\nexport const parsePushResult: TaskParser<string, PushResult> = (stdOut, stdErr) => {\n   const pushDetail = parsePushDetail(stdOut, stdErr);\n   const responseDetail = parseRemoteMessages<PushResultRemoteMessages>(stdOut, stdErr);\n\n   return {\n      ...pushDetail,\n      ...responseDetail,\n   };\n}\n\nexport const parsePushDetail: TaskParser<string, PushDetail> = (stdOut, stdErr) => {\n   return parseStringResponse({pushed: []}, parsers, stdOut, stdErr);\n}\n", "import { PushResult } from '../../../typings';\nimport { parsePushResult as parser } from '../parsers/parse-push';\nimport { StringTask } from '../types';\nimport { append, remove } from '../utils';\n\ntype PushRef = { remote?: string, branch?: string };\n\nexport function pushTagsTask(ref: PushRef = {}, customArgs: string[]): StringTask<PushResult> {\n   append(customArgs, '--tags');\n   return pushTask(ref, customArgs);\n}\n\nexport function pushTask(ref: PushRef = {}, customArgs: string[]): StringTask<PushResult> {\n   const commands = ['push', ...customArgs];\n   if (ref.branch) {\n      commands.splice(1, 0, ref.branch);\n   }\n   if (ref.remote) {\n      commands.splice(1, 0, ref.remote);\n   }\n\n   remove(commands, '-v');\n   append(commands, '--verbose');\n   append(commands, '--porcelain');\n\n   return {\n      commands,\n      format: 'utf-8',\n      parser,\n   };\n}\n", "import { FileStatusResult } from '../../../typings';\n\nexport const fromPathRegex = /^(.+) -> (.+)$/;\n\nexport class FileStatusSummary implements FileStatusResult {\n\n   public readonly from: string | undefined;\n\n   constructor (\n      public path: string,\n      public index: string,\n      public working_dir: string) {\n\n      if ('R' === (index + working_dir)) {\n         const detail = fromPathRegex.exec(path) || [null, path, path];\n         this.from = detail[1] || '';\n         this.path = detail[2] || '';\n      }\n   }\n}\n", "import { StatusResult } from '../../../typings';\nimport { append, NULL } from '../utils';\nimport { FileStatusSummary } from './FileStatusSummary';\n\ntype StatusLineParser = (result: StatusResult, file: string) => void;\n\nexport class StatusSummary implements StatusResult {\n   public not_added = [];\n   public conflicted = [];\n   public created = [];\n   public deleted = [];\n   public ignored = undefined;\n   public modified = [];\n   public renamed = [];\n   public files = [];\n   public staged = [];\n   public ahead = 0;\n   public behind = 0;\n   public current = null;\n   public tracking = null;\n   public detached = false;\n\n   public isClean = () => {\n      return !this.files.length;\n   }\n}\n\nenum PorcelainFileStatus {\n   ADDED = 'A',\n   DELETED = 'D',\n   MODIFIED = 'M',\n   RENAMED = 'R',\n   COPIED = 'C',\n   UNMERGED = 'U',\n   UNTRACKED = '?',\n   IGNORED = '!',\n   NONE = ' ',\n}\n\nfunction renamedFile(line: string) {\n   const [to, from] = line.split(NULL);\n\n   return {\n      from: from || to,\n      to,\n   };\n}\n\nfunction parser(indexX: PorcelainFileStatus, indexY: PorcelainFileStatus, handler: StatusLineParser): [string, StatusLineParser] {\n   return [`${indexX}${indexY}`, handler];\n}\n\nfunction conflicts(indexX: PorcelainFileStatus, ...indexY: PorcelainFileStatus[]) {\n   return indexY.map(y => parser(indexX, y, (result, file) => append(result.conflicted, file)));\n}\n\nconst parsers: Map<string, StatusLineParser> = new Map([\n   parser(PorcelainFileStatus.NONE, PorcelainFileStatus.ADDED, (result, file) => append(result.created, file)),\n   parser(PorcelainFileStatus.NONE, PorcelainFileStatus.DELETED, (result, file) => append(result.deleted, file)),\n   parser(PorcelainFileStatus.NONE, PorcelainFileStatus.MODIFIED, (result, file) => append(result.modified, file)),\n\n   parser(PorcelainFileStatus.ADDED, PorcelainFileStatus.NONE, (result, file) => append(result.created, file) && append(result.staged, file)),\n   parser(PorcelainFileStatus.ADDED, PorcelainFileStatus.MODIFIED, (result, file) =>\n      append(result.created, file) && append(result.staged, file) && append(result.modified, file)),\n\n   parser(PorcelainFileStatus.DELETED, PorcelainFileStatus.NONE, (result, file) => append(result.deleted, file) && append(result.staged, file)),\n\n   parser(PorcelainFileStatus.MODIFIED, PorcelainFileStatus.NONE, (result, file) => append(result.modified, file) && append(result.staged, file)),\n   parser(PorcelainFileStatus.MODIFIED, PorcelainFileStatus.MODIFIED, (result, file) => append(result.modified, file) && append(result.staged, file)),\n\n   parser(PorcelainFileStatus.RENAMED, PorcelainFileStatus.NONE, (result, file) => {\n      append(result.renamed, renamedFile(file));\n   }),\n   parser(PorcelainFileStatus.RENAMED, PorcelainFileStatus.MODIFIED, (result, file) => {\n      const renamed = renamedFile(file);\n      append(result.renamed, renamed);\n      append(result.modified, renamed.to);\n   }),\n   parser(PorcelainFileStatus.IGNORED, PorcelainFileStatus.IGNORED, (_result, _file) => {\n      append((_result.ignored = _result.ignored || []), _file);\n   }),\n\n   parser(PorcelainFileStatus.UNTRACKED, PorcelainFileStatus.UNTRACKED, (result, file) => append(result.not_added, file)),\n\n   ...conflicts(PorcelainFileStatus.ADDED, PorcelainFileStatus.ADDED, PorcelainFileStatus.UNMERGED),\n   ...conflicts(PorcelainFileStatus.DELETED, PorcelainFileStatus.DELETED, PorcelainFileStatus.UNMERGED),\n   ...conflicts(PorcelainFileStatus.UNMERGED, PorcelainFileStatus.ADDED, PorcelainFileStatus.DELETED, PorcelainFileStatus.UNMERGED),\n\n   ['##', (result, line) => {\n      const aheadReg = /ahead (\\d+)/;\n      const behindReg = /behind (\\d+)/;\n      const currentReg = /^(.+?(?=(?:\\.{3}|\\s|$)))/;\n      const trackingReg = /\\.{3}(\\S*)/;\n      const onEmptyBranchReg = /\\son\\s([\\S]+)$/;\n      let regexResult;\n\n      regexResult = aheadReg.exec(line);\n      result.ahead = regexResult && +regexResult[1] || 0;\n\n      regexResult = behindReg.exec(line);\n      result.behind = regexResult && +regexResult[1] || 0;\n\n      regexResult = currentReg.exec(line);\n      result.current = regexResult && regexResult[1];\n\n      regexResult = trackingReg.exec(line);\n      result.tracking = regexResult && regexResult[1];\n\n      regexResult = onEmptyBranchReg.exec(line);\n      result.current = regexResult && regexResult[1] || result.current;\n\n      result.detached = /\\(no branch\\)/.test(line);\n   }]\n]);\n\nexport const parseStatusSummary = function (text: string): StatusResult {\n   const lines = text.split(NULL);\n   const status = new StatusSummary();\n\n   for (let i = 0, l = lines.length; i < l;) {\n      let line = lines[i++].trim();\n\n      if (!line) {\n         continue;\n      }\n\n      if (line.charAt(0) === PorcelainFileStatus.RENAMED) {\n         line += NULL + (lines[i++] || '');\n      }\n\n      splitLine(status, line);\n   }\n\n   return status;\n};\n\nfunction splitLine(result: StatusResult, lineStr: string) {\n   const trimmed = lineStr.trim();\n   switch (' ') {\n      case trimmed.charAt(2):\n         return data(trimmed.charAt(0), trimmed.charAt(1), trimmed.substr(3));\n      case trimmed.charAt(1):\n         return data(PorcelainFileStatus.NONE, trimmed.charAt(0), trimmed.substr(2));\n      default:\n         return;\n   }\n\n   function data(index: string, workingDir: string, path: string) {\n      const raw = `${index}${workingDir}`;\n      const handler = parsers.get(raw);\n\n      if (handler) {\n         handler(result, path);\n      }\n\n      if (raw !== '##' && raw !== '!!') {\n         result.files.push(new FileStatusSummary(path.replace(/\\0.+$/, ''), index, workingDir));\n      }\n   }\n}\n", "import { StatusResult } from '../../../typings';\nimport { parseStatusSummary } from '../responses/StatusSummary';\nimport { StringTask } from '../types';\n\nconst ignoredOptions = ['--null', '-z'];\n\nexport function statusTask(customArgs: string[]): StringTask<StatusResult> {\n   const commands = [\n      'status',\n      '--porcelain',\n      '-b',\n      '-u',\n      '--null',\n      ...customArgs.filter(arg => !ignoredOptions.includes(arg))\n   ];\n\n   return {\n      format: 'utf-8',\n      commands,\n      parser(text: string) {\n         return parseStatusSummary(text);\n      }\n   }\n}\n", "import { SimpleGitBase } from '../../typings';\nimport { taskCallback } from './task-callback';\nimport { changeWorkingDirectoryTask } from './tasks/change-working-directory';\nimport commit from './tasks/commit';\nimport config from './tasks/config';\nimport grep from './tasks/grep';\nimport { hashObjectTask } from './tasks/hash-object';\nimport { initTask } from './tasks/init';\nimport log from './tasks/log';\nimport { mergeTask } from './tasks/merge';\nimport { pushTask } from './tasks/push';\nimport { statusTask } from './tasks/status';\nimport { configurationErrorTask, straightThroughStringTask } from './tasks/task';\nimport { outputHandler, SimpleGitExecutor, SimpleGitTask, SimpleGitTaskCallback } from './types';\nimport { asArray, filterString, filterType, getTrailingOptions, trailingFunctionArgument } from './utils';\n\nexport class SimpleGitApi implements SimpleGitBase {\n\n   constructor(private _executor: SimpleGitExecutor) {\n   }\n\n   protected _runTask<T>(task: SimpleGitTask<T>, then?: SimpleGitTaskCallback<T>) {\n      const chain = this._executor.chain();\n      const promise = chain.push(task);\n\n      if (then) {\n         taskCallback(task, promise, then);\n      }\n\n      return Object.create(this, {\n         then: {value: promise.then.bind(promise)},\n         catch: {value: promise.catch.bind(promise)},\n         _executor: {value: chain},\n      });\n   }\n\n   add(files: string | string[]) {\n      return this._runTask(\n         straightThroughStringTask(['add', ...asArray(files)]),\n         trailingFunctionArgument(arguments),\n      );\n   }\n\n   cwd(directory: string | { path: string, root?: boolean }) {\n      const next = trailingFunctionArgument(arguments);\n\n      if (typeof directory === 'string') {\n         return this._runTask(changeWorkingDirectoryTask(directory, this._executor), next);\n      }\n\n      if (typeof directory?.path === 'string') {\n         return this._runTask(changeWorkingDirectoryTask(directory.path, directory.root && this._executor || undefined), next);\n      }\n\n      return this._runTask(\n         configurationErrorTask('Git.cwd: workingDirectory must be supplied as a string'),\n         next\n      );\n   }\n\n   hashObject(path: string, write: boolean | unknown) {\n      return this._runTask(\n         hashObjectTask(path, write === true),\n         trailingFunctionArgument(arguments),\n      );\n   }\n\n   init(bare?: boolean | unknown) {\n      return this._runTask(\n         initTask(bare === true, this._executor.cwd, getTrailingOptions(arguments)),\n         trailingFunctionArgument(arguments),\n      );\n   }\n\n   merge() {\n      return this._runTask(\n         mergeTask(getTrailingOptions(arguments)),\n         trailingFunctionArgument(arguments),\n      );\n   }\n\n   mergeFromTo(remote: string, branch: string) {\n      if (!(filterString(remote) && filterString(branch))) {\n         return this._runTask(configurationErrorTask(\n            `Git.mergeFromTo requires that the 'remote' and 'branch' arguments are supplied as strings`\n         ));\n      }\n\n      return this._runTask(\n         mergeTask([remote, branch, ...getTrailingOptions(arguments)]),\n         trailingFunctionArgument(arguments, false),\n      );\n   }\n\n   outputHandler(handler: outputHandler) {\n      this._executor.outputHandler = handler;\n      return this;\n   }\n\n   push() {\n      const task = pushTask(\n         {\n            remote: filterType(arguments[0], filterString),\n            branch: filterType(arguments[1], filterString),\n         },\n         getTrailingOptions(arguments),\n      );\n\n      return this._runTask(\n         task,\n         trailingFunctionArgument(arguments),\n      );\n   }\n\n   stash() {\n      return this._runTask(\n         straightThroughStringTask(['stash', ...getTrailingOptions(arguments)]),\n         trailingFunctionArgument(arguments),\n      );\n   }\n\n   status() {\n      return this._runTask(statusTask(getTrailingOptions(arguments)), trailingFunctionArgument(arguments));\n   }\n}\n\nObject.assign(SimpleGitApi.prototype, commit(), config(), grep(), log());\n", "import { append, remove } from '../utils';\nimport { createDeferred, DeferredPromise } from '@kwsites/promise-deferred';\nimport { createLogger } from '../git-logger';\n\ntype ScheduleCompleteCallback = () => void;\ntype ScheduledTask = Pick<DeferredPromise<ScheduleCompleteCallback>, 'promise' | 'done'> & {id: number};\n\nconst createScheduledTask: () => ScheduledTask = (() => {\n   let id = 0;\n   return () => {\n      id++;\n      const {promise, done} = createDeferred<ScheduleCompleteCallback>();\n\n      return {\n         promise,\n         done,\n         id,\n      };\n   }\n})();\n\nexport class Scheduler {\n   private logger = createLogger('', 'scheduler');\n   private pending: ScheduledTask[] = [];\n   private running: ScheduledTask[] = [];\n\n   constructor(private concurrency = 2) {\n      this.logger(`Constructed, concurrency=%s`, concurrency);\n   }\n\n   private schedule() {\n      if (!this.pending.length || this.running.length >= this.concurrency) {\n         this.logger(`Schedule attempt ignored, pending=%s running=%s concurrency=%s`, this.pending.length, this.running.length, this.concurrency);\n         return;\n      }\n\n      const task = append(this.running, this.pending.shift()!);\n      this.logger(`Attempting id=%s`, task.id);\n      task.done(() => {\n         this.logger(`Completing id=`, task.id);\n         remove(this.running, task);\n         this.schedule();\n      });\n   }\n\n   next(): Promise<ScheduleCompleteCallback> {\n      const {promise, id} = append(this.pending, createScheduledTask());\n      this.logger(`Scheduling id=%s`, id);\n\n      this.schedule();\n\n      return promise;\n   }\n}\n", "import { straightThroughStringTask } from './task';\nimport { OptionFlags, Options, StringTask } from '../types';\n\nexport type ApplyOptions = Options &\n   OptionFlags<\n      | '--stat'\n      | '--numstat'\n      | '--summary'\n      | '--check'\n      | '--index'\n      | '--intent-to-add'\n      | '--3way'\n      | '--apply'\n      | '--no-add'\n      | '-R'\n      | '--reverse'\n      | '--allow-binary-replacement'\n      | '--binary'\n      | '--reject'\n      | '-z'\n      | '--inaccurate-eof'\n      | '--recount'\n      | '--cached'\n      | '--ignore-space-change'\n      | '--ignore-whitespace'\n      | '--verbose'\n      | '--unsafe-paths'> &\n   OptionFlags<\n      '--whitespace',\n      'nowarn' | 'warn' | 'fix' | 'error' | 'error-all'> &\n   OptionFlags<'--build-fake-ancestor' | '--exclude' | '--include' | '--directory',\n      string> &\n   OptionFlags<'-p' | '-C', number>;\n\nexport function applyPatchTask(patches: string[], customArgs: string[]): StringTask<string> {\n   return straightThroughStringTask(['apply', ...customArgs, ...patches]);\n}\n", "import {\n   BranchMultiDeleteResult,\n   BranchSingleDeleteFailure,\n   BranchSingleDeleteResult,\n   BranchSingleDeleteSuccess\n} from '../../../typings';\n\nexport class BranchDeletionBatch implements BranchMultiDeleteResult {\n   all: BranchSingleDeleteResult[] = [];\n   branches: { [branchName: string]: BranchSingleDeleteResult } = {};\n   errors: BranchSingleDeleteResult[] = [];\n\n   get success(): boolean {\n      return !this.errors.length;\n   }\n}\n\nexport function branchDeletionSuccess (branch: string, hash: string): BranchSingleDeleteSuccess {\n   return {\n      branch, hash, success: true,\n   };\n}\n\nexport function branchDeletionFailure (branch: string): BranchSingleDeleteFailure {\n   return {\n      branch, hash: null, success: false,\n   };\n}\n\nexport function isSingleBranchDeleteFailure (test: BranchSingleDeleteResult): test is BranchSingleDeleteSuccess {\n   return test.success;\n}\n", "import { BranchMultiDeleteResult } from '../../../typings';\nimport { BranchDeletionBatch, branchDeletionFailure, branchDeletionSuccess } from '../responses/BranchDeleteSummary';\nimport { TaskParser } from '../types';\nimport { ExitCodes, LineParser, parseStringResponse } from '../utils';\n\nconst deleteSuccessRegex = /(\\S+)\\s+\\(\\S+\\s([^)]+)\\)/;\nconst deleteErrorRegex = /^error[^']+'([^']+)'/m;\n\nconst parsers: LineParser<BranchMultiDeleteResult>[] = [\n   new LineParser(deleteSuccessRegex, (result, [branch, hash]) => {\n      const deletion = branchDeletionSuccess(branch, hash);\n\n      result.all.push(deletion);\n      result.branches[branch] = deletion;\n   }),\n   new LineParser(deleteErrorRegex, (result, [branch]) => {\n      const deletion = branchDeletionFailure(branch);\n\n      result.errors.push(deletion);\n      result.all.push(deletion);\n      result.branches[branch] = deletion;\n   }),\n];\n\nexport const parseBranchDeletions: TaskParser<string, BranchMultiDeleteResult> = (stdOut, stdErr) => {\n   return parseStringResponse(new BranchDeletionBatch(), parsers, stdOut, stdErr);\n}\n\nexport function hasBranchDeletionError(data: string, processExitCode: ExitCodes): boolean {\n   return processExitCode === ExitCodes.ERROR && deleteErrorRegex.test(data);\n}\n", "import { BranchSummary, BranchSummaryBranch } from '../../../typings';\n\nexport class BranchSummaryResult implements BranchSummary {\n   public all: string[] = [];\n   public branches: { [p: string]: BranchSummaryBranch } = {};\n   public current: string = '';\n   public detached: boolean = false;\n\n   push(current: boolean, detached: boolean, name: string, commit: string, label: string) {\n      if (current) {\n         this.detached = detached;\n         this.current = name;\n      }\n\n      this.all.push(name);\n      this.branches[name] = {\n         current: current,\n         name: name,\n         commit: commit,\n         label: label\n      };\n   }\n}\n\n", "import { BranchSummary } from '../../../typings';\nimport { BranchSummaryResult } from '../responses/BranchSummary';\nimport { LineParser, parseStringResponse } from '../utils';\n\nconst parsers: LineParser<BranchSummaryResult>[] = [\n   new LineParser(/^(\\*\\s)?\\((?:HEAD )?detached (?:from|at) (\\S+)\\)\\s+([a-z0-9]+)\\s(.*)$/, (result, [current, name, commit, label]) => {\n      result.push(\n         !!current,\n         true,\n         name, commit, label\n      );\n   }),\n   new LineParser(/^(\\*\\s)?(\\S+)\\s+([a-z0-9]+)\\s?(.*)$/s, (result, [current, name, commit, label]) => {\n      result.push(\n         !!current,\n         false,\n         name, commit, label\n      );\n   })\n];\n\nexport function parseBranchSummary (stdOut: string): BranchSummary {\n   return parseStringResponse(new BranchSummaryResult(), parsers, stdOut);\n}\n", "import { BranchMultiDeleteResult, BranchSingleDeleteResult, BranchSummary } from '../../../typings';\nimport { StringTask } from '../types';\nimport { GitResponseError } from '../errors/git-response-error';\nimport { hasBranchDeletionError, parseBranchDeletions } from '../parsers/parse-branch-delete';\nimport { parseBranchSummary } from '../parsers/parse-branch';\nimport { bufferToString } from '../utils';\n\nexport function containsDeleteBranchCommand(commands: string[]) {\n   const deleteCommands = ['-d', '-D', '--delete'];\n   return commands.some(command => deleteCommands.includes(command));\n}\n\nexport function branchTask(customArgs: string[]): StringTask<BranchSummary | BranchSingleDeleteResult> {\n   const isDelete = containsDeleteBranchCommand(customArgs);\n   const commands = ['branch', ...customArgs];\n\n   if (commands.length === 1) {\n      commands.push('-a');\n   }\n\n   if (!commands.includes('-v')) {\n      commands.splice(1, 0, '-v');\n   }\n\n   return {\n      format: 'utf-8',\n      commands,\n      parser(stdOut, stdErr) {\n         if (isDelete) {\n            return parseBranchDeletions(stdOut, stdErr).all[0];\n         }\n\n         return parseBranchSummary(stdOut);\n      },\n   }\n}\n\nexport function branchLocalTask(): StringTask<BranchSummary> {\n   const parser = parseBranchSummary;\n\n   return {\n      format: 'utf-8',\n      commands: ['branch', '-v'],\n      parser,\n   }\n}\n\nexport function deleteBranchesTask(branches: string[], forceDelete = false): StringTask<BranchMultiDeleteResult> {\n   return {\n      format: 'utf-8',\n      commands: ['branch', '-v', forceDelete ? '-D' : '-d', ...branches],\n      parser(stdOut, stdErr) {\n         return parseBranchDeletions(stdOut, stdErr);\n      },\n      onError({exitCode, stdOut}, error, done, fail) {\n         if (!hasBranchDeletionError(String(error), exitCode)) {\n            return fail(error);\n         }\n\n         done(stdOut);\n      },\n   }\n}\n\nexport function deleteBranchTask(branch: string, forceDelete = false): StringTask<BranchSingleDeleteResult> {\n   const task: StringTask<BranchSingleDeleteResult> = {\n      format: 'utf-8',\n      commands: ['branch', '-v', forceDelete ? '-D' : '-d', branch],\n      parser(stdOut, stdErr) {\n         return parseBranchDeletions(stdOut, stdErr).branches[branch]!;\n      },\n      onError({exitCode, stdErr, stdOut}, error, _, fail) {\n         if (!hasBranchDeletionError(String(error), exitCode)) {\n            return fail(error);\n         }\n\n         throw new GitResponseError(\n            task.parser(bufferToString(stdOut), bufferToString(stdErr)),\n            String(error)\n         );\n      },\n   };\n\n   return task;\n}\n", "\n/**\n * Parser for the `check-ignore` command - returns each file as a string array\n */\nexport const parseCheckIgnore = (text: string): string[] => {\n   return text.split(/\\n/g)\n      .map(line => line.trim())\n      .filter(file => !!file);\n};\n", "import { StringTask } from '../types';\nimport { parseCheckIgnore } from '../responses/CheckIgnore';\n\nexport function checkIgnoreTask(paths: string[]): StringTask<string[]> {\n   return {\n      commands: ['check-ignore', ...paths],\n      format: 'utf-8',\n      parser: parseCheckIgnore,\n   };\n}\n", "import { configurationErrorTask, EmptyTask, straightThroughStringTask } from './task';\nimport { OptionFlags, Options, StringTask } from '../types';\nimport { append, filterString } from '../utils';\n\nexport type CloneOptions = Options &\n   OptionFlags<'--bare' |\n      '--dissociate' |\n      '--mirror' |\n      '--no-checkout' |\n      '--no-remote-submodules' |\n      '--no-shallow-submodules' |\n      '--no-single-branch' |\n      '--no-tags' |\n      '--remote-submodules' |\n      '--single-branch' |\n      '--shallow-submodules' |\n      '--verbose'> &\n   OptionFlags<'--depth' | '-j' | '--jobs', number> &\n   OptionFlags<'--branch' | '--origin' | '--recurse-submodules' | '--separate-git-dir' | '--shallow-exclude' | '--shallow-since' | '--template', string>\n\nfunction disallowedCommand(command: string) {\n   return /^--upload-pack(=|$)/.test(command);\n}\n\nexport function cloneTask(repo: string | undefined, directory: string | undefined, customArgs: string[]): StringTask<string> | EmptyTask {\n   const commands = ['clone', ...customArgs];\n\n   filterString(repo) && commands.push(repo);\n   filterString(directory) && commands.push(directory);\n\n   const banned = commands.find(disallowedCommand);\n   if (banned) {\n      return configurationErrorTask(`git.fetch: potential exploit argument blocked.`);\n   }\n\n   return straightThroughStringTask(commands);\n}\n\nexport function cloneMirrorTask(repo: string | undefined, directory: string | undefined, customArgs: string[]) {\n   append(customArgs, '--mirror');\n\n   return cloneTask(repo, directory, customArgs);\n}\n", "import { StringTask } from '../types';\nimport { DiffResult } from '../../../typings';\nimport { parseDiffResult } from '../parsers/parse-diff-summary';\n\nexport function diffSummaryTask(customArgs: string[]): StringTask<DiffResult> {\n   return {\n      commands: ['diff', '--stat=4096', ...customArgs],\n      format: 'utf-8',\n      parser (stdOut) {\n         return parseDiffResult(stdOut);\n      }\n   }\n}\n", "import { FetchResult } from '../../../typings';\nimport { LineParser, parseStringResponse } from '../utils';\n\nconst parsers: LineParser<FetchResult>[] = [\n   new LineParser(/From (.+)$/, (result, [remote]) => {\n      result.remote = remote;\n   }),\n   new LineParser(/\\* \\[new branch]\\s+(\\S+)\\s*-> (.+)$/, (result, [name, tracking]) =>{\n      result.branches.push({\n         name,\n         tracking,\n      });\n   }),\n   new LineParser(/\\* \\[new tag]\\s+(\\S+)\\s*-> (.+)$/, (result, [name, tracking]) => {\n      result.tags.push({\n         name,\n         tracking,\n      });\n   })\n];\n\nexport function parseFetchResult (stdOut: string, stdErr: string): FetchResult {\n   const result: FetchResult = {\n      raw: stdOut,\n      remote: null,\n      branches: [],\n      tags: [],\n   };\n   return parseStringResponse(result, parsers, stdOut, stdErr);\n}\n", "import { FetchResult } from '../../../typings';\nimport { parseFetchResult } from '../parsers/parse-fetch';\nimport { StringTask } from '../types';\n\nimport { configurationErrorTask, EmptyTask } from './task';\n\nfunction disallowedCommand(command: string) {\n   return /^--upload-pack(=|$)/.test(command);\n}\n\nexport function fetchTask(remote: string, branch: string, customArgs: string[]): StringTask<FetchResult> | EmptyTask {\n   const commands = ['fetch', ...customArgs];\n   if (remote && branch) {\n      commands.push(remote, branch);\n   }\n\n   const banned = commands.find(disallowedCommand);\n   if (banned) {\n      return configurationErrorTask(`git.fetch: potential exploit argument blocked.`);\n   }\n\n   return {\n      commands,\n      format: 'utf-8',\n      parser: parseFetchResult,\n   }\n}\n", "import { MoveResult } from '../../../typings';\nimport { LineParser, parseStringResponse } from '../utils';\n\nconst parsers: LineParser<MoveResult>[] = [\n   new LineParser(/^Renaming (.+) to (.+)$/, (result, [from, to]) => {\n      result.moves.push({from, to});\n   }),\n];\n\nexport function parseMoveResult (stdOut: string): MoveResult {\n   return parseStringResponse({moves: []}, parsers, stdOut);\n}\n", "import { MoveResult } from '../../../typings';\nimport { parseMoveResult } from '../parsers/parse-move';\nimport { StringTask } from '../types';\nimport { asArray } from '../utils';\n\nexport function moveTask(from: string | string[], to: string): StringTask<MoveResult> {\n   return {\n      commands: ['mv', '-v', ...asArray(from), to],\n      format: 'utf-8',\n      parser: parseMoveResult,\n   };\n}\n", "import { PullResult } from '../../../typings';\nimport { GitResponseError } from '../errors/git-response-error';\nimport { parsePullErrorResult, parsePullResult } from '../parsers/parse-pull';\nimport { Maybe, StringTask } from '../types';\nimport { bufferToString } from '../utils';\n\nexport function pullTask(remote: Maybe<string>, branch: Maybe<string>, customArgs: string[]): StringTask<PullResult> {\n   const commands: string[] = ['pull', ...customArgs];\n   if (remote && branch) {\n      commands.splice(1, 0, remote, branch);\n   }\n\n   return {\n      commands,\n      format: 'utf-8',\n      parser(stdOut, stdErr): PullResult {\n         return parsePullResult(stdOut, stdErr);\n      },\n      onError(result, _error, _done, fail) {\n         const pullError = parsePullErrorResult(bufferToString(result.stdOut), bufferToString(result.stdErr));\n         if (pullError) {\n            return fail(new GitResponseError(pullError));\n         }\n\n         fail(_error);\n      }\n   }\n}\n", "import { forEachLineWithContent } from '../utils';\n\nexport interface RemoteWithoutRefs {\n   name: string;\n}\n\nexport interface RemoteWithRefs extends RemoteWithoutRefs {\n   refs: {\n      fetch: string;\n      push: string;\n   };\n}\n\nexport function parseGetRemotes (text: string): RemoteWithoutRefs[] {\n   const remotes: {[name: string]: RemoteWithoutRefs} = {};\n\n   forEach(text, ([name]) => remotes[name] = { name });\n\n   return Object.values(remotes);\n}\n\nexport function parseGetRemotesVerbose (text: string): RemoteWithRefs[] {\n   const remotes: {[name: string]: RemoteWithRefs} = {};\n\n   forEach(text, ([name, url, purpose]) => {\n      if (!remotes.hasOwnProperty(name)) {\n         remotes[name] = {\n            name: name,\n            refs: { fetch: '', push: '' },\n         };\n      }\n\n      if (purpose && url) {\n         remotes[name].refs[purpose.replace(/[^a-z]/g, '') as keyof RemoteWithRefs['refs']] = url;\n      }\n   });\n\n   return Object.values(remotes);\n}\n\nfunction forEach(text: string, handler: (line: string[]) => void) {\n   forEachLineWithContent(text, (line) => handler(line.split(/\\s+/)));\n}\n", "import { parseGetRemotes, parseGetRemotesVerbose } from '../responses/GetRemoteSummary';\nimport { StringTask } from '../types';\nimport { straightThroughStringTask } from './task';\n\nexport function addRemoteTask(remoteName: string, remoteRepo: string, customArgs: string[] = []): StringTask<string> {\n   return straightThroughStringTask(['remote', 'add', ...customArgs, remoteName, remoteRepo]);\n}\n\nexport function getRemotesTask(verbose: boolean): StringTask<any> {\n   const commands = ['remote'];\n   if (verbose) {\n      commands.push('-v');\n   }\n\n   return {\n      commands,\n      format: 'utf-8',\n      parser: verbose ? parseGetRemotesVerbose : parseGetRemotes,\n   };\n}\n\nexport function listRemotesTask(customArgs: string[] = []): StringTask<string> {\n   const commands = [...customArgs];\n   if (commands[0] !== 'ls-remote') {\n      commands.unshift('ls-remote');\n   }\n\n   return straightThroughStringTask(commands);\n}\n\nexport function remoteTask(customArgs: string[] = []): StringTask<string> {\n   const commands = [...customArgs];\n   if (commands[0] !== 'remote') {\n      commands.unshift('remote');\n   }\n\n   return straightThroughStringTask(commands);\n}\n\nexport function removeRemoteTask(remoteName: string) {\n   return straightThroughStringTask(['remote', 'remove', remoteName]);\n}\n", "import { LogOptions, LogResult } from '../../../typings';\nimport { createListLogSummaryParser } from '../parsers/parse-list-log-summary';\nimport { StringTask } from '../types';\nimport { parseLogOptions } from './log';\n\nexport function stashListTask(opt: LogOptions = {}, customArgs: string[]): StringTask<LogResult> {\n   const options = parseLogOptions<any>(opt);\n   const parser = createListLogSummaryParser(options.splitter, options.fields);\n\n   return {\n      commands: ['stash', 'list', ...options.commands, ...customArgs],\n      format: 'utf-8',\n      parser,\n   };\n}\n", "import { StringTask } from '../types';\nimport { straightThroughStringTask } from './task';\n\nexport function addSubModuleTask(repo: string, path: string): StringTask<string> {\n   return subModuleTask(['add', repo, path]);\n}\n\nexport function initSubModuleTask(customArgs: string[]): StringTask<string> {\n   return subModuleTask(['init', ...customArgs]);\n}\n\nexport function subModuleTask(customArgs: string[]): StringTask<string> {\n   const commands = [...customArgs];\n   if (commands[0] !== 'submodule') {\n      commands.unshift('submodule');\n   }\n\n   return straightThroughStringTask(commands);\n}\n\nexport function updateSubModuleTask(customArgs: string[]): StringTask<string> {\n   return subModuleTask(['update', ...customArgs]);\n}\n", "import { TagResult } from '../../../typings';\n\nexport class TagList implements TagResult {\n   constructor(\n      public readonly all: string[],\n      public readonly latest: string | undefined,\n   ) {\n   }\n}\n\nexport const parseTagList = function (data: string, customSort = false) {\n   const tags = data\n      .split('\\n')\n      .map(trimmed)\n      .filter(Boolean);\n\n   if (!customSort) {\n      tags.sort(function (tagA, tagB) {\n         const partsA = tagA.split('.');\n         const partsB = tagB.split('.');\n\n         if (partsA.length === 1 || partsB.length === 1) {\n            return singleSorted(toNumber(partsA[0]), toNumber(partsB[0]));\n         }\n\n         for (let i = 0, l = Math.max(partsA.length, partsB.length); i < l; i++) {\n            const diff = sorted(toNumber(partsA[i]), toNumber(partsB[i]));\n\n            if (diff) {\n               return diff;\n            }\n         }\n\n         return 0;\n      });\n   }\n\n   const latest = customSort ? tags[0] : [...tags].reverse().find((tag) => tag.indexOf('.') >= 0);\n\n   return new TagList(tags, latest);\n};\n\nfunction singleSorted(a: number, b:  number): number {\n   const aIsNum = isNaN(a);\n   const bIsNum = isNaN(b);\n\n   if (aIsNum !== bIsNum) {\n      return aIsNum ? 1 : -1;\n   }\n\n   return aIsNum ? sorted(a, b) : 0;\n}\n\nfunction sorted(a: number, b: number) {\n   return a === b ? 0 : a > b ? 1 : -1;\n}\n\nfunction trimmed(input: string) {\n   return input.trim();\n}\n\nfunction toNumber(input: string | undefined) {\n   if (typeof input === 'string') {\n      return parseInt(input.replace(/^\\D+/g, ''), 10) || 0;\n   }\n\n   return 0;\n}\n", "import { TagResult } from '../../../typings';\nimport { parseTagList } from '../responses/TagList';\nimport { StringTask } from '../types';\n\n/**\n * Task used by `git.tags`\n */\nexport function tagListTask (customArgs: string[] = []): StringTask<TagResult> {\n   const hasCustomSort = customArgs.some((option) => /^--sort=/.test(option));\n\n   return {\n      format: 'utf-8',\n      commands: ['tag', '-l', ...customArgs],\n      parser (text: string) {\n         return parseTagList(text, hasCustomSort);\n      },\n   }\n}\n\n/**\n * Task used by `git.addTag`\n */\nexport function addTagTask (name: string): StringTask<{name: string}> {\n   return {\n      format: 'utf-8',\n      commands: ['tag', name],\n      parser () {\n         return {name};\n      }\n   }\n}\n\n/**\n * Task used by `git.addTag`\n */\nexport function addAnnotatedTagTask (name: string, tagMessage: string): StringTask<{name: string}> {\n   return {\n      format: 'utf-8',\n      commands: ['tag', '-a', '-m', tagMessage, name],\n      parser () {\n         return {name};\n      }\n   }\n}\n", "const {GitExecutor} = require('./lib/runners/git-executor');\nconst {SimpleGitApi} = require('./lib/simple-git-api');\n\nconst {Scheduler} = require('./lib/runners/scheduler');\nconst {configurationErrorTask} = require('./lib/tasks/task');\nconst {\n   asArray,\n   filterArray,\n   filterPrimitives,\n   filterString,\n   filterStringOrStringArray,\n   filterType,\n   getTrailingOptions,\n   trailingFunctionArgument,\n   trailingOptionsArgument\n} = require('./lib/utils');\nconst {applyPatchTask} = require('./lib/tasks/apply-patch')\nconst {branchTask, branchLocalTask, deleteBranchesTask, deleteBranchTask} = require('./lib/tasks/branch');\nconst {checkIgnoreTask} = require('./lib/tasks/check-ignore');\nconst {checkIsRepoTask} = require('./lib/tasks/check-is-repo');\nconst {cloneTask, cloneMirrorTask} = require('./lib/tasks/clone');\nconst {cleanWithOptionsTask, isCleanOptionsArray} = require('./lib/tasks/clean');\nconst {commitTask} = require('./lib/tasks/commit');\nconst {diffSummaryTask} = require('./lib/tasks/diff');\nconst {fetchTask} = require('./lib/tasks/fetch');\nconst {moveTask} = require(\"./lib/tasks/move\");\nconst {pullTask} = require('./lib/tasks/pull');\nconst {pushTagsTask} = require('./lib/tasks/push');\nconst {addRemoteTask, getRemotesTask, listRemotesTask, remoteTask, removeRemoteTask} = require('./lib/tasks/remote');\nconst {getResetMode, resetTask} = require('./lib/tasks/reset');\nconst {stashListTask} = require('./lib/tasks/stash-list');\nconst {addSubModuleTask, initSubModuleTask, subModuleTask, updateSubModuleTask} = require('./lib/tasks/sub-module');\nconst {addAnnotatedTagTask, addTagTask, tagListTask} = require('./lib/tasks/tag');\nconst {straightThroughBufferTask, straightThroughStringTask} = require('./lib/tasks/task');\n\nfunction Git (options, plugins) {\n   this._executor = new GitExecutor(\n      options.binary, options.baseDir,\n      new Scheduler(options.maxConcurrentProcesses), plugins,\n   );\n}\n\n(Git.prototype = Object.create(SimpleGitApi.prototype)).constructor = Git;\n\n/**\n * Sets the path to a custom git binary, should either be `git` when there is an installation of git available on\n * the system path, or a fully qualified path to the executable.\n *\n * @param {string} command\n * @returns {Git}\n */\nGit.prototype.customBinary = function (command) {\n   this._executor.binary = command;\n   return this;\n};\n\n/**\n * Sets an environment variable for the spawned child process, either supply both a name and value as strings or\n * a single object to entirely replace the current environment variables.\n *\n * @param {string|Object} name\n * @param {string} [value]\n * @returns {Git}\n */\nGit.prototype.env = function (name, value) {\n   if (arguments.length === 1 && typeof name === 'object') {\n      this._executor.env = name;\n   } else {\n      (this._executor.env = this._executor.env || {})[name] = value;\n   }\n\n   return this;\n};\n\n/**\n * List the stash(s) of the local repo\n */\nGit.prototype.stashList = function (options) {\n   return this._runTask(\n      stashListTask(\n         trailingOptionsArgument(arguments) || {},\n         filterArray(options) && options || []\n      ),\n      trailingFunctionArgument(arguments),\n   );\n};\n\nfunction createCloneTask (api, task, repoPath, localPath) {\n   if (typeof repoPath !== 'string') {\n      return configurationErrorTask(`git.${ api }() requires a string 'repoPath'`);\n   }\n\n   return task(repoPath, filterType(localPath, filterString), getTrailingOptions(arguments));\n}\n\n\n/**\n * Clone a git repo\n */\nGit.prototype.clone = function () {\n   return this._runTask(\n      createCloneTask('clone', cloneTask, ...arguments),\n      trailingFunctionArgument(arguments),\n   );\n};\n\n/**\n * Mirror a git repo\n */\nGit.prototype.mirror = function () {\n   return this._runTask(\n      createCloneTask('mirror', cloneMirrorTask, ...arguments),\n      trailingFunctionArgument(arguments),\n   );\n};\n\n/**\n * Moves one or more files to a new destination.\n *\n * @see https://git-scm.com/docs/git-mv\n *\n * @param {string|string[]} from\n * @param {string} to\n */\nGit.prototype.mv = function (from, to) {\n   return this._runTask(moveTask(from, to), trailingFunctionArgument(arguments));\n};\n\n/**\n * Internally uses pull and tags to get the list of tags then checks out the latest tag.\n *\n * @param {Function} [then]\n */\nGit.prototype.checkoutLatestTag = function (then) {\n   var git = this;\n   return this.pull(function () {\n      git.tags(function (err, tags) {\n         git.checkout(tags.latest, then);\n      });\n   });\n};\n\n/**\n * Pull the updated contents of the current repo\n */\nGit.prototype.pull = function (remote, branch, options, then) {\n   return this._runTask(\n      pullTask(filterType(remote, filterString), filterType(branch, filterString), getTrailingOptions(arguments)),\n      trailingFunctionArgument(arguments),\n   );\n};\n\n/**\n * Fetch the updated contents of the current repo.\n *\n * @example\n *   .fetch('upstream', 'master') // fetches from master on remote named upstream\n *   .fetch(function () {}) // runs fetch against default remote and branch and calls function\n *\n * @param {string} [remote]\n * @param {string} [branch]\n */\nGit.prototype.fetch = function (remote, branch) {\n   return this._runTask(\n      fetchTask(filterType(remote, filterString), filterType(branch, filterString), getTrailingOptions(arguments)),\n      trailingFunctionArgument(arguments),\n   );\n};\n\n/**\n * Disables/enables the use of the console for printing warnings and errors, by default messages are not shown in\n * a production environment.\n *\n * @param {boolean} silence\n * @returns {Git}\n */\nGit.prototype.silent = function (silence) {\n   console.warn('simple-git deprecation notice: git.silent: logging should be configured using the `debug` library / `DEBUG` environment variable, this will be an error in version 3');\n   return this;\n};\n\n/**\n * List all tags. When using git 2.7.0 or above, include an options object with `\"--sort\": \"property-name\"` to\n * sort the tags by that property instead of using the default semantic versioning sort.\n *\n * Note, supplying this option when it is not supported by your Git version will cause the operation to fail.\n *\n * @param {Object} [options]\n * @param {Function} [then]\n */\nGit.prototype.tags = function (options, then) {\n   return this._runTask(\n      tagListTask(getTrailingOptions(arguments)),\n      trailingFunctionArgument(arguments),\n   );\n};\n\n/**\n * Rebases the current working copy. Options can be supplied either as an array of string parameters\n * to be sent to the `git rebase` command, or a standard options object.\n */\nGit.prototype.rebase = function () {\n   return this._runTask(\n      straightThroughStringTask(['rebase', ...getTrailingOptions(arguments)]),\n      trailingFunctionArgument(arguments)\n   );\n};\n\n/**\n * Reset a repo\n */\nGit.prototype.reset = function (mode) {\n   return this._runTask(\n      resetTask(getResetMode(mode), getTrailingOptions(arguments)),\n      trailingFunctionArgument(arguments),\n   );\n};\n\n/**\n * Revert one or more commits in the local working copy\n */\nGit.prototype.revert = function (commit) {\n   const next = trailingFunctionArgument(arguments);\n\n   if (typeof commit !== 'string') {\n      return this._runTask(\n         configurationErrorTask('Commit must be a string'),\n         next,\n      );\n   }\n\n   return this._runTask(\n      straightThroughStringTask(['revert', ...getTrailingOptions(arguments, 0, true), commit]),\n      next\n   );\n};\n\n/**\n * Add a lightweight tag to the head of the current branch\n */\nGit.prototype.addTag = function (name) {\n   const task = (typeof name === 'string')\n      ? addTagTask(name)\n      : configurationErrorTask('Git.addTag requires a tag name');\n\n   return this._runTask(task, trailingFunctionArgument(arguments));\n};\n\n/**\n * Add an annotated tag to the head of the current branch\n */\nGit.prototype.addAnnotatedTag = function (tagName, tagMessage) {\n   return this._runTask(\n      addAnnotatedTagTask(tagName, tagMessage),\n      trailingFunctionArgument(arguments),\n   );\n};\n\n/**\n * Check out a tag or revision, any number of additional arguments can be passed to the `git checkout` command\n * by supplying either a string or array of strings as the first argument.\n */\nGit.prototype.checkout = function () {\n   const commands = ['checkout', ...getTrailingOptions(arguments, true)];\n   return this._runTask(\n      straightThroughStringTask(commands),\n      trailingFunctionArgument(arguments),\n   );\n};\n\n/**\n * Check out a remote branch\n *\n * @param {string} branchName name of branch\n * @param {string} startPoint (e.g origin/development)\n * @param {Function} [then]\n */\nGit.prototype.checkoutBranch = function (branchName, startPoint, then) {\n   return this.checkout(['-b', branchName, startPoint], trailingFunctionArgument(arguments));\n};\n\n/**\n * Check out a local branch\n */\nGit.prototype.checkoutLocalBranch = function (branchName, then) {\n   return this.checkout(['-b', branchName], trailingFunctionArgument(arguments));\n};\n\n/**\n * Delete a local branch\n */\nGit.prototype.deleteLocalBranch = function (branchName, forceDelete, then) {\n   return this._runTask(\n      deleteBranchTask(branchName, typeof forceDelete === \"boolean\" ? forceDelete : false),\n      trailingFunctionArgument(arguments),\n   );\n};\n\n/**\n * Delete one or more local branches\n */\nGit.prototype.deleteLocalBranches = function (branchNames, forceDelete, then) {\n   return this._runTask(\n      deleteBranchesTask(branchNames, typeof forceDelete === \"boolean\" ? forceDelete : false),\n      trailingFunctionArgument(arguments),\n   );\n};\n\n/**\n * List all branches\n *\n * @param {Object | string[]} [options]\n * @param {Function} [then]\n */\nGit.prototype.branch = function (options, then) {\n   return this._runTask(\n      branchTask(getTrailingOptions(arguments)),\n      trailingFunctionArgument(arguments),\n   );\n};\n\n/**\n * Return list of local branches\n *\n * @param {Function} [then]\n */\nGit.prototype.branchLocal = function (then) {\n   return this._runTask(\n      branchLocalTask(),\n      trailingFunctionArgument(arguments),\n   );\n};\n\n/**\n * Executes any command against the git binary.\n */\nGit.prototype.raw = function (commands) {\n   const createRestCommands = !Array.isArray(commands);\n   const command = [].slice.call(createRestCommands ? arguments : commands, 0);\n\n   for (let i = 0; i < command.length && createRestCommands; i++) {\n      if (!filterPrimitives(command[i])) {\n         command.splice(i, command.length - i);\n         break;\n      }\n   }\n\n   command.push(\n      ...getTrailingOptions(arguments, 0, true),\n   );\n\n   var next = trailingFunctionArgument(arguments);\n\n   if (!command.length) {\n      return this._runTask(\n         configurationErrorTask('Raw: must supply one or more command to execute'),\n         next,\n      );\n   }\n\n   return this._runTask(straightThroughStringTask(command), next);\n};\n\nGit.prototype.submoduleAdd = function (repo, path, then) {\n   return this._runTask(\n      addSubModuleTask(repo, path),\n      trailingFunctionArgument(arguments),\n   );\n};\n\nGit.prototype.submoduleUpdate = function (args, then) {\n   return this._runTask(\n      updateSubModuleTask(getTrailingOptions(arguments, true)),\n      trailingFunctionArgument(arguments),\n   );\n};\n\nGit.prototype.submoduleInit = function (args, then) {\n   return this._runTask(\n      initSubModuleTask(getTrailingOptions(arguments, true)),\n      trailingFunctionArgument(arguments),\n   );\n};\n\nGit.prototype.subModule = function (options, then) {\n   return this._runTask(\n      subModuleTask(getTrailingOptions(arguments)),\n      trailingFunctionArgument(arguments),\n   );\n};\n\nGit.prototype.listRemote = function () {\n   return this._runTask(\n      listRemotesTask(getTrailingOptions(arguments)),\n      trailingFunctionArgument(arguments),\n   );\n};\n\n/**\n * Adds a remote to the list of remotes.\n */\nGit.prototype.addRemote = function (remoteName, remoteRepo, then) {\n   return this._runTask(\n      addRemoteTask(remoteName, remoteRepo, getTrailingOptions(arguments)),\n      trailingFunctionArgument(arguments),\n   );\n};\n\n/**\n * Removes an entry by name from the list of remotes.\n */\nGit.prototype.removeRemote = function (remoteName, then) {\n   return this._runTask(\n      removeRemoteTask(remoteName),\n      trailingFunctionArgument(arguments),\n   );\n};\n\n/**\n * Gets the currently available remotes, setting the optional verbose argument to true includes additional\n * detail on the remotes themselves.\n */\nGit.prototype.getRemotes = function (verbose, then) {\n   return this._runTask(\n      getRemotesTask(verbose === true),\n      trailingFunctionArgument(arguments),\n   );\n};\n\n/**\n * Call any `git remote` function with arguments passed as an array of strings.\n *\n * @param {string[]} options\n * @param {Function} [then]\n */\nGit.prototype.remote = function (options, then) {\n   return this._runTask(\n      remoteTask(getTrailingOptions(arguments)),\n      trailingFunctionArgument(arguments),\n   );\n};\n\n/**\n * Call any `git tag` function with arguments passed as an array of strings.\n *\n * @param {string[]} options\n * @param {Function} [then]\n */\nGit.prototype.tag = function (options, then) {\n   const command = getTrailingOptions(arguments);\n\n   if (command[0] !== 'tag') {\n      command.unshift('tag');\n   }\n\n   return this._runTask(\n      straightThroughStringTask(command),\n      trailingFunctionArgument(arguments)\n   );\n};\n\n/**\n * Updates repository server info\n *\n * @param {Function} [then]\n */\nGit.prototype.updateServerInfo = function (then) {\n   return this._runTask(\n      straightThroughStringTask(['update-server-info']),\n      trailingFunctionArgument(arguments),\n   );\n};\n\n/**\n * Pushes the current tag changes to a remote which can be either a URL or named remote. When not specified uses the\n * default configured remote spec.\n *\n * @param {string} [remote]\n * @param {Function} [then]\n */\nGit.prototype.pushTags = function (remote, then) {\n   const task = pushTagsTask({remote: filterType(remote, filterString)}, getTrailingOptions(arguments));\n\n   return this._runTask(task, trailingFunctionArgument(arguments));\n};\n\n/**\n * Removes the named files from source control.\n */\nGit.prototype.rm = function (files) {\n   return this._runTask(\n      straightThroughStringTask(['rm', '-f', ...asArray(files)]),\n      trailingFunctionArgument(arguments)\n   );\n};\n\n/**\n * Removes the named files from source control but keeps them on disk rather than deleting them entirely. To\n * completely remove the files, use `rm`.\n *\n * @param {string|string[]} files\n */\nGit.prototype.rmKeepLocal = function (files) {\n   return this._runTask(\n      straightThroughStringTask(['rm', '--cached', ...asArray(files)]),\n      trailingFunctionArgument(arguments)\n   );\n};\n\n/**\n * Returns a list of objects in a tree based on commit hash. Passing in an object hash returns the object's content,\n * size, and type.\n *\n * Passing \"-p\" will instruct cat-file to determine the object type, and display its formatted contents.\n *\n * @param {string[]} [options]\n * @param {Function} [then]\n */\nGit.prototype.catFile = function (options, then) {\n   return this._catFile('utf-8', arguments);\n};\n\nGit.prototype.binaryCatFile = function () {\n   return this._catFile('buffer', arguments);\n};\n\nGit.prototype._catFile = function (format, args) {\n   var handler = trailingFunctionArgument(args);\n   var command = ['cat-file'];\n   var options = args[0];\n\n   if (typeof options === 'string') {\n      return this._runTask(\n         configurationErrorTask('Git.catFile: options must be supplied as an array of strings'),\n         handler,\n      );\n   }\n\n   if (Array.isArray(options)) {\n      command.push.apply(command, options);\n   }\n\n   const task = format === 'buffer'\n      ? straightThroughBufferTask(command)\n      : straightThroughStringTask(command);\n\n   return this._runTask(task, handler);\n};\n\nGit.prototype.diff = function (options, then) {\n   const task = filterString(options)\n      ? configurationErrorTask('git.diff: supplying options as a single string is no longer supported, switch to an array of strings')\n      : straightThroughStringTask(['diff', ...getTrailingOptions(arguments)]);\n\n   return this._runTask(\n      task,\n      trailingFunctionArgument(arguments),\n   );\n};\n\nGit.prototype.diffSummary = function () {\n   return this._runTask(\n      diffSummaryTask(getTrailingOptions(arguments, 1)),\n      trailingFunctionArgument(arguments),\n   );\n};\n\nGit.prototype.applyPatch = function (patches) {\n   const task = !filterStringOrStringArray(patches)\n      ? configurationErrorTask(`git.applyPatch requires one or more string patches as the first argument`)\n      : applyPatchTask(asArray(patches), getTrailingOptions([].slice.call(arguments, 1)));\n\n   return this._runTask(\n      task,\n      trailingFunctionArgument(arguments),\n   );\n}\n\nGit.prototype.revparse = function () {\n   const commands = ['rev-parse', ...getTrailingOptions(arguments, true)];\n   return this._runTask(\n      straightThroughStringTask(commands, true),\n      trailingFunctionArgument(arguments),\n   );\n};\n\n/**\n * Show various types of objects, for example the file at a certain commit\n *\n * @param {string[]} [options]\n * @param {Function} [then]\n */\nGit.prototype.show = function (options, then) {\n   return this._runTask(\n      straightThroughStringTask(['show', ...getTrailingOptions(arguments, 1)]),\n      trailingFunctionArgument(arguments)\n   );\n};\n\n/**\n */\nGit.prototype.clean = function (mode, options, then) {\n   const usingCleanOptionsArray = isCleanOptionsArray(mode);\n   const cleanMode = usingCleanOptionsArray && mode.join('') || filterType(mode, filterString) || '';\n   const customArgs = getTrailingOptions([].slice.call(arguments, usingCleanOptionsArray ? 1 : 0));\n\n   return this._runTask(\n      cleanWithOptionsTask(cleanMode, customArgs),\n      trailingFunctionArgument(arguments),\n   );\n};\n\nGit.prototype.exec = function (then) {\n   const task = {\n      commands: [],\n      format: 'utf-8',\n      parser () {\n         if (typeof then === 'function') {\n            then();\n         }\n      }\n   };\n\n   return this._runTask(task);\n};\n\n/**\n * Clears the queue of pending commands and returns the wrapper instance for chaining.\n *\n * @returns {Git}\n */\nGit.prototype.clearQueue = function () {\n   // TODO:\n   // this._executor.clear();\n   return this;\n};\n\n/**\n * Check if a pathname or pathnames are excluded by .gitignore\n *\n * @param {string|string[]} pathnames\n * @param {Function} [then]\n */\nGit.prototype.checkIgnore = function (pathnames, then) {\n   return this._runTask(\n      checkIgnoreTask(asArray((filterType(pathnames, filterStringOrStringArray, [])))),\n      trailingFunctionArgument(arguments),\n   );\n};\n\nGit.prototype.checkIsRepo = function (checkType, then) {\n   return this._runTask(\n      checkIsRepoTask(filterType(checkType, filterString)),\n      trailingFunctionArgument(arguments),\n   );\n};\n\nmodule.exports = Git;\n", "import { SimpleGitFactory } from '../../typings';\n\nimport * as api from './api';\nimport {\n   commandConfigPrefixingPlugin,\n   completionDetectionPlugin,\n   errorDetectionHandler,\n   errorDetectionPlugin,\n   PluginStore,\n   progressMonitorPlugin,\n   spawnOptionsPlugin,\n   timeoutPlugin\n} from './plugins';\nimport { createInstanceConfig, folderExists } from './utils';\nimport { SimpleGitOptions } from './types';\n\nconst Git = require('../git');\n\n/**\n * Adds the necessary properties to the supplied object to enable it for use as\n * the default export of a module.\n *\n * Eg: `module.exports = esModuleFactory({ something () {} })`\n */\nexport function esModuleFactory<T>(defaultExport: T): T & { __esModule: true, default: T } {\n   return Object.defineProperties(defaultExport, {\n      __esModule: {value: true},\n      default: {value: defaultExport},\n   });\n}\n\nexport function gitExportFactory<T = {}>(factory: SimpleGitFactory, extra: T) {\n   return Object.assign(function (...args: Parameters<SimpleGitFactory>) {\n         return factory.apply(null, args);\n      },\n      api,\n      extra || {},\n   );\n}\n\nexport function gitInstanceFactory(baseDir?: string | Partial<SimpleGitOptions>, options?: Partial<SimpleGitOptions>) {\n   const plugins = new PluginStore();\n   const config = createInstanceConfig(\n      baseDir && (typeof baseDir === 'string' ? {baseDir} : baseDir) || {},\n      options\n   );\n\n   if (!folderExists(config.baseDir)) {\n      throw new api.GitConstructError(config, `Cannot use simple-git on a directory that does not exist`);\n   }\n\n   if (Array.isArray(config.config)) {\n      plugins.add(commandConfigPrefixingPlugin(config.config));\n   }\n\n   plugins.add(completionDetectionPlugin(config.completion));\n   config.progress && plugins.add(progressMonitorPlugin(config.progress));\n   config.timeout && plugins.add(timeoutPlugin(config.timeout));\n   config.spawnOptions && plugins.add(spawnOptionsPlugin(config.spawnOptions));\n\n   plugins.add(errorDetectionPlugin(errorDetectionHandler(true)));\n   config.errors && plugins.add(errorDetectionPlugin(config.errors));\n\n   return new Git(config, plugins);\n}\n", "import { SimpleGit, SimpleGitOptions } from '../../../typings';\n\nimport { GitResponseError } from '../errors/git-response-error';\nimport { gitInstanceFactory } from '../git-factory';\nimport { SimpleGitTaskCallback } from '../types';\n\nconst functionNamesBuilderApi = [\n   'customBinary', 'env', 'outputHandler', 'silent',\n];\n\nconst functionNamesPromiseApi = [\n   'add',\n   'addAnnotatedTag',\n   'addConfig',\n   'addRemote',\n   'addTag',\n   'applyPatch',\n   'binaryCatFile',\n   'branch',\n   'branchLocal',\n   'catFile',\n   'checkIgnore',\n   'checkIsRepo',\n   'checkout',\n   'checkoutBranch',\n   'checkoutLatestTag',\n   'checkoutLocalBranch',\n   'clean',\n   'clone',\n   'commit',\n   'cwd',\n   'deleteLocalBranch',\n   'deleteLocalBranches',\n   'diff',\n   'diffSummary',\n   'exec',\n   'fetch',\n   'getRemotes',\n   'init',\n   'listConfig',\n   'listRemote',\n   'log',\n   'merge',\n   'mergeFromTo',\n   'mirror',\n   'mv',\n   'pull',\n   'push',\n   'pushTags',\n   'raw',\n   'rebase',\n   'remote',\n   'removeRemote',\n   'reset',\n   'revert',\n   'revparse',\n   'rm',\n   'rmKeepLocal',\n   'show',\n   'stash',\n   'stashList',\n   'status',\n   'subModule',\n   'submoduleAdd',\n   'submoduleInit',\n   'submoduleUpdate',\n   'tag',\n   'tags',\n   'updateServerInfo'\n];\n\nexport function gitP(...args: [] | [string] | [Partial<SimpleGitOptions>] | [string, Partial<SimpleGitOptions>]): SimpleGit {\n\n   let git: any;\n\n   let chain = Promise.resolve();\n\n   try {\n      git = gitInstanceFactory(...args);\n   } catch (e) {\n      chain = Promise.reject(e);\n   }\n\n   function builderReturn() {\n      return promiseApi;\n   }\n\n   function chainReturn() {\n      return chain;\n   }\n\n   const promiseApi = [...functionNamesBuilderApi, ...functionNamesPromiseApi].reduce((api: any, name: string) => {\n      const isAsync = functionNamesPromiseApi.includes(name);\n\n      const valid = isAsync ? asyncWrapper(name, git) : syncWrapper(name, git, api);\n      const alternative = isAsync ? chainReturn : builderReturn;\n\n      Object.defineProperty(api, name, {\n         enumerable: false,\n         configurable: false,\n         value: git ? valid : alternative,\n      });\n\n      return api;\n   }, {});\n\n   return promiseApi as SimpleGit;\n\n   function asyncWrapper(fn: string, git: any): (...args: any[]) => Promise<any> {\n      return function (...args: any[]) {\n         if (typeof args[args.length] === 'function') {\n            throw new TypeError(\n               'Promise interface requires that handlers are not supplied inline, ' +\n               'trailing function not allowed in call to ' + fn);\n         }\n\n         return chain.then(function () {\n            return new Promise(function (resolve, reject) {\n               const callback: SimpleGitTaskCallback = (err: Error | null, result?: any) => {\n                  if (err) {\n                     return reject(toError(err));\n                  }\n\n                  resolve(result);\n               };\n               args.push(callback);\n\n               git[fn].apply(git, args);\n            });\n         });\n      };\n   }\n\n   function syncWrapper(fn: string, git: any, api: SimpleGit) {\n      return (...args: any[]) => {\n         git[fn](...args);\n\n         return api;\n      };\n   }\n}\n\nfunction toError(error: Error | string | any): Error {\n\n   if (error instanceof Error) {\n      return error;\n   }\n\n   if (typeof error === 'string') {\n      return new Error(error);\n   }\n\n   return new GitResponseError(error);\n}\n", "\nconst {gitP} = require('./lib/runners/promise-wrapped');\nconst {esModuleFactory, gitInstanceFactory, gitExportFactory} = require('./lib/git-factory');\n\nmodule.exports = esModuleFactory(\n   gitExportFactory(gitInstanceFactory, {gitP})\n);\n"],
+  "mappings": "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",
   "names": []
 }
diff --git a/node_modules/simple-git/dist/esm/index.js b/node_modules/simple-git/dist/esm/index.js
index e74bb3b..3550725 100644
--- a/node_modules/simple-git/dist/esm/index.js
+++ b/node_modules/simple-git/dist/esm/index.js
@@ -406,9 +406,9 @@ var init_task_options = __esm({
 function callTaskParser(parser3, streams) {
   return parser3(streams.stdOut, streams.stdErr);
 }
-function parseStringResponse(result, parsers11, texts, trim = true) {
-  asArray(texts).forEach((text) => {
-    for (let lines = toLinesWithContent(text, trim), i = 0, max = lines.length; i < max; i++) {
+function parseStringResponse(result, parsers11, ...texts) {
+  texts.forEach((text) => {
+    for (let lines = toLinesWithContent(text), i = 0, max = lines.length; i < max; i++) {
       const line = (offset = 0) => {
         if (i + offset >= max) {
           return;
@@ -1559,26 +1559,6 @@ var init_init = __esm({
   }
 });
 
-// src/lib/args/log-format.ts
-function logFormatFromCommand(customArgs) {
-  for (let i = 0; i < customArgs.length; i++) {
-    const format = logFormatRegex.exec(customArgs[i]);
-    if (format) {
-      return `--${format[1]}`;
-    }
-  }
-  return "" /* NONE */;
-}
-function isLogFormat(customArg) {
-  return logFormatRegex.test(customArg);
-}
-var logFormatRegex;
-var init_log_format = __esm({
-  "src/lib/args/log-format.ts"() {
-    logFormatRegex = /^--(stat|numstat|name-only|name-status)(=|$)/;
-  }
-});
-
 // src/lib/responses/DiffSummary.ts
 var DiffSummary;
 var init_DiffSummary = __esm({
@@ -1595,97 +1575,74 @@ var init_DiffSummary = __esm({
 });
 
 // src/lib/parsers/parse-diff-summary.ts
-function getDiffParser(format = "" /* NONE */) {
-  const parser3 = diffSummaryParsers[format];
-  return (stdOut) => parseStringResponse(new DiffSummary(), parser3, stdOut, false);
+function parseDiffResult(stdOut) {
+  const lines = stdOut.trim().split("\n");
+  const status = new DiffSummary();
+  readSummaryLine(status, lines.pop());
+  for (let i = 0, max = lines.length; i < max; i++) {
+    const line = lines[i];
+    textFileChange(line, status) || binaryFileChange(line, status);
+  }
+  return status;
+}
+function readSummaryLine(status, summary) {
+  (summary || "").trim().split(", ").forEach(function(text) {
+    const summary2 = /(\d+)\s([a-z]+)/.exec(text);
+    if (!summary2) {
+      return;
+    }
+    summaryType(status, summary2[2], parseInt(summary2[1], 10));
+  });
 }
-var statParser, numStatParser, nameOnlyParser, nameStatusParser, diffSummaryParsers;
+function summaryType(status, key, value) {
+  const match = /([a-z]+?)s?\b/.exec(key);
+  if (!match || !statusUpdate[match[1]]) {
+    return;
+  }
+  statusUpdate[match[1]](status, value);
+}
+function textFileChange(input, { files }) {
+  const line = input.trim().match(/^(.+)\s+\|\s+(\d+)(\s+[+\-]+)?$/);
+  if (line) {
+    var alterations = (line[3] || "").trim();
+    files.push({
+      file: line[1].trim(),
+      changes: parseInt(line[2], 10),
+      insertions: alterations.replace(/-/g, "").length,
+      deletions: alterations.replace(/\+/g, "").length,
+      binary: false
+    });
+    return true;
+  }
+  return false;
+}
+function binaryFileChange(input, { files }) {
+  const line = input.match(/^(.+) \|\s+Bin ([0-9.]+) -> ([0-9.]+) ([a-z]+)$/);
+  if (line) {
+    files.push({
+      file: line[1].trim(),
+      before: +line[2],
+      after: +line[3],
+      binary: true
+    });
+    return true;
+  }
+  return false;
+}
+var statusUpdate;
 var init_parse_diff_summary = __esm({
   "src/lib/parsers/parse-diff-summary.ts"() {
-    init_log_format();
     init_DiffSummary();
-    init_utils();
-    statParser = [
-      new LineParser(/(.+)\s+\|\s+(\d+)(\s+[+\-]+)?$/, (result, [file, changes, alterations = ""]) => {
-        result.files.push({
-          file: file.trim(),
-          changes: asNumber(changes),
-          insertions: alterations.replace(/[^+]/g, "").length,
-          deletions: alterations.replace(/[^-]/g, "").length,
-          binary: false
-        });
-      }),
-      new LineParser(/(.+) \|\s+Bin ([0-9.]+) -> ([0-9.]+) ([a-z]+)/, (result, [file, before, after]) => {
-        result.files.push({
-          file: file.trim(),
-          before: asNumber(before),
-          after: asNumber(after),
-          binary: true
-        });
-      }),
-      new LineParser(/(\d+) files? changed\s*((?:, \d+ [^,]+){0,2})/, (result, [changed, summary]) => {
-        const inserted = /(\d+) i/.exec(summary);
-        const deleted = /(\d+) d/.exec(summary);
-        result.changed = asNumber(changed);
-        result.insertions = asNumber(inserted == null ? void 0 : inserted[1]);
-        result.deletions = asNumber(deleted == null ? void 0 : deleted[1]);
-      })
-    ];
-    numStatParser = [
-      new LineParser(/(\d+)\t(\d+)\t(.+)$/, (result, [changesInsert, changesDelete, file]) => {
-        const insertions = asNumber(changesInsert);
-        const deletions = asNumber(changesDelete);
-        result.changed++;
-        result.insertions += insertions;
-        result.deletions += deletions;
-        result.files.push({
-          file,
-          changes: insertions + deletions,
-          insertions,
-          deletions,
-          binary: false
-        });
-      }),
-      new LineParser(/-\t-\t(.+)$/, (result, [file]) => {
-        result.changed++;
-        result.files.push({
-          file,
-          after: 0,
-          before: 0,
-          binary: true
-        });
-      })
-    ];
-    nameOnlyParser = [
-      new LineParser(/(.+)$/, (result, [file]) => {
-        result.changed++;
-        result.files.push({
-          file,
-          changes: 0,
-          insertions: 0,
-          deletions: 0,
-          binary: false
-        });
-      })
-    ];
-    nameStatusParser = [
-      new LineParser(/([ACDMRTUXB])\s*(.+)$/, (result, [_status, file]) => {
-        result.changed++;
-        result.files.push({
-          file,
-          changes: 0,
-          insertions: 0,
-          deletions: 0,
-          binary: false
-        });
-      })
-    ];
-    diffSummaryParsers = {
-      ["" /* NONE */]: statParser,
-      ["--stat" /* STAT */]: statParser,
-      ["--numstat" /* NUM_STAT */]: numStatParser,
-      ["--name-status" /* NAME_STATUS */]: nameStatusParser,
-      ["--name-only" /* NAME_ONLY */]: nameOnlyParser
+    statusUpdate = {
+      file(status, value) {
+        status.changed = value;
+      },
+      deletion(status, value) {
+        status.deletions = value;
+      },
+      insertion(status, value) {
+        status.insertions = value;
+      }
     };
   }
 });
@@ -1697,8 +1654,7 @@ function lineBuilder(tokens, fields) {
     return line;
   }, /* @__PURE__ */ Object.create({ diff: null }));
 }
-function createListLogSummaryParser(splitter = SPLITTER, fields = defaultFieldNames, logFormat = "" /* NONE */) {
-  const parseDiffResult = getDiffParser(logFormat);
+function createListLogSummaryParser(splitter = SPLITTER, fields = defaultFieldNames) {
   return function(stdOut) {
     const all = toLinesWithContent(stdOut, true, START_BOUNDARY).map(function(item) {
       const lineDetail = item.trim().split(COMMIT_BOUNDARY);
@@ -1720,7 +1676,6 @@ var init_parse_list_log_summary = __esm({
   "src/lib/parsers/parse-list-log-summary.ts"() {
     init_utils();
     init_parse_diff_summary();
-    init_log_format();
     START_BOUNDARY = "\xF2\xF2\xF2\xF2\xF2\xF2 ";
     COMMIT_BOUNDARY = " \xF2\xF2";
     SPLITTER = " \xF2 ";
@@ -1728,43 +1683,6 @@ var init_parse_list_log_summary = __esm({
   }
 });
 
-// src/lib/tasks/diff.ts
-var diff_exports = {};
-__export(diff_exports, {
-  diffSummaryTask: () => diffSummaryTask,
-  validateLogFormatConfig: () => validateLogFormatConfig
-});
-function diffSummaryTask(customArgs) {
-  let logFormat = logFormatFromCommand(customArgs);
-  const commands = ["diff"];
-  if (logFormat === "" /* NONE */) {
-    logFormat = "--stat" /* STAT */;
-    commands.push("--stat=4096");
-  }
-  commands.push(...customArgs);
-  return validateLogFormatConfig(commands) || {
-    commands,
-    format: "utf-8",
-    parser: getDiffParser(logFormat)
-  };
-}
-function validateLogFormatConfig(customArgs) {
-  const flags = customArgs.filter(isLogFormat);
-  if (flags.length > 1) {
-    return configurationErrorTask(`Summary flags are mutually exclusive - pick one of ${flags.join(",")}`);
-  }
-  if (flags.length && customArgs.includes("-z")) {
-    return configurationErrorTask(`Summary flag ${flags} parsing is not compatible with null termination option '-z'`);
-  }
-}
-var init_diff = __esm({
-  "src/lib/tasks/diff.ts"() {
-    init_log_format();
-    init_parse_diff_summary();
-    init_task();
-  }
-});
-
 // src/lib/tasks/log.ts
 function prettyFormat(format, splitter) {
   const fields = [];
@@ -1825,19 +1743,17 @@ function parseLogOptions(opt = {}, customArgs = []) {
   };
 }
 function logTask(splitter, fields, customArgs) {
-  const parser3 = createListLogSummaryParser(splitter, fields, logFormatFromCommand(customArgs));
   return {
     commands: ["log", ...customArgs],
     format: "utf-8",
-    parser: parser3
+    parser: createListLogSummaryParser(splitter, fields)
   };
 }
 function log_default() {
   return {
     log(...rest) {
       const next = trailingFunctionArgument(arguments);
-      const options = parseLogOptions(trailingOptionsArgument(arguments), filterType(arguments[0], filterArray));
-      const task = rejectDeprecatedSignatures(...rest) || validateLogFormatConfig(options.commands) || createLogTask(options);
+      const task = rejectDeprecatedSignatures(...rest) || createLogTask(parseLogOptions(trailingOptionsArgument(arguments), filterType(arguments[0], filterArray)));
       return this._runTask(task, next);
     }
   };
@@ -1851,11 +1767,9 @@ function log_default() {
 var excludeOptions;
 var init_log = __esm({
   "src/lib/tasks/log.ts"() {
-    init_log_format();
     init_parse_list_log_summary();
     init_utils();
     init_task();
-    init_diff();
     excludeOptions = /* @__PURE__ */ ((excludeOptions2) => {
       excludeOptions2[excludeOptions2["--pretty"] = 0] = "--pretty";
       excludeOptions2[excludeOptions2["max-count"] = 1] = "max-count";
@@ -2032,7 +1946,7 @@ var init_parse_remote_messages = __esm({
 
 // src/lib/parsers/parse-pull.ts
 function parsePullErrorResult(stdOut, stdErr) {
-  const pullError = parseStringResponse(new PullFailedSummary(), errorParsers, [stdOut, stdErr]);
+  const pullError = parseStringResponse(new PullFailedSummary(), errorParsers, stdOut, stdErr);
   return pullError.message && pullError;
 }
 var FILE_UPDATE_REGEX, SUMMARY_REGEX, ACTION_REGEX, parsers3, errorParsers, parsePullDetail, parsePullResult;
@@ -2079,7 +1993,7 @@ var init_parse_pull = __esm({
       })
     ];
     parsePullDetail = (stdOut, stdErr) => {
-      return parseStringResponse(new PullSummary(), parsers3, [stdOut, stdErr]);
+      return parseStringResponse(new PullSummary(), parsers3, stdOut, stdErr);
     };
     parsePullResult = (stdOut, stdErr) => {
       return Object.assign(new PullSummary(), parsePullDetail(stdOut, stdErr), parseRemoteMessages(stdOut, stdErr));
@@ -2203,7 +2117,7 @@ var init_parse_push = __esm({
       return __spreadValues(__spreadValues({}, pushDetail), responseDetail);
     };
     parsePushDetail = (stdOut, stdErr) => {
-      return parseStringResponse({ pushed: [] }, parsers5, [stdOut, stdErr]);
+      return parseStringResponse({ pushed: [] }, parsers5, stdOut, stdErr);
     };
   }
 });
@@ -2622,7 +2536,7 @@ var init_parse_branch_delete = __esm({
       })
     ];
     parseBranchDeletions = (stdOut, stdErr) => {
-      return parseStringResponse(new BranchDeletionBatch(), parsers7, [stdOut, stdErr]);
+      return parseStringResponse(new BranchDeletionBatch(), parsers7, stdOut, stdErr);
     };
   }
 });
@@ -2638,15 +2552,14 @@ var init_BranchSummary = __esm({
         this.current = "";
         this.detached = false;
       }
-      push(status, detached, name, commit, label) {
-        if (status === "*" /* CURRENT */) {
+      push(current, detached, name, commit, label) {
+        if (current) {
           this.detached = detached;
           this.current = name;
         }
         this.all.push(name);
         this.branches[name] = {
-          current: status === "*" /* CURRENT */,
-          linkedWorkTree: status === "+" /* LINKED */,
+          current,
           name,
           commit,
           label
@@ -2657,9 +2570,6 @@ var init_BranchSummary = __esm({
 });
 
 // src/lib/parsers/parse-branch.ts
-function branchStatus(input) {
-  return input ? input.charAt(0) : "";
-}
 function parseBranchSummary(stdOut) {
   return parseStringResponse(new BranchSummaryResult(), parsers8, stdOut);
 }
@@ -2669,11 +2579,11 @@ var init_parse_branch = __esm({
     init_BranchSummary();
     init_utils();
     parsers8 = [
-      new LineParser(/^([*+]\s)?\((?:HEAD )?detached (?:from|at) (\S+)\)\s+([a-z0-9]+)\s(.*)$/, (result, [current, name, commit, label]) => {
-        result.push(branchStatus(current), true, name, commit, label);
+      new LineParser(/^(\*\s)?\((?:HEAD )?detached (?:from|at) (\S+)\)\s+([a-z0-9]+)\s(.*)$/, (result, [current, name, commit, label]) => {
+        result.push(!!current, true, name, commit, label);
       }),
-      new LineParser(/^([*+]\s)?(\S+)\s+([a-z0-9]+)\s?(.*)$/s, (result, [current, name, commit, label]) => {
-        result.push(branchStatus(current), false, name, commit, label);
+      new LineParser(/^(\*\s)?(\S+)\s+([a-z0-9]+)\s?(.*)$/s, (result, [current, name, commit, label]) => {
+        result.push(!!current, false, name, commit, label);
       })
     ];
   }
@@ -2818,6 +2728,26 @@ var init_clone = __esm({
   }
 });
 
+// src/lib/tasks/diff.ts
+var diff_exports = {};
+__export(diff_exports, {
+  diffSummaryTask: () => diffSummaryTask
+});
+function diffSummaryTask(customArgs) {
+  return {
+    commands: ["diff", "--stat=4096", ...customArgs],
+    format: "utf-8",
+    parser(stdOut) {
+      return parseDiffResult(stdOut);
+    }
+  };
+}
+var init_diff = __esm({
+  "src/lib/tasks/diff.ts"() {
+    init_parse_diff_summary();
+  }
+});
+
 // src/lib/parsers/parse-fetch.ts
 function parseFetchResult(stdOut, stdErr) {
   const result = {
@@ -2826,7 +2756,7 @@ function parseFetchResult(stdOut, stdErr) {
     branches: [],
     tags: []
   };
-  return parseStringResponse(result, parsers9, [stdOut, stdErr]);
+  return parseStringResponse(result, parsers9, stdOut, stdErr);
 }
 var parsers9;
 var init_parse_fetch = __esm({
@@ -3034,19 +2964,16 @@ __export(stash_list_exports, {
 });
 function stashListTask(opt = {}, customArgs) {
   const options = parseLogOptions(opt);
-  const commands = ["stash", "list", ...options.commands, ...customArgs];
-  const parser3 = createListLogSummaryParser(options.splitter, options.fields, logFormatFromCommand(commands));
-  return validateLogFormatConfig(commands) || {
-    commands,
+  const parser3 = createListLogSummaryParser(options.splitter, options.fields);
+  return {
+    commands: ["stash", "list", ...options.commands, ...customArgs],
     format: "utf-8",
     parser: parser3
   };
 }
 var init_stash_list = __esm({
   "src/lib/tasks/stash-list.ts"() {
-    init_log_format();
     init_parse_list_log_summary();
-    init_diff();
     init_log();
   }
 });
@@ -3854,7 +3781,6 @@ function toError(error) {
 }
 
 // src/esm.mjs
-var simpleGit = gitInstanceFactory;
 var esm_default = gitInstanceFactory;
 export {
   CheckRepoActions,
@@ -3868,7 +3794,6 @@ export {
   TaskConfigurationError,
   esm_default as default,
   gitP,
-  grepQueryBuilder,
-  simpleGit
+  grepQueryBuilder
 };
 //# sourceMappingURL=index.js.map
diff --git a/node_modules/simple-git/dist/esm/index.js.map b/node_modules/simple-git/dist/esm/index.js.map
index dba5dc5..731ce16 100644
--- a/node_modules/simple-git/dist/esm/index.js.map
+++ b/node_modules/simple-git/dist/esm/index.js.map
@@ -1,7 +1,7 @@
 {
   "version": 3,
-  "sources": ["../../src/lib/errors/git-error.ts", "../../src/lib/errors/git-response-error.ts", "../../src/lib/errors/task-configuration-error.ts", "../../src/lib/utils/util.ts", "../../src/lib/utils/argument-filters.ts", "../../src/lib/utils/exit-codes.ts", "../../src/lib/utils/git-output-streams.ts", "../../src/lib/utils/line-parser.ts", "../../src/lib/utils/simple-git-options.ts", "../../src/lib/utils/task-options.ts", "../../src/lib/utils/task-parser.ts", "../../src/lib/utils/index.ts", "../../src/lib/tasks/check-is-repo.ts", "../../src/lib/responses/CleanSummary.ts", "../../src/lib/tasks/task.ts", "../../src/lib/tasks/clean.ts", "../../src/lib/responses/ConfigList.ts", "../../src/lib/tasks/config.ts", "../../src/lib/tasks/grep.ts", "../../src/lib/tasks/reset.ts", "../../src/lib/git-logger.ts", "../../src/lib/runners/tasks-pending-queue.ts", "../../src/lib/runners/git-executor-chain.ts", "../../src/lib/runners/git-executor.ts", "../../src/lib/task-callback.ts", "../../src/lib/tasks/change-working-directory.ts", "../../src/lib/parsers/parse-commit.ts", "../../src/lib/tasks/commit.ts", "../../src/lib/tasks/hash-object.ts", "../../src/lib/responses/InitSummary.ts", "../../src/lib/tasks/init.ts", "../../src/lib/args/log-format.ts", "../../src/lib/responses/DiffSummary.ts", "../../src/lib/parsers/parse-diff-summary.ts", "../../src/lib/parsers/parse-list-log-summary.ts", "../../src/lib/tasks/diff.ts", "../../src/lib/tasks/log.ts", "../../src/lib/responses/MergeSummary.ts", "../../src/lib/responses/PullSummary.ts", "../../src/lib/parsers/parse-remote-objects.ts", "../../src/lib/parsers/parse-remote-messages.ts", "../../src/lib/parsers/parse-pull.ts", "../../src/lib/parsers/parse-merge.ts", "../../src/lib/tasks/merge.ts", "../../src/lib/parsers/parse-push.ts", "../../src/lib/tasks/push.ts", "../../src/lib/responses/FileStatusSummary.ts", "../../src/lib/responses/StatusSummary.ts", "../../src/lib/tasks/status.ts", "../../src/lib/simple-git-api.ts", "../../src/lib/runners/scheduler.ts", "../../src/lib/tasks/apply-patch.ts", "../../src/lib/responses/BranchDeleteSummary.ts", "../../src/lib/parsers/parse-branch-delete.ts", "../../src/lib/responses/BranchSummary.ts", "../../src/lib/parsers/parse-branch.ts", "../../src/lib/tasks/branch.ts", "../../src/lib/responses/CheckIgnore.ts", "../../src/lib/tasks/check-ignore.ts", "../../src/lib/tasks/clone.ts", "../../src/lib/parsers/parse-fetch.ts", "../../src/lib/tasks/fetch.ts", "../../src/lib/parsers/parse-move.ts", "../../src/lib/tasks/move.ts", "../../src/lib/tasks/pull.ts", "../../src/lib/responses/GetRemoteSummary.ts", "../../src/lib/tasks/remote.ts", "../../src/lib/tasks/stash-list.ts", "../../src/lib/tasks/sub-module.ts", "../../src/lib/responses/TagList.ts", "../../src/lib/tasks/tag.ts", "../../src/git.js", "../../src/lib/errors/git-construct-error.ts", "../../src/lib/api.ts", "../../src/lib/errors/git-plugin-error.ts", "../../src/lib/plugins/command-config-prefixing-plugin.ts", "../../src/lib/plugins/completion-detection.plugin.ts", "../../src/lib/plugins/error-detection.plugin.ts", "../../src/lib/plugins/plugin-store.ts", "../../src/lib/plugins/progress-monitor-plugin.ts", "../../src/lib/plugins/spawn-options-plugin.ts", "../../src/lib/plugins/timout-plugin.ts", "../../src/lib/git-factory.ts", "../../src/lib/runners/promise-wrapped.ts", "../../src/esm.mjs"],
-  "sourcesContent": ["import type { SimpleGitTask } from '../types';\n\n/**\n * The `GitError` is thrown when the underlying `git` process throws a\n * fatal exception (eg an `ENOENT` exception when attempting to use a\n * non-writable directory as the root for your repo), and acts as the\n * base class for more specific errors thrown by the parsing of the\n * git response or errors in the configuration of the task about to\n * be run.\n *\n * When an exception is thrown, pending tasks in the same instance will\n * not be executed. The recommended way to run a series of tasks that\n * can independently fail without needing to prevent future tasks from\n * running is to catch them individually:\n *\n * ```typescript\n import { gitP, SimpleGit, GitError, PullResult } from 'simple-git';\n\n function catchTask (e: GitError) {\n   return e.\n }\n\n const git = gitP(repoWorkingDir);\n const pulled: PullResult | GitError = await git.pull().catch(catchTask);\n const pushed: string | GitError = await git.pushTags().catch(catchTask);\n ```\n */\nexport class GitError extends Error {\n\n   constructor (\n      public task?: SimpleGitTask<any>,\n      message?: string,\n   ) {\n      super(message);\n      Object.setPrototypeOf(this, new.target.prototype);\n   }\n\n}\n", "import { GitError } from './git-error';\n\n/**\n * The `GitResponseError` is the wrapper for a parsed response that is treated as\n * a fatal error, for example attempting a `merge` can leave the repo in a corrupted\n * state when there are conflicts so the task will reject rather than resolve.\n *\n * For example, catching the merge conflict exception:\n *\n * ```typescript\n import { gitP, SimpleGit, GitResponseError, MergeSummary } from 'simple-git';\n\n const git = gitP(repoRoot);\n const mergeOptions: string[] = ['--no-ff', 'other-branch'];\n const mergeSummary: MergeSummary = await git.merge(mergeOptions)\n      .catch((e: GitResponseError<MergeSummary>) => e.git);\n\n if (mergeSummary.failed) {\n   // deal with the error\n }\n ```\n */\nexport class GitResponseError<T = any> extends GitError {\n\n   constructor(\n      /**\n       * `.git` access the parsed response that is treated as being an error\n       */\n      public readonly git: T,\n      message?: string,\n   ) {\n      super(undefined, message || String(git));\n   }\n\n}\n", "import { GitError } from './git-error';\n\n/**\n * The `TaskConfigurationError` is thrown when a command was incorrectly\n * configured. An error of this kind means that no attempt was made to\n * run your command through the underlying `git` binary.\n *\n * Check the `.message` property for more detail on why your configuration\n * resulted in an error.\n */\nexport class TaskConfigurationError extends GitError {\n\n   constructor (\n      message?: string,\n   ) {\n      super(undefined, message);\n   }\n\n}\n", "import { exists, FOLDER } from '@kwsites/file-exists';\nimport { Maybe } from '../types';\n\nexport const NULL = '\\0';\n\nexport const NOOP: (...args: any[]) => void = () => {\n};\n\n/**\n * Returns either the source argument when it is a `Function`, or the default\n * `NOOP` function constant\n */\nexport function asFunction<T extends () => any>(source: T | any): T {\n   return typeof source === 'function' ? source : NOOP;\n}\n\n/**\n * Determines whether the supplied argument is both a function, and is not\n * the `NOOP` function.\n */\nexport function isUserFunction<T extends Function>(source: T | any): source is T {\n   return (typeof source === 'function' && source !== NOOP);\n}\n\nexport function splitOn(input: string, char: string): [string, string] {\n   const index = input.indexOf(char);\n   if (index <= 0) {\n      return [input, ''];\n   }\n\n   return [\n      input.substr(0, index),\n      input.substr(index + 1),\n   ];\n}\n\nexport function first<T extends any[]>(input: T, offset?: number): Maybe<T[number]>;\nexport function first<T extends IArguments>(input: T, offset?: number): Maybe<unknown>;\nexport function first(input: any[] | IArguments, offset = 0): Maybe<unknown> {\n   return isArrayLike(input) && input.length > offset ? input[offset] : undefined;\n}\n\nexport function last<T extends any[]>(input: T, offset?: number): Maybe<T[number]>;\nexport function last<T extends IArguments>(input: T, offset?: number): Maybe<unknown>;\nexport function last<T>(input: T, offset?: number): Maybe<unknown>;\nexport function last(input: unknown, offset = 0) {\n   if (isArrayLike(input) && input.length > offset) {\n      return input[input.length - 1 - offset];\n   }\n}\n\ntype ArrayLike<T = any> = T[] | IArguments | { [index: number]: T; length: number };\n\nfunction isArrayLike(input: any): input is ArrayLike {\n   return !!(input && typeof input.length === 'number');\n}\n\nexport function toLinesWithContent(input = '', trimmed = true, separator = '\\n'): string[] {\n   return input.split(separator)\n      .reduce((output, line) => {\n         const lineContent = trimmed ? line.trim() : line;\n         if (lineContent) {\n            output.push(lineContent);\n         }\n         return output;\n      }, [] as string[]);\n}\n\ntype LineWithContentCallback<T = void> = (line: string) => T;\n\nexport function forEachLineWithContent<T>(input: string, callback: LineWithContentCallback<T>): T[] {\n   return toLinesWithContent(input, true).map(line => callback(line));\n}\n\nexport function folderExists(path: string): boolean {\n   return exists(path, FOLDER);\n}\n\n/**\n * Adds `item` into the `target` `Array` or `Set` when it is not already present and returns the `item`.\n */\nexport function append<T>(target: T[] | Set<T>, item: T): typeof item {\n   if (Array.isArray(target)) {\n      if (!target.includes(item)) {\n         target.push(item);\n      }\n   } else {\n      target.add(item);\n   }\n   return item;\n}\n\n/**\n * Adds `item` into the `target` `Array` when it is not already present and returns the `target`.\n */\nexport function including<T>(target: T[], item: T): typeof target {\n   if (Array.isArray(target) && !target.includes(item)) {\n      target.push(item);\n   }\n\n   return target;\n}\n\nexport function remove<T>(target: Set<T> | T[], item: T): T {\n   if (Array.isArray(target)) {\n      const index = target.indexOf(item);\n      if (index >= 0) {\n         target.splice(index, 1);\n      }\n   } else {\n      target.delete(item);\n   }\n   return item;\n}\n\nexport const objectToString = Object.prototype.toString.call.bind(Object.prototype.toString) as (input: any) => string;\n\nexport function asArray<T>(source: T | T[]): T[] {\n   return Array.isArray(source) ? source : [source];\n}\n\nexport function asStringArray<T>(source: T | T[]): string[] {\n   return asArray(source).map(String);\n}\n\nexport function asNumber(source: string | null | undefined, onNaN = 0) {\n   if (source == null) {\n      return onNaN;\n   }\n\n   const num = parseInt(source, 10);\n   return isNaN(num) ? onNaN : num;\n}\n\nexport function prefixedArray<T>(input: T[], prefix: T): T[] {\n   const output: T[] = [];\n   for (let i = 0, max = input.length; i < max; i++) {\n      output.push(prefix, input[i]);\n   }\n   return output;\n}\n\nexport function bufferToString(input: Buffer | Buffer[]): string {\n   return (Array.isArray(input) ? Buffer.concat(input) : input).toString('utf-8');\n}\n\n/**\n * Get a new object from a source object with only the listed properties.\n */\nexport function pick(source: Record<string, any>, properties: string[]) {\n   return Object.assign({}, ...properties.map((property) => property in source ? {[property]: source[property]} : {}));\n}\n\nexport function delay(duration = 0): Promise<void> {\n   return new Promise(done => setTimeout(done, duration));\n}\n", "import { Maybe, Options, Primitives } from '../types';\nimport { objectToString } from './util';\n\nexport interface ArgumentFilterPredicate<T> {\n   (input: any): input is T;\n}\n\nexport function filterType<T, K>(input: K, filter: ArgumentFilterPredicate<T>): K extends T ? T : undefined;\nexport function filterType<T, K>(input: K, filter: ArgumentFilterPredicate<T>, def: T): T;\nexport function filterType<T, K>(input: K, filter: ArgumentFilterPredicate<T>, def?: T): Maybe<T> {\n   if (filter(input)) {\n      return input;\n   }\n   return (arguments.length > 2) ? def : undefined\n}\n\nexport const filterArray: ArgumentFilterPredicate<Array<any>> = (input): input is Array<any> => {\n   return Array.isArray(input);\n}\n\nexport function filterPrimitives(input: unknown, omit?: Array<'boolean' | 'string' | 'number'>): input is Primitives {\n   return /number|string|boolean/.test(typeof input) && (!omit || !omit.includes((typeof input) as 'boolean' | 'string' | 'number'));\n}\n\nexport const filterString: ArgumentFilterPredicate<string> = (input): input is string => {\n   return typeof input === 'string';\n};\n\nexport const filterStringArray: ArgumentFilterPredicate<string[]> = (input): input is string[] => {\n   return Array.isArray(input) && input.every(filterString);\n};\n\nexport const filterStringOrStringArray: ArgumentFilterPredicate<string | string[]> = (input): input is string | string[] => {\n   return filterString(input) || (Array.isArray(input) && input.every(filterString));\n};\n\nexport function filterPlainObject<T extends Options>(input: T | unknown): input is T;\nexport function filterPlainObject<T extends Object>(input: T | unknown): input is T {\n   return !!input && objectToString(input) === '[object Object]';\n}\n\nexport function filterFunction(input: unknown): input is Function {\n   return typeof input === 'function';\n}\n\nexport const filterHasLength: ArgumentFilterPredicate<{ length: number }> = (input): input is { length: number } => {\n   if (input == null || 'number|boolean|function'.includes(typeof input)) {\n      return false;\n   }\n   return Array.isArray(input) || typeof input === 'string' || typeof input.length === 'number';\n}\n", "/**\n * Known process exit codes used by the task parsers to determine whether an error\n * was one they can automatically handle\n */\nexport enum ExitCodes {\n   SUCCESS,\n   ERROR,\n   UNCLEAN = 128,\n}\n", "import { TaskResponseFormat } from '../types';\n\nexport class GitOutputStreams<T extends TaskResponseFormat = Buffer> {\n\n   constructor(public readonly stdOut: T, public readonly stdErr: T) {\n   }\n\n   asStrings(): GitOutputStreams<string> {\n      return new GitOutputStreams(this.stdOut.toString('utf8'), this.stdErr.toString('utf8'));\n   }\n}\n", "export class LineParser<T> {\n\n   protected matches: string[] = [];\n\n   private _regExp: RegExp[];\n\n   constructor(\n      regExp: RegExp | RegExp[],\n      useMatches?: (target: T, match: string[]) => boolean | void,\n   ) {\n      this._regExp = Array.isArray(regExp) ? regExp : [regExp];\n      if (useMatches) {\n         this.useMatches = useMatches;\n      }\n   }\n\n   parse = (line: (offset: number) => (string | undefined), target: T): boolean => {\n      this.resetMatches();\n\n      if (!this._regExp.every((reg, index) => this.addMatch(reg, index, line(index)))) {\n         return false;\n      }\n\n      return this.useMatches(target, this.prepareMatches()) !== false;\n   }\n\n   // @ts-ignore\n   protected useMatches(target: T, match: string[]): boolean | void {\n      throw new Error(`LineParser:useMatches not implemented`);\n   }\n\n   protected resetMatches() {\n      this.matches.length = 0;\n   }\n\n   protected prepareMatches() {\n      return this.matches;\n   }\n\n   protected addMatch(reg: RegExp, index: number, line?: string) {\n      const matched = line && reg.exec(line);\n      if (matched) {\n         this.pushMatch(index, matched);\n      }\n\n      return !!matched;\n   }\n\n   protected pushMatch(_index: number, matched: string[]) {\n      this.matches.push(...matched.slice(1));\n   }\n\n}\n\nexport class RemoteLineParser<T> extends LineParser<T> {\n\n   protected addMatch(reg: RegExp, index: number, line?: string): boolean {\n      return /^remote:\\s/.test(String(line)) && super.addMatch(reg, index, line);\n   }\n\n   protected pushMatch(index: number, matched: string[]) {\n      if (index > 0 || matched.length > 1) {\n         super.pushMatch(index, matched);\n      }\n   }\n\n}\n", "import { SimpleGitOptions } from '../types';\n\nconst defaultOptions: Omit<SimpleGitOptions, 'baseDir'> = {\n   binary: 'git',\n   maxConcurrentProcesses: 5,\n   config: [],\n};\n\nexport function createInstanceConfig(...options: Array<Partial<SimpleGitOptions> | undefined>): SimpleGitOptions {\n   const baseDir = process.cwd();\n   const config: SimpleGitOptions = Object.assign({baseDir, ...defaultOptions},\n      ...(options.filter(o => typeof o === 'object' && o))\n   );\n\n   config.baseDir = config.baseDir || baseDir;\n\n   return config;\n}\n", "import { filterArray, filterFunction, filterPlainObject, filterPrimitives, filterType } from './argument-filters';\nimport { asFunction, isUserFunction, last } from './util';\nimport { Maybe, Options, OptionsValues } from '../types';\n\nexport function appendTaskOptions<T extends Options = Options>(options: Maybe<T>, commands: string[] = []): string[] {\n   if (!filterPlainObject<Options>(options)) {\n      return commands;\n   }\n\n   return Object.keys(options).reduce((commands: string[], key: string) => {\n      const value: OptionsValues = options[key];\n\n      if (filterPrimitives(value, ['boolean'])) {\n         commands.push(key + '=' + value);\n      } else {\n         commands.push(key);\n      }\n\n      return commands;\n   }, commands);\n}\n\nexport function getTrailingOptions(args: IArguments, initialPrimitive = 0, objectOnly = false): string[] {\n   const command: string[] = [];\n\n   for (let i = 0, max = initialPrimitive < 0 ? args.length : initialPrimitive; i < max; i++) {\n      if ('string|number'.includes(typeof args[i])) {\n         command.push(String(args[i]));\n      }\n   }\n\n   appendTaskOptions(trailingOptionsArgument(args), command);\n   if (!objectOnly) {\n      command.push(...trailingArrayArgument(args));\n   }\n\n   return command;\n}\n\nfunction trailingArrayArgument(args: IArguments) {\n   const hasTrailingCallback = typeof last(args) === 'function';\n   return filterType(\n      last(args, hasTrailingCallback ? 1 : 0), filterArray, []\n   );\n}\n\n/**\n * Given any number of arguments, returns the trailing options argument, ignoring a trailing function argument\n * if there is one. When not found, the return value is null.\n */\nexport function trailingOptionsArgument(args: IArguments): Maybe<Options> {\n   const hasTrailingCallback = filterFunction(last(args));\n   return filterType(last(args, hasTrailingCallback ? 1 : 0), filterPlainObject);\n}\n\n/**\n * Returns either the source argument when it is a `Function`, or the default\n * `NOOP` function constant\n */\nexport function trailingFunctionArgument(args: unknown[] | IArguments | unknown, includeNoop = true): Maybe<(...args: any[]) => unknown> {\n   const callback = asFunction(last(args));\n   return includeNoop || isUserFunction(callback) ? callback : undefined;\n}\n", "import type { MaybeArray, TaskParser, TaskResponseFormat } from '../types';\nimport { GitOutputStreams } from './git-output-streams';\nimport { LineParser } from './line-parser';\nimport { asArray, toLinesWithContent } from './util';\n\nexport function callTaskParser<INPUT extends TaskResponseFormat, RESPONSE>(parser: TaskParser<INPUT, RESPONSE>, streams: GitOutputStreams<INPUT>) {\n   return parser(streams.stdOut, streams.stdErr);\n}\n\nexport function parseStringResponse<T>(result: T, parsers: LineParser<T>[], texts: MaybeArray<string>, trim = true): T {\n   asArray(texts).forEach(text => {\n      for (let lines = toLinesWithContent(text, trim), i = 0, max = lines.length; i < max; i++) {\n         const line = (offset = 0) => {\n            if ((i + offset) >= max) {\n               return;\n            }\n            return lines[i + offset];\n         }\n\n         parsers.some(({parse}) => parse(line, result));\n      }\n   });\n\n   return result;\n}\n", "\nexport * from './argument-filters';\nexport * from './exit-codes';\nexport * from './git-output-streams';\nexport * from './line-parser';\nexport * from './simple-git-options';\nexport * from './task-options';\nexport * from './task-parser';\nexport * from './util';\n", "import { ExitCodes } from '../utils';\nimport { Maybe, StringTask } from '../types';\n\nexport enum CheckRepoActions {\n   BARE = 'bare',\n   IN_TREE = 'tree',\n   IS_REPO_ROOT = 'root',\n}\n\nconst onError: StringTask<boolean>['onError'] = ({exitCode}, error, done, fail) => {\n   if (exitCode === ExitCodes.UNCLEAN && isNotRepoMessage(error)) {\n      return done(Buffer.from('false'));\n   }\n\n   fail(error);\n}\n\nconst parser: StringTask<boolean>['parser'] = (text) => {\n   return text.trim() === 'true';\n}\n\nexport function checkIsRepoTask(action: Maybe<CheckRepoActions>): StringTask<boolean> {\n   switch (action) {\n      case CheckRepoActions.BARE:\n         return checkIsBareRepoTask();\n      case CheckRepoActions.IS_REPO_ROOT:\n         return checkIsRepoRootTask();\n   }\n\n   const commands = ['rev-parse', '--is-inside-work-tree'];\n\n   return {\n      commands,\n      format: 'utf-8',\n      onError,\n      parser,\n   }\n}\n\n\nexport function checkIsRepoRootTask(): StringTask<boolean> {\n   const commands = ['rev-parse', '--git-dir'];\n\n   return {\n      commands,\n      format: 'utf-8',\n      onError,\n      parser(path) {\n         return /^\\.(git)?$/.test(path.trim());\n      },\n   }\n}\n\n\nexport function checkIsBareRepoTask(): StringTask<boolean> {\n   const commands = ['rev-parse', '--is-bare-repository'];\n\n   return {\n      commands,\n      format: 'utf-8',\n      onError,\n      parser,\n   }\n}\n\n\nfunction isNotRepoMessage(error: Error): boolean {\n   return /(Not a git repository|Kein Git-Repository)/i.test(String(error));\n}\n", "import { CleanSummary } from '../../../typings';\nimport { toLinesWithContent } from '../utils';\n\nexport class CleanResponse implements CleanSummary {\n\n   public paths: string[] = [];\n   public files: string[] = [];\n   public folders: string[] = [];\n\n   constructor(\n      public readonly dryRun: boolean,\n   ) {}\n\n}\n\nconst removalRegexp = /^[a-z]+\\s*/i;\nconst dryRunRemovalRegexp = /^[a-z]+\\s+[a-z]+\\s*/i;\nconst isFolderRegexp = /\\/$/;\n\nexport function cleanSummaryParser (dryRun: boolean, text: string): CleanSummary {\n   const summary = new CleanResponse(dryRun);\n   const regexp = dryRun ? dryRunRemovalRegexp : removalRegexp;\n\n   toLinesWithContent(text).forEach(line => {\n      const removed = line.replace(regexp, '');\n\n      summary.paths.push(removed);\n      (isFolderRegexp.test(removed) ? summary.folders : summary.files).push(removed);\n   });\n\n   return summary;\n}\n", "import { TaskConfigurationError } from '../errors/task-configuration-error';\nimport type { BufferTask, EmptyTaskParser, SimpleGitTask, StringTask } from '../types';\n\nexport const EMPTY_COMMANDS: [] = [];\n\nexport type EmptyTask = {\n   commands: typeof EMPTY_COMMANDS;\n   format: 'empty',\n   parser: EmptyTaskParser;\n   onError?: undefined;\n};\n\n\nexport function adhocExecTask(parser: EmptyTaskParser): EmptyTask {\n   return {\n      commands: EMPTY_COMMANDS,\n      format: 'empty',\n      parser,\n   };\n}\n\nexport function configurationErrorTask(error: Error | string): EmptyTask {\n   return {\n      commands: EMPTY_COMMANDS,\n      format: 'empty',\n      parser() {\n         throw typeof error === 'string' ? new TaskConfigurationError(error) : error;\n      }\n   }\n}\n\nexport function straightThroughStringTask(commands: string[], trimmed = false): StringTask<string> {\n   return {\n      commands,\n      format: 'utf-8',\n      parser(text) {\n         return trimmed ? String(text).trim() : text;\n      },\n   }\n}\n\nexport function straightThroughBufferTask(commands: string[]): BufferTask<any> {\n   return {\n      commands,\n      format: 'buffer',\n      parser(buffer) {\n         return buffer;\n      },\n   }\n}\n\nexport function isBufferTask<R>(task: SimpleGitTask<R>): task is BufferTask<R> {\n   return task.format === 'buffer';\n}\n\nexport function isEmptyTask<R>(task: SimpleGitTask<R>): task is EmptyTask {\n   return task.format === 'empty' || !task.commands.length;\n}\n", "import { CleanSummary } from '../../../typings';\nimport { cleanSummaryParser } from '../responses/CleanSummary';\nimport { Maybe, StringTask } from '../types';\nimport { asStringArray } from '../utils';\nimport { configurationErrorTask } from './task';\n\nexport const CONFIG_ERROR_INTERACTIVE_MODE = 'Git clean interactive mode is not supported';\nexport const CONFIG_ERROR_MODE_REQUIRED = 'Git clean mode parameter (\"n\" or \"f\") is required';\nexport const CONFIG_ERROR_UNKNOWN_OPTION = 'Git clean unknown option found in: ';\n\n/**\n * All supported option switches available for use in a `git.clean` operation\n */\nexport enum CleanOptions {\n   DRY_RUN = 'n',\n   FORCE = 'f',\n   IGNORED_INCLUDED = 'x',\n   IGNORED_ONLY = 'X',\n   EXCLUDING = 'e',\n   QUIET = 'q',\n   RECURSIVE = 'd',\n}\n\n/**\n * The two modes `git.clean` can run in - one of these must be supplied in order\n * for the command to not throw a `TaskConfigurationError`\n */\nexport type CleanMode = CleanOptions.FORCE | CleanOptions.DRY_RUN;\n\nconst CleanOptionValues: Set<string> = new Set(['i', ...asStringArray(Object.values(CleanOptions as any))]);\n\nexport function cleanWithOptionsTask(mode: CleanMode | string, customArgs: string[]) {\n   const {cleanMode, options, valid} = getCleanOptions(mode);\n\n   if (!cleanMode) {\n      return configurationErrorTask(CONFIG_ERROR_MODE_REQUIRED);\n   }\n\n   if (!valid.options) {\n      return configurationErrorTask(CONFIG_ERROR_UNKNOWN_OPTION + JSON.stringify(mode));\n   }\n\n   options.push(...customArgs);\n\n   if (options.some(isInteractiveMode)) {\n      return configurationErrorTask(CONFIG_ERROR_INTERACTIVE_MODE);\n   }\n\n   return cleanTask(cleanMode, options);\n}\n\nexport function cleanTask(mode: CleanMode, customArgs: string[]): StringTask<CleanSummary> {\n   const commands: string[] = ['clean', `-${mode}`, ...customArgs];\n\n   return {\n      commands,\n      format: 'utf-8',\n      parser(text: string): CleanSummary {\n         return cleanSummaryParser(mode === CleanOptions.DRY_RUN, text);\n      }\n   }\n}\n\nexport function isCleanOptionsArray (input: string[]): input is CleanOptions[] {\n   return Array.isArray(input) && input.every(test => CleanOptionValues.has(test));\n}\n\nfunction getCleanOptions(input: string) {\n   let cleanMode: Maybe<CleanMode>;\n   let options: string[] = [];\n   let valid = {cleanMode: false, options: true};\n\n   input.replace(/[^a-z]i/g, '').split('').forEach(char => {\n      if (isCleanMode(char)) {\n         cleanMode = char;\n         valid.cleanMode = true;\n      }\n      else {\n         valid.options = valid.options && isKnownOption(options[options.length] = (`-${char}`));\n      }\n   });\n\n   return {\n      cleanMode,\n      options,\n      valid,\n   }\n}\n\nfunction isCleanMode(cleanMode?: string): cleanMode is CleanMode {\n   return cleanMode === CleanOptions.FORCE || cleanMode === CleanOptions.DRY_RUN;\n}\n\nfunction isKnownOption(option: string): boolean {\n   return /^-[a-z]$/i.test(option) && CleanOptionValues.has(option.charAt(1));\n}\n\nfunction isInteractiveMode(option: string): boolean {\n   if (/^-[^\\-]/.test(option)) {\n      return option.indexOf('i') > 0;\n   }\n\n   return option === '--interactive';\n}\n", "import { ConfigGetResult, ConfigListSummary, ConfigValues } from '../../../typings';\nimport { last, splitOn } from '../utils';\n\nexport class ConfigList implements ConfigListSummary {\n\n   public files: string[] = [];\n   public values: { [fileName: string]: ConfigValues } = Object.create(null);\n\n   private _all: ConfigValues | undefined;\n\n   public get all(): ConfigValues {\n      if (!this._all) {\n         this._all = this.files.reduce((all: ConfigValues, file: string) => {\n            return Object.assign(all, this.values[file]);\n         }, {});\n      }\n\n      return this._all;\n   }\n\n   public addFile(file: string): ConfigValues {\n      if (!(file in this.values)) {\n         const latest = last(this.files);\n         this.values[file] = latest ? Object.create(this.values[latest]) : {}\n\n         this.files.push(file);\n      }\n\n      return this.values[file];\n   }\n\n   public addValue(file: string, key: string, value: string) {\n      const values = this.addFile(file);\n\n      if (!values.hasOwnProperty(key)) {\n         values[key] = value;\n      } else if (Array.isArray(values[key])) {\n         (values[key] as string[]).push(value);\n      } else {\n         values[key] = [values[key] as string, value];\n      }\n\n      this._all = undefined;\n   }\n\n}\n\nexport function configListParser(text: string): ConfigList {\n   const config = new ConfigList();\n\n   for (const item of configParser(text)) {\n      config.addValue(item.file, String(item.key), item.value);\n   }\n\n   return config;\n}\n\nexport function configGetParser(text: string, key: string): ConfigGetResult {\n   let value: string | null = null;\n   const values: string[] = [];\n   const scopes: Map<string, string[]> = new Map();\n\n   for (const item of configParser(text, key)) {\n      if (item.key !== key) {\n         continue;\n      }\n\n      values.push(value = item.value);\n\n      if (!scopes.has(item.file)) {\n         scopes.set(item.file, []);\n      }\n\n      scopes.get(item.file)!.push(value);\n   }\n\n   return {\n      key,\n      paths: Array.from(scopes.keys()),\n      scopes,\n      value,\n      values\n   };\n}\n\nfunction configFilePath(filePath: string): string {\n   return filePath.replace(/^(file):/, '');\n}\n\nfunction* configParser(text: string, requestedKey: string | null = null) {\n   const lines = text.split('\\0');\n\n   for (let i = 0, max = lines.length - 1; i < max;) {\n      const file = configFilePath(lines[i++]);\n\n      let value = lines[i++];\n      let key = requestedKey;\n\n      if (value.includes('\\n')) {\n         const line = splitOn(value, '\\n');\n         key = line[0];\n         value = line[1];\n      }\n\n      yield {file, key, value};\n   }\n}\n", "import { ConfigGetResult, ConfigListSummary, SimpleGit } from '../../../typings';\nimport { configGetParser, configListParser } from '../responses/ConfigList';\nimport { SimpleGitApi } from '../simple-git-api';\nimport { StringTask } from '../types';\nimport { trailingFunctionArgument } from '../utils';\n\nexport enum GitConfigScope {\n   system = 'system',\n   global = 'global',\n   local = 'local',\n   worktree = 'worktree',\n}\n\nfunction asConfigScope<T extends GitConfigScope | undefined>(scope: GitConfigScope | unknown, fallback: T): GitConfigScope | T {\n   if (typeof scope === 'string' && GitConfigScope.hasOwnProperty(scope)) {\n      return scope as GitConfigScope;\n   }\n   return fallback;\n}\n\nfunction addConfigTask(key: string, value: string, append: boolean, scope: GitConfigScope): StringTask<string> {\n   const commands: string[] = ['config', `--${scope}`];\n\n   if (append) {\n      commands.push('--add');\n   }\n\n   commands.push(key, value);\n\n   return {\n      commands,\n      format: 'utf-8',\n      parser(text: string): string {\n         return text;\n      }\n   }\n}\n\nfunction getConfigTask(key: string, scope?: GitConfigScope): StringTask<ConfigGetResult> {\n   const commands: string[] = ['config', '--null', '--show-origin', '--get-all', key];\n\n   if (scope) {\n      commands.splice(1, 0, `--${scope}`);\n   }\n\n   return {\n      commands,\n      format: 'utf-8',\n      parser(text) {\n         return configGetParser(text, key);\n      }\n   };\n}\n\nfunction listConfigTask(scope?: GitConfigScope): StringTask<ConfigListSummary> {\n   const commands = ['config', '--list', '--show-origin', '--null'];\n\n   if (scope) {\n      commands.push(`--${scope}`);\n   }\n\n   return {\n      commands,\n      format: 'utf-8',\n      parser(text: string) {\n         return configListParser(text);\n      },\n   }\n}\n\nexport default function (): Pick<SimpleGit, 'addConfig' | 'getConfig' | 'listConfig'> {\n   return {\n      addConfig(this: SimpleGitApi, key: string, value: string, ...rest: unknown[]) {\n         return this._runTask(\n            addConfigTask(key, value, rest[0] === true, asConfigScope(rest[1], GitConfigScope.local)),\n            trailingFunctionArgument(arguments),\n         );\n      },\n\n      getConfig(this: SimpleGitApi, key: string, scope?: GitConfigScope) {\n         return this._runTask(\n            getConfigTask(key, asConfigScope(scope, undefined)),\n            trailingFunctionArgument(arguments),\n         )\n      },\n\n      listConfig(this: SimpleGitApi, ...rest: unknown[]) {\n         return this._runTask(\n            listConfigTask(asConfigScope(rest[0], undefined)),\n            trailingFunctionArgument(arguments),\n         );\n      },\n   };\n}\n", "import { GrepResult, SimpleGit } from '../../../typings';\nimport { SimpleGitApi } from '../simple-git-api';\nimport {\n   asNumber,\n   forEachLineWithContent,\n   getTrailingOptions,\n   NULL,\n   prefixedArray,\n   trailingFunctionArgument\n} from '../utils';\n\nimport { configurationErrorTask } from './task';\n\nconst disallowedOptions = ['-h'];\n\nconst Query = Symbol('grepQuery');\n\nexport interface GitGrepQuery extends Iterable<string> {\n   /** Adds one or more terms to be grouped as an \"and\" to any other terms */\n   and(...and: string[]): this;\n\n   /** Adds one or more search terms - git.grep will \"or\" this to other terms */\n   param(...param: string[]): this;\n}\n\nclass GrepQuery implements GitGrepQuery {\n   private [Query]: string[] = [];\n\n   * [Symbol.iterator]() {\n      for (const query of this[Query]) {\n         yield query;\n      }\n   }\n\n   and(...and: string[]) {\n      and.length && this[Query].push('--and', '(', ...prefixedArray(and, '-e'), ')');\n      return this;\n   }\n\n   param(...param: string[]) {\n      this[Query].push(...prefixedArray(param, '-e'));\n      return this;\n   }\n}\n\n/**\n * Creates a new builder for a `git.grep` query with optional params\n */\nexport function grepQueryBuilder(...params: string[]): GitGrepQuery {\n   return new GrepQuery().param(...params);\n}\n\nfunction parseGrep(grep: string): GrepResult {\n   const paths: GrepResult['paths'] = new Set<string>();\n   const results: GrepResult['results'] = {};\n\n   forEachLineWithContent(grep, (input) => {\n      const [path, line, preview] = input.split(NULL);\n      paths.add(path);\n      (results[path] = results[path] || []).push({\n         line: asNumber(line),\n         path,\n         preview,\n      });\n   });\n\n   return {\n      paths,\n      results,\n   };\n}\n\nexport default function (): Pick<SimpleGit, 'grep'> {\n   return {\n      grep(this: SimpleGitApi, searchTerm: string | GitGrepQuery) {\n         const then = trailingFunctionArgument(arguments);\n         const options = getTrailingOptions(arguments);\n\n         for (const option of disallowedOptions) {\n            if (options.includes(option)) {\n               return this._runTask(\n                  configurationErrorTask(`git.grep: use of \"${option}\" is not supported.`),\n                  then,\n               );\n            }\n         }\n\n         if (typeof searchTerm === 'string') {\n            searchTerm = grepQueryBuilder().param(searchTerm);\n         }\n\n         const commands = ['grep', '--null', '-n', '--full-name', ...options, ...searchTerm];\n\n         return this._runTask({\n            commands,\n            format: 'utf-8',\n            parser(stdOut) {\n               return parseGrep(stdOut);\n            },\n         }, then);\n      }\n   }\n}\n", "import { straightThroughStringTask } from './task';\nimport { Maybe, OptionFlags, Options } from '../types';\n\nexport enum ResetMode {\n   MIXED = 'mixed',\n   SOFT = 'soft',\n   HARD = 'hard',\n   MERGE = 'merge',\n   KEEP = 'keep',\n}\n\nconst ResetModes = Array.from(Object.values(ResetMode));\n\nexport type ResetOptions = Options &\n   OptionFlags<'-q' | '--quiet' | '--no-quiet' | '--pathspec-from-nul'> &\n   OptionFlags<'--pathspec-from-file', string>;\n\nexport function resetTask(mode: Maybe<ResetMode>, customArgs: string[]) {\n   const commands: string[] = ['reset'];\n   if (isValidResetMode(mode)) {\n      commands.push(`--${mode}`);\n   }\n   commands.push(...customArgs);\n\n   return straightThroughStringTask(commands);\n}\n\nexport function getResetMode(mode: ResetMode | any): Maybe<ResetMode> {\n   if (isValidResetMode(mode)) {\n      return mode;\n   }\n\n   switch (typeof mode) {\n      case 'string':\n      case 'undefined':\n         return ResetMode.SOFT;\n   }\n\n   return;\n}\n\nfunction isValidResetMode(mode: ResetMode | any): mode is ResetMode {\n   return ResetModes.includes(mode);\n}\n", "import debug, { Debugger } from 'debug';\nimport { append, filterHasLength, filterString, filterType, NOOP, objectToString, remove } from './utils';\nimport { Maybe } from './types';\n\ndebug.formatters.L = (value: any) => String(filterHasLength(value) ? value.length : '-');\ndebug.formatters.B = (value: Buffer) => {\n   if (Buffer.isBuffer(value)) {\n      return value.toString('utf8');\n   }\n   return objectToString(value);\n}\n\ntype OutputLoggingHandler = (message: string, ...args: any[]) => void;\n\nfunction createLog () {\n   return debug('simple-git');\n}\n\nexport interface OutputLogger extends OutputLoggingHandler {\n   readonly label: string;\n\n   info: OutputLoggingHandler;\n   step (nextStep?: string): OutputLogger;\n   sibling (name: string): OutputLogger;\n}\n\nfunction prefixedLogger (to: Debugger, prefix: string, forward?: OutputLoggingHandler): OutputLoggingHandler {\n   if (!prefix || !String(prefix).replace(/\\s*/, '')) {\n      return !forward ? to : (message, ...args) => {\n         to(message, ...args);\n         forward(message, ...args);\n      };\n   }\n\n   return (message, ...args) => {\n      to(`%s ${message}`, prefix, ...args);\n      if (forward) {\n         forward(message, ...args);\n      }\n   };\n}\n\nfunction childLoggerName (name: Maybe<string>, childDebugger: Maybe<Debugger>, {namespace: parentNamespace}: Debugger): string {\n   if (typeof name === 'string') {\n      return name;\n   }\n   const childNamespace = childDebugger && childDebugger.namespace || '';\n\n   if (childNamespace.startsWith(parentNamespace)) {\n      return childNamespace.substr(parentNamespace.length + 1);\n   }\n\n   return childNamespace || parentNamespace;\n}\n\nexport function createLogger (label: string, verbose?: string | Debugger, initialStep?: string, infoDebugger = createLog()): OutputLogger {\n   const labelPrefix = label && `[${label}]` || '';\n\n   const spawned: OutputLogger[] = [];\n   const debugDebugger: Maybe<Debugger> = (typeof verbose === 'string') ? infoDebugger.extend(verbose) : verbose;\n   const key = childLoggerName(filterType(verbose, filterString), debugDebugger, infoDebugger);\n\n   return step(initialStep);\n\n   function sibling(name: string, initial?: string) {\n      return append(spawned, createLogger(label, key.replace(/^[^:]+/, name), initial, infoDebugger));\n   }\n\n   function step(phase?: string) {\n      const stepPrefix = phase && `[${phase}]` || '';\n      const debug = debugDebugger && prefixedLogger(debugDebugger, stepPrefix) || NOOP;\n      const info = prefixedLogger(infoDebugger, `${labelPrefix} ${ stepPrefix}`, debug);\n\n      return Object.assign(debugDebugger ? debug : info, {\n         label,\n         sibling,\n         info,\n         step,\n      });\n   }\n}\n\n/**\n * The `GitLogger` is used by the main `SimpleGit` runner to handle logging\n * any warnings or errors.\n */\nexport class GitLogger {\n\n   public error: OutputLoggingHandler;\n\n   public warn: OutputLoggingHandler\n\n   constructor(private _out: Debugger = createLog()) {\n      this.error = prefixedLogger(_out, '[ERROR]');\n      this.warn = prefixedLogger(_out, '[WARN]');\n   }\n\n   silent (silence = false) {\n      if (silence !== this._out.enabled) {\n         return;\n      }\n\n      const {namespace} = this._out;\n      const env = (process.env.DEBUG || '').split(',').filter(s => !!s);\n      const hasOn = env.includes(namespace);\n      const hasOff = env.includes(`-${namespace}`);\n\n      // enabling the log\n      if (!silence) {\n         if (hasOff) {\n            remove(env, `-${namespace}`);\n         }\n         else {\n            env.push(namespace);\n         }\n      }\n      else {\n         if (hasOn) {\n            remove(env, namespace);\n         }\n         else {\n            env.push(`-${namespace}`);\n         }\n      }\n\n      debug.enable(env.join(','));\n   }\n\n}\n", "import { SimpleGitTask } from '../types';\nimport { GitError } from '../errors/git-error';\nimport { createLogger, OutputLogger } from '../git-logger';\n\ntype AnySimpleGitTask = SimpleGitTask<any>;\n\ntype TaskInProgress = {\n   name: string;\n   logger: OutputLogger;\n   task: AnySimpleGitTask;\n}\n\nexport class TasksPendingQueue {\n\n   private _queue: Map<AnySimpleGitTask, TaskInProgress> = new Map();\n\n   constructor(private logLabel = 'GitExecutor') {\n   }\n\n   private withProgress(task: AnySimpleGitTask) {\n      return this._queue.get(task);\n   }\n\n   private createProgress (task: AnySimpleGitTask): TaskInProgress {\n      const name = TasksPendingQueue.getName(task.commands[0]);\n      const logger = createLogger(this.logLabel, name);\n\n      return {\n         task,\n         logger,\n         name,\n      };\n   }\n\n   push(task: AnySimpleGitTask): TaskInProgress {\n      const progress = this.createProgress(task);\n      progress.logger('Adding task to the queue, commands = %o', task.commands);\n\n      this._queue.set(task, progress);\n\n      return progress;\n   }\n\n   fatal(err: GitError) {\n      for (const [task, {logger}] of Array.from(this._queue.entries())) {\n         if (task === err.task) {\n            logger.info(`Failed %o`, err);\n            logger(`Fatal exception, any as-yet un-started tasks run through this executor will not be attempted`);\n         } else {\n            logger.info(`A fatal exception occurred in a previous task, the queue has been purged: %o`, err.message);\n         }\n\n         this.complete(task);\n      }\n\n      if (this._queue.size !== 0) {\n         throw new Error(`Queue size should be zero after fatal: ${this._queue.size}`);\n      }\n   }\n\n   complete(task: AnySimpleGitTask) {\n      const progress = this.withProgress(task);\n      if (progress) {\n         this._queue.delete(task);\n      }\n   }\n\n   attempt(task: AnySimpleGitTask): TaskInProgress {\n      const progress = this.withProgress(task);\n      if (!progress) {\n         throw new GitError(undefined, 'TasksPendingQueue: attempt called for an unknown task');\n      }\n      progress.logger('Starting task');\n\n      return progress;\n   }\n\n   static getName (name = 'empty') {\n      return `task:${name}:${++TasksPendingQueue.counter}`;\n   }\n\n   private static counter = 0;\n}\n", "import { spawn, SpawnOptions } from 'child_process';\nimport { GitError } from '../errors/git-error';\nimport { OutputLogger } from '../git-logger';\nimport { PluginStore } from '../plugins';\nimport { EmptyTask, isBufferTask, isEmptyTask, } from '../tasks/task';\nimport { GitExecutorResult, Maybe, outputHandler, RunnableTask, SimpleGitExecutor, SimpleGitTask } from '../types';\nimport { callTaskParser, first, GitOutputStreams, objectToString } from '../utils';\nimport { Scheduler } from './scheduler';\nimport { TasksPendingQueue } from './tasks-pending-queue';\n\nexport class GitExecutorChain implements SimpleGitExecutor {\n\n   private _chain: Promise<any> = Promise.resolve();\n   private _queue = new TasksPendingQueue();\n   private _cwd: string | undefined;\n\n   public get binary() {\n      return this._executor.binary;\n   }\n\n   public get cwd() {\n      return this._cwd || this._executor.cwd;\n   }\n\n   public set cwd(cwd: string) {\n      this._cwd = cwd;\n   }\n\n   public get env() {\n      return this._executor.env;\n   }\n\n   public get outputHandler() {\n      return this._executor.outputHandler;\n   }\n\n   constructor(\n      private _executor: SimpleGitExecutor,\n      private _scheduler: Scheduler,\n      private _plugins: PluginStore\n   ) {\n   }\n\n   public chain() {\n      return this;\n   }\n\n   public push<R>(task: SimpleGitTask<R>): Promise<R> {\n      this._queue.push(task);\n\n      return this._chain = this._chain.then(() => this.attemptTask(task));\n   }\n\n   private async attemptTask<R>(task: SimpleGitTask<R>): Promise<void | R> {\n      const onScheduleComplete = await this._scheduler.next();\n      const onQueueComplete = () => this._queue.complete(task);\n\n      try {\n         const {logger} = this._queue.attempt(task);\n         return await (isEmptyTask(task)\n               ? this.attemptEmptyTask(task, logger)\n               : this.attemptRemoteTask(task, logger)\n         ) as R;\n      } catch (e) {\n         throw this.onFatalException(task, e as Error);\n      } finally {\n         onQueueComplete();\n         onScheduleComplete();\n      }\n   }\n\n   private onFatalException<R>(task: SimpleGitTask<R>, e: Error) {\n      const gitError = (e instanceof GitError) ? Object.assign(e, {task}) : new GitError(task, e && String(e));\n\n      this._chain = Promise.resolve();\n      this._queue.fatal(gitError);\n\n      return gitError;\n   }\n\n   private async attemptRemoteTask<R>(task: RunnableTask<R>, logger: OutputLogger) {\n      const args = this._plugins.exec('spawn.args', [...task.commands], pluginContext(task, task.commands));\n\n      const raw = await this.gitResponse(\n         task,\n         this.binary, args, this.outputHandler, logger.step('SPAWN'),\n      );\n      const outputStreams = await this.handleTaskData(task, args, raw, logger.step('HANDLE'));\n\n      logger(`passing response to task's parser as a %s`, task.format);\n\n      if (isBufferTask(task)) {\n         return callTaskParser(task.parser, outputStreams);\n      }\n\n      return callTaskParser(task.parser, outputStreams.asStrings());\n   }\n\n   private async attemptEmptyTask(task: EmptyTask, logger: OutputLogger) {\n      logger(`empty task bypassing child process to call to task's parser`);\n      return task.parser(this);\n   }\n\n   private handleTaskData<R>(\n      task: SimpleGitTask<R>,\n      args: string[],\n      result: GitExecutorResult, logger: OutputLogger): Promise<GitOutputStreams> {\n\n      const {exitCode, rejection, stdOut, stdErr} = result;\n\n      return new Promise((done, fail) => {\n         logger(`Preparing to handle process response exitCode=%d stdOut=`, exitCode);\n\n         const {error} = this._plugins.exec('task.error', {error: rejection}, {\n            ...pluginContext(task, args),\n            ...result,\n         });\n\n         if (error && task.onError) {\n            logger.info(`exitCode=%s handling with custom error handler`);\n\n            return task.onError(\n               result,\n               error,\n               (newStdOut) => {\n                  logger.info(`custom error handler treated as success`);\n                  logger(`custom error returned a %s`, objectToString(newStdOut));\n\n                  done(new GitOutputStreams(\n                     Array.isArray(newStdOut) ? Buffer.concat(newStdOut) : newStdOut,\n                     Buffer.concat(stdErr),\n                  ));\n               },\n               fail\n            );\n         }\n\n         if (error) {\n            logger.info(`handling as error: exitCode=%s stdErr=%s rejection=%o`, exitCode, stdErr.length, rejection);\n            return fail(error);\n         }\n\n         logger.info(`retrieving task output complete`);\n         done(new GitOutputStreams(\n            Buffer.concat(stdOut),\n            Buffer.concat(stdErr),\n         ));\n      });\n   }\n\n   private async gitResponse<R>(task: SimpleGitTask<R>, command: string, args: string[], outputHandler: Maybe<outputHandler>, logger: OutputLogger): Promise<GitExecutorResult> {\n      const outputLogger = logger.sibling('output');\n      const spawnOptions: SpawnOptions = this._plugins.exec('spawn.options', {\n         cwd: this.cwd,\n         env: this.env,\n         windowsHide: true,\n      }, pluginContext(task, task.commands));\n\n      return new Promise((done) => {\n         const stdOut: Buffer[] = [];\n         const stdErr: Buffer[] = [];\n\n         let rejection: Maybe<Error>;\n\n         logger.info(`%s %o`, command, args);\n         logger('%O', spawnOptions)\n         const spawned = spawn(command, args, spawnOptions);\n\n         spawned.stdout!.on('data', onDataReceived(stdOut, 'stdOut', logger, outputLogger.step('stdOut')));\n         spawned.stderr!.on('data', onDataReceived(stdErr, 'stdErr', logger, outputLogger.step('stdErr')));\n\n         spawned.on('error', onErrorReceived(stdErr, logger));\n\n         if (outputHandler) {\n            logger(`Passing child process stdOut/stdErr to custom outputHandler`);\n            outputHandler(command, spawned.stdout!, spawned.stderr!, [...args]);\n         }\n\n         this._plugins.exec('spawn.after', undefined, {\n            ...pluginContext(task, args),\n            spawned,\n            close(exitCode: number, reason?: Error) {\n               done({\n                  stdOut,\n                  stdErr,\n                  exitCode,\n                  rejection: rejection || reason,\n               });\n            },\n            kill(reason: Error) {\n               if (spawned.killed) {\n                  return;\n               }\n\n               rejection = reason;\n               spawned.kill('SIGINT');\n            },\n         });\n      });\n   }\n\n}\n\nfunction pluginContext<R>(task: SimpleGitTask<R>, commands: string[]) {\n   return {\n      method: first(task.commands) || '',\n      commands,\n   }\n}\n\nfunction onErrorReceived(target: Buffer[], logger: OutputLogger) {\n   return (err: Error) => {\n      logger(`[ERROR] child process exception %o`, err);\n      target.push(Buffer.from(String(err.stack), 'ascii'));\n   }\n}\n\nfunction onDataReceived(target: Buffer[], name: string, logger: OutputLogger, output: OutputLogger) {\n   return (buffer: Buffer) => {\n      logger(`%s received %L bytes`, name, buffer);\n      output(`%B`, buffer);\n      target.push(buffer)\n   }\n}\n", "import type { PluginStore } from '../plugins';\nimport type { GitExecutorEnv, outputHandler, SimpleGitExecutor, SimpleGitTask } from '../types';\n\nimport { GitExecutorChain } from './git-executor-chain';\nimport { Scheduler } from './scheduler';\n\nexport class GitExecutor implements SimpleGitExecutor {\n\n   private _chain = new GitExecutorChain(this, this._scheduler, this._plugins);\n\n   public env: GitExecutorEnv;\n   public outputHandler?: outputHandler;\n\n   constructor(\n      public binary: string = 'git',\n      public cwd: string,\n      private _scheduler: Scheduler,\n      private _plugins: PluginStore,\n   ) {\n   }\n\n   chain(): SimpleGitExecutor {\n      return new GitExecutorChain(this, this._scheduler, this._plugins);\n   }\n\n   push<R>(task: SimpleGitTask<R>): Promise<R> {\n      return this._chain.push(task);\n   }\n\n}\n\n\n", "import { GitError } from './errors/git-error';\nimport { GitResponseError } from './errors/git-response-error';\nimport { SimpleGitTask, SimpleGitTaskCallback } from './types';\nimport { NOOP } from './utils';\n\nexport function taskCallback<R>(task: SimpleGitTask<R>, response: Promise<R>, callback: SimpleGitTaskCallback<R> = NOOP) {\n\n   const onSuccess = (data: R) => {\n      callback(null, data);\n   };\n\n   const onError = (err: GitError | GitResponseError) => {\n      if (err?.task === task) {\n         callback((err instanceof GitResponseError) ? addDeprecationNoticeToError(err) : err, undefined as any);\n      }\n   };\n\n   response.then(onSuccess, onError);\n\n}\n\nfunction addDeprecationNoticeToError (err: GitResponseError) {\n   let log = (name: string) => {\n      console.warn(`simple-git deprecation notice: accessing GitResponseError.${name} should be GitResponseError.git.${name}, this will no longer be available in version 3`);\n      log = NOOP;\n   };\n\n   return Object.create(err, Object.getOwnPropertyNames(err.git).reduce(descriptorReducer, {}));\n\n   function descriptorReducer(all: PropertyDescriptorMap, name: string): typeof all {\n      if (name in err) {\n         return all;\n      }\n\n      all[name] = {\n         enumerable: false,\n         configurable: false,\n         get () {\n            log(name);\n            return err.git[name];\n         },\n      };\n\n      return all;\n   }\n}\n", "import { folderExists } from '../utils';\nimport { SimpleGitExecutor } from '../types';\nimport { adhocExecTask } from './task';\n\nexport function changeWorkingDirectoryTask (directory: string, root?: SimpleGitExecutor) {\n   return adhocExecTask((instance: SimpleGitExecutor) => {\n      if (!folderExists(directory)) {\n         throw new Error(`Git.cwd: cannot change to non-directory \"${ directory }\"`);\n      }\n\n      return ((root || instance).cwd = directory);\n   });\n}\n", "import { CommitResult } from '../../../typings';\nimport { LineParser, parseStringResponse } from '../utils';\n\nconst parsers: LineParser<CommitResult>[] = [\n   new LineParser(/^\\[([^\\s]+)( \\([^)]+\\))? ([^\\]]+)/, (result, [branch, root, commit]) => {\n      result.branch = branch;\n      result.commit = commit;\n      result.root = !!root;\n   }),\n   new LineParser(/\\s*Author:\\s(.+)/i, (result, [author]) => {\n      const parts = author.split('<');\n      const email = parts.pop();\n\n      if (!email || !email.includes('@')) {\n         return;\n      }\n\n      result.author = {\n         email: email.substr(0, email.length - 1),\n         name: parts.join('<').trim()\n      };\n   }),\n   new LineParser(/(\\d+)[^,]*(?:,\\s*(\\d+)[^,]*)(?:,\\s*(\\d+))/g, (result, [changes, insertions, deletions]) => {\n      result.summary.changes = parseInt(changes, 10) || 0;\n      result.summary.insertions = parseInt(insertions, 10) || 0;\n      result.summary.deletions = parseInt(deletions, 10) || 0;\n   }),\n   new LineParser(/^(\\d+)[^,]*(?:,\\s*(\\d+)[^(]+\\(([+-]))?/, (result, [changes, lines, direction]) => {\n      result.summary.changes = parseInt(changes, 10) || 0;\n      const count = parseInt(lines, 10) || 0;\n      if (direction === '-') {\n         result.summary.deletions = count;\n      } else if (direction === '+') {\n         result.summary.insertions = count;\n      }\n   }),\n];\n\nexport function parseCommitResult(stdOut: string): CommitResult {\n   const result: CommitResult = {\n      author: null,\n      branch: '',\n      commit: '',\n      root: false,\n      summary: {\n         changes: 0,\n         insertions: 0,\n         deletions: 0,\n      },\n   };\n   return parseStringResponse(result, parsers, stdOut);\n}\n", "import type { CommitResult, SimpleGit } from '../../../typings';\nimport type { SimpleGitApi } from '../simple-git-api';\nimport type { StringTask } from '../types';\nimport { parseCommitResult } from '../parsers/parse-commit';\nimport {\n   asArray,\n   filterArray,\n   filterStringOrStringArray,\n   filterType,\n   getTrailingOptions, prefixedArray,\n   trailingFunctionArgument\n} from '../utils';\nimport { configurationErrorTask } from './task';\n\nexport function commitTask(message: string[], files: string[], customArgs: string[]): StringTask<CommitResult> {\n   const commands: string[] = [\n      '-c',\n      'core.abbrev=40',\n      'commit',\n      ...prefixedArray(message, '-m'),\n      ...files,\n      ...customArgs,\n   ];\n\n   return {\n      commands,\n      format: 'utf-8',\n      parser: parseCommitResult,\n   };\n}\n\nexport default function (): Pick<SimpleGit, 'commit'> {\n   return {\n      commit(this: SimpleGitApi, message: string | string[], ...rest: unknown[]) {\n         const next = trailingFunctionArgument(arguments);\n         const task = rejectDeprecatedSignatures(message) ||\n            commitTask(\n               asArray(message),\n               asArray(filterType(rest[0], filterStringOrStringArray, [])),\n               [...filterType(rest[1], filterArray, []), ...getTrailingOptions(arguments, 0, true)]\n            );\n\n         return this._runTask(task, next);\n      },\n   };\n\n   function rejectDeprecatedSignatures(message?: unknown) {\n      return (\n         !filterStringOrStringArray(message) &&\n         configurationErrorTask(`git.commit: requires the commit message to be supplied as a string/string[]`)\n      );\n   }\n}\n", "import { straightThroughStringTask } from './task';\nimport { StringTask } from '../types';\n\n/**\n * Task used by `git.hashObject`\n */\nexport function hashObjectTask(filePath: string, write: boolean): StringTask<string> {\n   const commands = ['hash-object', filePath];\n   if (write) {\n      commands.push('-w');\n   }\n\n   return straightThroughStringTask(commands, true);\n}\n", "import { InitResult } from '../../../typings';\n\nexport class InitSummary implements InitResult {\n   constructor(\n      public readonly bare: boolean,\n      public readonly path: string,\n      public readonly existing: boolean,\n      public readonly gitDir: string,\n   ) {}\n}\n\nconst initResponseRegex = /^Init.+ repository in (.+)$/;\nconst reInitResponseRegex = /^Rein.+ in (.+)$/;\n\nexport function parseInit(bare: boolean, path: string, text: string) {\n   const response = String(text).trim();\n   let result;\n\n   if ((result = initResponseRegex.exec(response))) {\n      return new InitSummary(bare, path, false, result[1]);\n   }\n\n   if ((result = reInitResponseRegex.exec(response))) {\n      return new InitSummary(bare, path, true, result[1]);\n   }\n\n   let gitDir = '';\n   const tokens = response.split(' ');\n   while (tokens.length) {\n      const token = tokens.shift();\n      if (token === 'in') {\n         gitDir = tokens.join(' ');\n         break;\n      }\n   }\n\n   return new InitSummary(bare, path, /^re/i.test(response), gitDir);\n}\n", "import { InitResult } from '../../../typings';\nimport { parseInit } from '../responses/InitSummary';\nimport { StringTask } from '../types';\n\nconst bareCommand = '--bare';\n\nfunction hasBareCommand(command: string[]) {\n   return command.includes(bareCommand);\n}\n\nexport function initTask(bare = false, path: string, customArgs: string[]): StringTask<InitResult> {\n   const commands = ['init', ...customArgs];\n   if (bare && !hasBareCommand(commands)) {\n      commands.splice(1, 0, bareCommand);\n   }\n\n   return {\n      commands,\n      format: 'utf-8',\n      parser(text: string): InitResult {\n         return parseInit(commands.includes('--bare'), path, text);\n      }\n   }\n}\n", "export enum LogFormat {\n   NONE = '',\n   STAT = '--stat',\n   NUM_STAT = '--numstat',\n   NAME_ONLY = '--name-only',\n   NAME_STATUS = '--name-status',\n}\n\nconst logFormatRegex = /^--(stat|numstat|name-only|name-status)(=|$)/;\n\nexport function logFormatFromCommand(customArgs: string[]) {\n   for (let i = 0; i < customArgs.length; i++) {\n      const format = logFormatRegex.exec(customArgs[i]);\n      if (format) {\n         return `--${format[1]}` as LogFormat;\n      }\n   }\n\n   return LogFormat.NONE;\n}\n\nexport function isLogFormat(customArg: string | unknown) {\n   return logFormatRegex.test(customArg as string);\n}\n", "import { DiffResult, DiffResultBinaryFile, DiffResultTextFile } from '../../../typings';\n\n/***\n * The DiffSummary is returned as a response to getting `git().status()`\n */\nexport class DiffSummary implements DiffResult {\n   changed = 0\n   deletions = 0;\n   insertions = 0;\n\n   files: Array<DiffResultTextFile | DiffResultBinaryFile> = [];\n}\n", "import { DiffResult } from '../../../typings';\nimport { LogFormat } from '../args/log-format';\nimport { DiffSummary } from '../responses/DiffSummary';\nimport { asNumber, LineParser, parseStringResponse } from '../utils';\n\nconst statParser = [\n   new LineParser<DiffResult>(/(.+)\\s+\\|\\s+(\\d+)(\\s+[+\\-]+)?$/, (result, [file, changes, alterations = '']) => {\n      result.files.push({\n         file: file.trim(),\n         changes: asNumber(changes),\n         insertions: alterations.replace(/[^+]/g, '').length,\n         deletions: alterations.replace(/[^-]/g, '').length,\n         binary: false\n      });\n   }),\n   new LineParser<DiffResult>(/(.+) \\|\\s+Bin ([0-9.]+) -> ([0-9.]+) ([a-z]+)/, (result, [file, before, after]) => {\n      result.files.push({\n         file: file.trim(),\n         before: asNumber(before),\n         after: asNumber(after),\n         binary: true\n      });\n   }),\n   new LineParser<DiffResult>(/(\\d+) files? changed\\s*((?:, \\d+ [^,]+){0,2})/, (result, [changed, summary]) => {\n      const inserted = /(\\d+) i/.exec(summary);\n      const deleted = /(\\d+) d/.exec(summary);\n\n      result.changed = asNumber(changed);\n      result.insertions = asNumber(inserted?.[1]);\n      result.deletions = asNumber(deleted?.[1]);\n   })\n];\n\nconst numStatParser = [\n   new LineParser<DiffResult>(/(\\d+)\\t(\\d+)\\t(.+)$/, (result, [changesInsert, changesDelete, file]) => {\n      const insertions = asNumber(changesInsert);\n      const deletions = asNumber(changesDelete);\n\n      result.changed++;\n      result.insertions += insertions;\n      result.deletions += deletions;\n\n      result.files.push({\n         file,\n         changes: insertions + deletions,\n         insertions,\n         deletions,\n         binary: false,\n      });\n   }),\n   new LineParser<DiffResult>(/-\\t-\\t(.+)$/, (result, [file]) => {\n      result.changed++;\n\n      result.files.push({\n         file,\n         after: 0,\n         before: 0,\n         binary: true,\n      });\n   })\n];\n\nconst nameOnlyParser = [\n   new LineParser<DiffResult>(/(.+)$/, (result, [file]) => {\n      result.changed++;\n      result.files.push({\n         file,\n         changes: 0,\n         insertions: 0,\n         deletions: 0,\n         binary: false,\n      });\n   })\n];\n\nconst nameStatusParser = [\n   new LineParser<DiffResult>(/([ACDMRTUXB])\\s*(.+)$/, (result, [_status, file]) => {\n      result.changed++;\n      result.files.push({\n         file,\n         changes: 0,\n         insertions: 0,\n         deletions: 0,\n         binary: false,\n      });\n   })\n];\n\nconst diffSummaryParsers: Record<LogFormat, LineParser<DiffResult>[]> = {\n   [LogFormat.NONE]: statParser,\n   [LogFormat.STAT]: statParser,\n   [LogFormat.NUM_STAT]: numStatParser,\n   [LogFormat.NAME_STATUS]: nameStatusParser,\n   [LogFormat.NAME_ONLY]: nameOnlyParser,\n};\n\nexport function getDiffParser(format = LogFormat.NONE) {\n   const parser = diffSummaryParsers[format];\n\n   return (stdOut: string) => parseStringResponse(new DiffSummary(), parser, stdOut, false);\n}\n", "import { ListLogLine, LogResult } from '../../../typings';\nimport { toLinesWithContent } from '../utils';\nimport { getDiffParser } from './parse-diff-summary';\nimport { LogFormat } from '../args/log-format';\n\nexport const START_BOUNDARY = '\u00F2\u00F2\u00F2\u00F2\u00F2\u00F2 ';\n\nexport const COMMIT_BOUNDARY = ' \u00F2\u00F2';\n\nexport const SPLITTER = ' \u00F2 ';\n\nconst defaultFieldNames = ['hash', 'date', 'message', 'refs', 'author_name', 'author_email'];\n\nfunction lineBuilder(tokens: string[], fields: string[]): any {\n   return fields.reduce((line, field, index) => {\n      line[field] = tokens[index] || '';\n      return line;\n   }, Object.create({diff: null}) as any);\n}\n\nexport function createListLogSummaryParser<T = any> (splitter = SPLITTER, fields = defaultFieldNames, logFormat = LogFormat.NONE) {\n   const parseDiffResult = getDiffParser(logFormat);\n\n   return function (stdOut: string): LogResult<T> {\n      const all: ReadonlyArray<T & ListLogLine> = toLinesWithContent(stdOut, true, START_BOUNDARY)\n         .map(function (item) {\n            const lineDetail = item.trim().split(COMMIT_BOUNDARY);\n            const listLogLine: T & ListLogLine = lineBuilder(lineDetail[0].trim().split(splitter), fields);\n\n            if (lineDetail.length > 1 && !!lineDetail[1].trim()) {\n               listLogLine.diff = parseDiffResult(lineDetail[1]);\n            }\n\n            return listLogLine;\n         });\n\n      return {\n         all,\n         latest: all.length && all[0] || null,\n         total: all.length,\n      };\n   }\n}\n", "import { StringTask } from '../types';\nimport { DiffResult } from '../../../typings';\nimport { isLogFormat, LogFormat, logFormatFromCommand } from '../args/log-format';\nimport { getDiffParser } from '../parsers/parse-diff-summary';\nimport { configurationErrorTask, EmptyTask } from './task';\n\nexport function diffSummaryTask(customArgs: string[]): StringTask<DiffResult> | EmptyTask {\n   let logFormat = logFormatFromCommand(customArgs);\n\n   const commands = ['diff'];\n\n   if (logFormat === LogFormat.NONE) {\n      logFormat = LogFormat.STAT;\n      commands.push('--stat=4096');\n   }\n\n   commands.push(...customArgs);\n\n   return validateLogFormatConfig(commands) || {\n      commands,\n      format: 'utf-8',\n      parser: getDiffParser(logFormat),\n   };\n}\n\nexport function validateLogFormatConfig(customArgs: unknown[]): EmptyTask | void {\n   const flags = customArgs.filter(isLogFormat);\n\n   if (flags.length > 1) {\n      return configurationErrorTask(`Summary flags are mutually exclusive - pick one of ${flags.join(',')}`);\n   }\n\n   if (flags.length && customArgs.includes('-z')) {\n      return configurationErrorTask(`Summary flag ${flags} parsing is not compatible with null termination option '-z'`);\n   }\n}\n", "import type { Options, StringTask } from '../types';\nimport type { LogResult, SimpleGit } from '../../../typings';\nimport { logFormatFromCommand } from '../args/log-format';\nimport {\n   COMMIT_BOUNDARY,\n   createListLogSummaryParser,\n   SPLITTER,\n   START_BOUNDARY\n} from '../parsers/parse-list-log-summary';\nimport {\n   appendTaskOptions,\n   filterArray,\n   filterPrimitives,\n   filterString,\n   filterType,\n   trailingFunctionArgument,\n   trailingOptionsArgument\n} from '../utils';\nimport { SimpleGitApi } from '../simple-git-api';\nimport { configurationErrorTask } from './task';\nimport { validateLogFormatConfig } from './diff';\n\nenum excludeOptions {\n   '--pretty',\n   'max-count',\n   'maxCount',\n   'n',\n   'file',\n   'format',\n   'from',\n   'to',\n   'splitter',\n   'symmetric',\n   'mailMap',\n   'multiLine',\n   'strictDate',\n}\n\nexport interface DefaultLogFields {\n   hash: string;\n   date: string;\n   message: string;\n   refs: string;\n   body: string;\n   author_name: string;\n   author_email: string;\n}\n\nexport type LogOptions<T = DefaultLogFields> = {\n   file?: string;\n   format?: T;\n   from?: string;\n   mailMap?: boolean;\n   maxCount?: number;\n   multiLine?: boolean;\n   splitter?: string;\n   strictDate?: boolean;\n   symmetric?: boolean;\n   to?: string;\n};\n\ninterface ParsedLogOptions {\n   fields: string[];\n   splitter: string;\n   commands: string[]\n}\n\nfunction prettyFormat(format: Record<string, string | unknown>, splitter: string): [string[], string] {\n   const fields: string[] = [];\n   const formatStr: string[] = [];\n\n   Object.keys(format).forEach((field) => {\n      fields.push(field);\n      formatStr.push(String(format[field]));\n   });\n\n   return [\n      fields, formatStr.join(splitter)\n   ];\n}\n\nfunction userOptions<T extends Options>(input: T): Options {\n   return Object.keys(input).reduce((out, key) => {\n      if (!(key in excludeOptions)) {\n         out[key] = input[key];\n      }\n      return out;\n   }, {} as Options);\n}\n\nexport function parseLogOptions<T extends Options>(opt: Options | LogOptions<T> = {}, customArgs: string[] = []): ParsedLogOptions {\n   const splitter = filterType(opt.splitter, filterString, SPLITTER);\n   const format = !filterPrimitives(opt.format) && opt.format ? opt.format : {\n      hash: '%H',\n      date: opt.strictDate === false ? '%ai' : '%aI',\n      message: '%s',\n      refs: '%D',\n      body: opt.multiLine ? '%B' : '%b',\n      author_name: opt.mailMap !== false ? '%aN' : '%an',\n      author_email: opt.mailMap !== false ? '%aE' : '%ae'\n   };\n\n   const [fields, formatStr] = prettyFormat(format, splitter);\n\n   const suffix: string[] = [];\n   const command: string[] = [\n      `--pretty=format:${START_BOUNDARY}${formatStr}${COMMIT_BOUNDARY}`,\n      ...customArgs,\n   ];\n\n   const maxCount: number | undefined = (opt as any).n || (opt as any)['max-count'] || opt.maxCount;\n   if (maxCount) {\n      command.push(`--max-count=${maxCount}`);\n   }\n\n   if (opt.from && opt.to) {\n      const rangeOperator = (opt.symmetric !== false) ? '...' : '..';\n      suffix.push(`${opt.from}${rangeOperator}${opt.to}`);\n   }\n\n   if (filterString(opt.file)) {\n      suffix.push('--follow', opt.file);\n   }\n\n   appendTaskOptions(userOptions(opt as Options), command);\n\n   return {\n      fields,\n      splitter,\n      commands: [\n         ...command,\n         ...suffix,\n      ],\n   };\n}\n\nexport function logTask<T>(splitter: string, fields: string[], customArgs: string[]): StringTask<LogResult<T>> {\n   const parser = createListLogSummaryParser(splitter, fields, logFormatFromCommand(customArgs));\n\n   return {\n      commands: ['log', ...customArgs],\n      format: 'utf-8',\n      parser,\n   };\n}\n\nexport default function (): Pick<SimpleGit, 'log'> {\n   return {\n      log<T extends Options>(this: SimpleGitApi, ...rest: unknown[]) {\n         const next = trailingFunctionArgument(arguments);\n         const options = parseLogOptions<T>(trailingOptionsArgument(arguments), filterType(arguments[0], filterArray));\n         const task = rejectDeprecatedSignatures(...rest) ||\n            validateLogFormatConfig(options.commands) ||\n            createLogTask(options);\n\n         return this._runTask(task, next);\n      }\n   }\n\n   function createLogTask(options: ParsedLogOptions) {\n      return logTask(options.splitter, options.fields, options.commands);\n   }\n\n   function rejectDeprecatedSignatures(from?: unknown, to?: unknown) {\n      return (\n         filterString(from) &&\n         filterString(to) &&\n         configurationErrorTask(`git.log(string, string) should be replaced with git.log({ from: string, to: string })`)\n      );\n   }\n}\n", "import { MergeConflict, MergeConflictDeletion, MergeDetail, MergeResultStatus } from '../../../typings';\n\nexport class MergeSummaryConflict implements MergeConflict {\n   constructor(\n      public readonly reason: string,\n      public readonly file: string | null = null,\n      public readonly meta?: MergeConflictDeletion,\n   ) {\n   }\n\n   toString() {\n      return `${this.file}:${this.reason}`;\n   }\n}\n\nexport class MergeSummaryDetail implements MergeDetail {\n   public conflicts: MergeConflict[] = [];\n   public merges: string[] = [];\n   public result: MergeResultStatus = 'success';\n\n   get failed() {\n      return this.conflicts.length > 0;\n   }\n\n   get reason() {\n      return this.result;\n   }\n\n   toString() {\n      if (this.conflicts.length) {\n         return `CONFLICTS: ${this.conflicts.join(', ')}`;\n      }\n\n      return 'OK';\n   }\n}\n\n", "import { PullDetailFileChanges, PullDetailSummary, PullFailedResult, PullResult } from '../../../typings';\n\nexport class PullSummary implements PullResult {\n   public remoteMessages = {\n      all: [],\n   };\n   public created = [];\n   public deleted: string[] = [];\n   public files: string[] = [];\n   public deletions: PullDetailFileChanges = {};\n   public insertions: PullDetailFileChanges = {};\n   public summary: PullDetailSummary = {\n      changes: 0,\n      deletions: 0,\n      insertions: 0,\n   };\n}\n\nexport class PullFailedSummary implements PullFailedResult {\n   remote = '';\n   hash = {\n      local: '',\n      remote: '',\n   };\n   branch = {\n      local: '',\n      remote: '',\n   };\n   message = '';\n\n   toString() {\n      return this.message;\n   }\n}\n\n", "import { RemoteMessageResult, RemoteMessages, RemoteMessagesObjectEnumeration } from '../../../typings';\nimport { asNumber, RemoteLineParser } from '../utils';\n\nfunction objectEnumerationResult<T extends RemoteMessages = RemoteMessages>(remoteMessages: T): RemoteMessagesObjectEnumeration {\n   return (remoteMessages.objects = remoteMessages.objects || {\n      compressing: 0,\n      counting: 0,\n      enumerating: 0,\n      packReused: 0,\n      reused: {count: 0, delta: 0},\n      total: {count: 0, delta: 0}\n   });\n}\n\nfunction asObjectCount(source: string) {\n   const count = /^\\s*(\\d+)/.exec(source);\n   const delta = /delta (\\d+)/i.exec(source);\n\n   return {\n      count: asNumber(count && count[1] || '0'),\n      delta: asNumber(delta && delta[1] || '0'),\n   };\n}\n\nexport const remoteMessagesObjectParsers: RemoteLineParser<RemoteMessageResult<RemoteMessages>>[] = [\n   new RemoteLineParser(/^remote:\\s*(enumerating|counting|compressing) objects: (\\d+),/i, (result, [action, count]) => {\n      const key = action.toLowerCase();\n      const enumeration = objectEnumerationResult(result.remoteMessages);\n\n      Object.assign(enumeration, {[key]: asNumber(count)});\n   }),\n   new RemoteLineParser(/^remote:\\s*(enumerating|counting|compressing) objects: \\d+% \\(\\d+\\/(\\d+)\\),/i, (result, [action, count]) => {\n      const key = action.toLowerCase();\n      const enumeration = objectEnumerationResult(result.remoteMessages);\n\n      Object.assign(enumeration, {[key]: asNumber(count)});\n   }),\n   new RemoteLineParser(/total ([^,]+), reused ([^,]+), pack-reused (\\d+)/i, (result, [total, reused, packReused]) => {\n      const objects = objectEnumerationResult(result.remoteMessages);\n      objects.total = asObjectCount(total);\n      objects.reused = asObjectCount(reused);\n      objects.packReused = asNumber(packReused);\n   }),\n];\n", "import { PushResultRemoteMessages, RemoteMessageResult, RemoteMessages } from '../../../typings';\nimport { asNumber, parseStringResponse, RemoteLineParser } from '../utils';\nimport { remoteMessagesObjectParsers } from './parse-remote-objects';\n\nconst parsers: RemoteLineParser<RemoteMessageResult<PushResultRemoteMessages | RemoteMessages>>[] = [\n   new RemoteLineParser(/^remote:\\s*(.+)$/, (result, [text]) => {\n      result.remoteMessages.all.push(text.trim());\n      return false;\n   }),\n   ...remoteMessagesObjectParsers,\n   new RemoteLineParser([/create a (?:pull|merge) request/i, /\\s(https?:\\/\\/\\S+)$/], (result, [pullRequestUrl]) => {\n      (result.remoteMessages as PushResultRemoteMessages).pullRequestUrl = pullRequestUrl;\n   }),\n   new RemoteLineParser([/found (\\d+) vulnerabilities.+\\(([^)]+)\\)/i, /\\s(https?:\\/\\/\\S+)$/], (result, [count, summary, url]) => {\n      (result.remoteMessages as PushResultRemoteMessages).vulnerabilities = {\n         count: asNumber(count),\n         summary,\n         url,\n      };\n   }),\n];\n\nexport function parseRemoteMessages<T extends RemoteMessages = RemoteMessages>(\n   _stdOut: string, stdErr: string,\n): RemoteMessageResult {\n   return parseStringResponse({remoteMessages: new RemoteMessageSummary() as T}, parsers, stdErr);\n}\n\nexport class RemoteMessageSummary implements RemoteMessages {\n   public readonly all: string[] = [];\n}\n", "import { PullDetail, PullFailedResult, PullResult, RemoteMessages } from '../../../typings';\nimport { PullFailedSummary, PullSummary } from '../responses/PullSummary';\nimport { TaskParser } from '../types';\nimport { append, LineParser, parseStringResponse } from '../utils';\nimport { parseRemoteMessages } from './parse-remote-messages';\n\nconst FILE_UPDATE_REGEX = /^\\s*(.+?)\\s+\\|\\s+\\d+\\s*(\\+*)(-*)/;\nconst SUMMARY_REGEX = /(\\d+)\\D+((\\d+)\\D+\\(\\+\\))?(\\D+(\\d+)\\D+\\(-\\))?/;\nconst ACTION_REGEX = /^(create|delete) mode \\d+ (.+)/;\n\nconst parsers: LineParser<PullResult>[] = [\n   new LineParser(FILE_UPDATE_REGEX, (result, [file, insertions, deletions]) => {\n      result.files.push(file);\n\n      if (insertions) {\n         result.insertions[file] = insertions.length;\n      }\n\n      if (deletions) {\n         result.deletions[file] = deletions.length;\n      }\n   }),\n   new LineParser(SUMMARY_REGEX, (result, [changes, , insertions, , deletions]) => {\n      if (insertions !== undefined || deletions !== undefined) {\n         result.summary.changes = +changes || 0;\n         result.summary.insertions = +insertions || 0;\n         result.summary.deletions = +deletions || 0;\n         return true;\n      }\n      return false;\n   }),\n   new LineParser(ACTION_REGEX, (result, [action, file]) => {\n      append(result.files, file);\n      append((action === 'create') ? result.created : result.deleted, file);\n   }),\n];\n\nconst errorParsers: LineParser<PullFailedResult>[] = [\n   new LineParser(/^from\\s(.+)$/i, (result, [remote]) => void (result.remote = remote)),\n   new LineParser(/^fatal:\\s(.+)$/, (result, [message]) => void (result.message = message)),\n   new LineParser(/([a-z0-9]+)\\.\\.([a-z0-9]+)\\s+(\\S+)\\s+->\\s+(\\S+)$/, (result, [hashLocal, hashRemote, branchLocal, branchRemote]) => {\n      result.branch.local = branchLocal;\n      result.hash.local = hashLocal;\n      result.branch.remote = branchRemote;\n      result.hash.remote = hashRemote;\n   }),\n];\n\nexport const parsePullDetail: TaskParser<string, PullDetail> = (stdOut, stdErr) => {\n   return parseStringResponse(new PullSummary(), parsers, [stdOut, stdErr]);\n}\n\nexport const parsePullResult: TaskParser<string, PullResult> = (stdOut, stdErr) => {\n   return Object.assign(\n      new PullSummary(),\n      parsePullDetail(stdOut, stdErr),\n      parseRemoteMessages<RemoteMessages>(stdOut, stdErr),\n   );\n}\n\nexport function parsePullErrorResult(stdOut: string, stdErr: string) {\n   const pullError = parseStringResponse(new PullFailedSummary(), errorParsers, [stdOut, stdErr]);\n\n   return pullError.message && pullError;\n}\n", "import { MergeDetail, MergeResult } from '../../../typings';\nimport { MergeSummaryConflict, MergeSummaryDetail } from '../responses/MergeSummary';\nimport { TaskParser } from '../types';\nimport { LineParser, parseStringResponse } from '../utils';\nimport { parsePullResult } from './parse-pull';\n\nconst parsers: LineParser<MergeDetail>[] = [\n   new LineParser(/^Auto-merging\\s+(.+)$/, (summary, [autoMerge]) => {\n      summary.merges.push(autoMerge);\n   }),\n   new LineParser(/^CONFLICT\\s+\\((.+)\\): Merge conflict in (.+)$/, (summary, [reason, file]) => {\n      summary.conflicts.push(new MergeSummaryConflict(reason, file));\n   }),\n   new LineParser(/^CONFLICT\\s+\\((.+\\/delete)\\): (.+) deleted in (.+) and/, (summary, [reason, file, deleteRef]) => {\n      summary.conflicts.push(new MergeSummaryConflict(reason, file, {deleteRef}));\n   }),\n   new LineParser(/^CONFLICT\\s+\\((.+)\\):/, (summary, [reason]) => {\n      summary.conflicts.push(new MergeSummaryConflict(reason, null));\n   }),\n   new LineParser(/^Automatic merge failed;\\s+(.+)$/, (summary, [result]) => {\n      summary.result = result;\n   }),\n];\n\n/**\n * Parse the complete response from `git.merge`\n */\nexport const parseMergeResult: TaskParser<string, MergeResult> = (stdOut, stdErr) => {\n   return Object.assign(\n      parseMergeDetail(stdOut, stdErr),\n      parsePullResult(stdOut, stdErr),\n   );\n};\n\n/**\n * Parse the merge specific detail (ie: not the content also available in the pull detail) from `git.mnerge`\n * @param stdOut\n */\nexport const parseMergeDetail: TaskParser<string, MergeDetail> = (stdOut) => {\n   return parseStringResponse(new MergeSummaryDetail(), parsers, stdOut);\n}\n", "import { MergeResult } from '../../../typings';\nimport { GitResponseError } from '../errors/git-response-error';\nimport { parseMergeResult } from '../parsers/parse-merge';\nimport { StringTask } from '../types';\nimport { configurationErrorTask, EmptyTask } from './task';\n\nexport function mergeTask(customArgs: string[]): EmptyTask | StringTask<MergeResult> {\n   if (!customArgs.length) {\n      return configurationErrorTask('Git.merge requires at least one option');\n   }\n\n   return {\n      commands: ['merge', ...customArgs],\n      format: 'utf-8',\n      parser(stdOut, stdErr): MergeResult {\n         const merge = parseMergeResult(stdOut, stdErr);\n         if (merge.failed) {\n            throw new GitResponseError(merge);\n         }\n\n         return merge;\n      }\n   }\n}\n", "import { PushDetail, PushResult, PushResultPushedItem, PushResultRemoteMessages } from '../../../typings';\nimport { TaskParser } from '../types';\nimport { LineParser, parseStringResponse } from '../utils';\nimport { parseRemoteMessages } from './parse-remote-messages';\n\nfunction pushResultPushedItem(local: string, remote: string, status: string): PushResultPushedItem {\n   const deleted = status.includes('deleted');\n   const tag = status.includes('tag') || /^refs\\/tags/.test(local);\n   const alreadyUpdated = !status.includes('new');\n\n   return {\n      deleted,\n      tag,\n      branch: !tag,\n      new: !alreadyUpdated,\n      alreadyUpdated,\n      local,\n      remote,\n   };\n}\n\nconst parsers: LineParser<PushDetail>[] = [\n   new LineParser(/^Pushing to (.+)$/, (result, [repo]) => {\n      result.repo = repo;\n   }),\n   new LineParser(/^updating local tracking ref '(.+)'/, (result, [local]) => {\n      result.ref = {\n         ...(result.ref || {}),\n         local,\n      }\n   }),\n   new LineParser(/^[*-=]\\s+([^:]+):(\\S+)\\s+\\[(.+)]$/, (result, [local, remote, type]) => {\n      result.pushed.push(pushResultPushedItem(local, remote, type));\n   }),\n   new LineParser(/^Branch '([^']+)' set up to track remote branch '([^']+)' from '([^']+)'/, (result, [local, remote, remoteName]) => {\n      result.branch = {\n         ...(result.branch || {}),\n         local,\n         remote,\n         remoteName,\n      };\n   }),\n   new LineParser(/^([^:]+):(\\S+)\\s+([a-z0-9]+)\\.\\.([a-z0-9]+)$/, (result, [local, remote, from, to]) => {\n      result.update = {\n         head: {\n            local,\n            remote,\n         },\n         hash: {\n            from,\n            to,\n         },\n      };\n   }),\n];\n\nexport const parsePushResult: TaskParser<string, PushResult> = (stdOut, stdErr) => {\n   const pushDetail = parsePushDetail(stdOut, stdErr);\n   const responseDetail = parseRemoteMessages<PushResultRemoteMessages>(stdOut, stdErr);\n\n   return {\n      ...pushDetail,\n      ...responseDetail,\n   };\n}\n\nexport const parsePushDetail: TaskParser<string, PushDetail> = (stdOut, stdErr) => {\n   return parseStringResponse({pushed: []}, parsers, [stdOut, stdErr]);\n}\n", "import { PushResult } from '../../../typings';\nimport { parsePushResult as parser } from '../parsers/parse-push';\nimport { StringTask } from '../types';\nimport { append, remove } from '../utils';\n\ntype PushRef = { remote?: string, branch?: string };\n\nexport function pushTagsTask(ref: PushRef = {}, customArgs: string[]): StringTask<PushResult> {\n   append(customArgs, '--tags');\n   return pushTask(ref, customArgs);\n}\n\nexport function pushTask(ref: PushRef = {}, customArgs: string[]): StringTask<PushResult> {\n   const commands = ['push', ...customArgs];\n   if (ref.branch) {\n      commands.splice(1, 0, ref.branch);\n   }\n   if (ref.remote) {\n      commands.splice(1, 0, ref.remote);\n   }\n\n   remove(commands, '-v');\n   append(commands, '--verbose');\n   append(commands, '--porcelain');\n\n   return {\n      commands,\n      format: 'utf-8',\n      parser,\n   };\n}\n", "import { FileStatusResult } from '../../../typings';\n\nexport const fromPathRegex = /^(.+) -> (.+)$/;\n\nexport class FileStatusSummary implements FileStatusResult {\n\n   public readonly from: string | undefined;\n\n   constructor (\n      public path: string,\n      public index: string,\n      public working_dir: string) {\n\n      if ('R' === (index + working_dir)) {\n         const detail = fromPathRegex.exec(path) || [null, path, path];\n         this.from = detail[1] || '';\n         this.path = detail[2] || '';\n      }\n   }\n}\n", "import { StatusResult } from '../../../typings';\nimport { append, NULL } from '../utils';\nimport { FileStatusSummary } from './FileStatusSummary';\n\ntype StatusLineParser = (result: StatusResult, file: string) => void;\n\nexport class StatusSummary implements StatusResult {\n   public not_added = [];\n   public conflicted = [];\n   public created = [];\n   public deleted = [];\n   public ignored = undefined;\n   public modified = [];\n   public renamed = [];\n   public files = [];\n   public staged = [];\n   public ahead = 0;\n   public behind = 0;\n   public current = null;\n   public tracking = null;\n   public detached = false;\n\n   public isClean = () => {\n      return !this.files.length;\n   }\n}\n\nenum PorcelainFileStatus {\n   ADDED = 'A',\n   DELETED = 'D',\n   MODIFIED = 'M',\n   RENAMED = 'R',\n   COPIED = 'C',\n   UNMERGED = 'U',\n   UNTRACKED = '?',\n   IGNORED = '!',\n   NONE = ' ',\n}\n\nfunction renamedFile(line: string) {\n   const [to, from] = line.split(NULL);\n\n   return {\n      from: from || to,\n      to,\n   };\n}\n\nfunction parser(indexX: PorcelainFileStatus, indexY: PorcelainFileStatus, handler: StatusLineParser): [string, StatusLineParser] {\n   return [`${indexX}${indexY}`, handler];\n}\n\nfunction conflicts(indexX: PorcelainFileStatus, ...indexY: PorcelainFileStatus[]) {\n   return indexY.map(y => parser(indexX, y, (result, file) => append(result.conflicted, file)));\n}\n\nconst parsers: Map<string, StatusLineParser> = new Map([\n   parser(PorcelainFileStatus.NONE, PorcelainFileStatus.ADDED, (result, file) => append(result.created, file)),\n   parser(PorcelainFileStatus.NONE, PorcelainFileStatus.DELETED, (result, file) => append(result.deleted, file)),\n   parser(PorcelainFileStatus.NONE, PorcelainFileStatus.MODIFIED, (result, file) => append(result.modified, file)),\n\n   parser(PorcelainFileStatus.ADDED, PorcelainFileStatus.NONE, (result, file) => append(result.created, file) && append(result.staged, file)),\n   parser(PorcelainFileStatus.ADDED, PorcelainFileStatus.MODIFIED, (result, file) =>\n      append(result.created, file) && append(result.staged, file) && append(result.modified, file)),\n\n   parser(PorcelainFileStatus.DELETED, PorcelainFileStatus.NONE, (result, file) => append(result.deleted, file) && append(result.staged, file)),\n\n   parser(PorcelainFileStatus.MODIFIED, PorcelainFileStatus.NONE, (result, file) => append(result.modified, file) && append(result.staged, file)),\n   parser(PorcelainFileStatus.MODIFIED, PorcelainFileStatus.MODIFIED, (result, file) => append(result.modified, file) && append(result.staged, file)),\n\n   parser(PorcelainFileStatus.RENAMED, PorcelainFileStatus.NONE, (result, file) => {\n      append(result.renamed, renamedFile(file));\n   }),\n   parser(PorcelainFileStatus.RENAMED, PorcelainFileStatus.MODIFIED, (result, file) => {\n      const renamed = renamedFile(file);\n      append(result.renamed, renamed);\n      append(result.modified, renamed.to);\n   }),\n   parser(PorcelainFileStatus.IGNORED, PorcelainFileStatus.IGNORED, (_result, _file) => {\n      append((_result.ignored = _result.ignored || []), _file);\n   }),\n\n   parser(PorcelainFileStatus.UNTRACKED, PorcelainFileStatus.UNTRACKED, (result, file) => append(result.not_added, file)),\n\n   ...conflicts(PorcelainFileStatus.ADDED, PorcelainFileStatus.ADDED, PorcelainFileStatus.UNMERGED),\n   ...conflicts(PorcelainFileStatus.DELETED, PorcelainFileStatus.DELETED, PorcelainFileStatus.UNMERGED),\n   ...conflicts(PorcelainFileStatus.UNMERGED, PorcelainFileStatus.ADDED, PorcelainFileStatus.DELETED, PorcelainFileStatus.UNMERGED),\n\n   ['##', (result, line) => {\n      const aheadReg = /ahead (\\d+)/;\n      const behindReg = /behind (\\d+)/;\n      const currentReg = /^(.+?(?=(?:\\.{3}|\\s|$)))/;\n      const trackingReg = /\\.{3}(\\S*)/;\n      const onEmptyBranchReg = /\\son\\s([\\S]+)$/;\n      let regexResult;\n\n      regexResult = aheadReg.exec(line);\n      result.ahead = regexResult && +regexResult[1] || 0;\n\n      regexResult = behindReg.exec(line);\n      result.behind = regexResult && +regexResult[1] || 0;\n\n      regexResult = currentReg.exec(line);\n      result.current = regexResult && regexResult[1];\n\n      regexResult = trackingReg.exec(line);\n      result.tracking = regexResult && regexResult[1];\n\n      regexResult = onEmptyBranchReg.exec(line);\n      result.current = regexResult && regexResult[1] || result.current;\n\n      result.detached = /\\(no branch\\)/.test(line);\n   }]\n]);\n\nexport const parseStatusSummary = function (text: string): StatusResult {\n   const lines = text.split(NULL);\n   const status = new StatusSummary();\n\n   for (let i = 0, l = lines.length; i < l;) {\n      let line = lines[i++].trim();\n\n      if (!line) {\n         continue;\n      }\n\n      if (line.charAt(0) === PorcelainFileStatus.RENAMED) {\n         line += NULL + (lines[i++] || '');\n      }\n\n      splitLine(status, line);\n   }\n\n   return status;\n};\n\nfunction splitLine(result: StatusResult, lineStr: string) {\n   const trimmed = lineStr.trim();\n   switch (' ') {\n      case trimmed.charAt(2):\n         return data(trimmed.charAt(0), trimmed.charAt(1), trimmed.substr(3));\n      case trimmed.charAt(1):\n         return data(PorcelainFileStatus.NONE, trimmed.charAt(0), trimmed.substr(2));\n      default:\n         return;\n   }\n\n   function data(index: string, workingDir: string, path: string) {\n      const raw = `${index}${workingDir}`;\n      const handler = parsers.get(raw);\n\n      if (handler) {\n         handler(result, path);\n      }\n\n      if (raw !== '##' && raw !== '!!') {\n         result.files.push(new FileStatusSummary(path.replace(/\\0.+$/, ''), index, workingDir));\n      }\n   }\n}\n", "import { StatusResult } from '../../../typings';\nimport { parseStatusSummary } from '../responses/StatusSummary';\nimport { StringTask } from '../types';\n\nconst ignoredOptions = ['--null', '-z'];\n\nexport function statusTask(customArgs: string[]): StringTask<StatusResult> {\n   const commands = [\n      'status',\n      '--porcelain',\n      '-b',\n      '-u',\n      '--null',\n      ...customArgs.filter(arg => !ignoredOptions.includes(arg))\n   ];\n\n   return {\n      format: 'utf-8',\n      commands,\n      parser(text: string) {\n         return parseStatusSummary(text);\n      }\n   }\n}\n", "import { SimpleGitBase } from '../../typings';\nimport { taskCallback } from './task-callback';\nimport { changeWorkingDirectoryTask } from './tasks/change-working-directory';\nimport commit from './tasks/commit';\nimport config from './tasks/config';\nimport grep from './tasks/grep';\nimport { hashObjectTask } from './tasks/hash-object';\nimport { initTask } from './tasks/init';\nimport log from './tasks/log';\nimport { mergeTask } from './tasks/merge';\nimport { pushTask } from './tasks/push';\nimport { statusTask } from './tasks/status';\nimport { configurationErrorTask, straightThroughStringTask } from './tasks/task';\nimport { outputHandler, SimpleGitExecutor, SimpleGitTask, SimpleGitTaskCallback } from './types';\nimport { asArray, filterString, filterType, getTrailingOptions, trailingFunctionArgument } from './utils';\n\nexport class SimpleGitApi implements SimpleGitBase {\n\n   constructor(private _executor: SimpleGitExecutor) {\n   }\n\n   protected _runTask<T>(task: SimpleGitTask<T>, then?: SimpleGitTaskCallback<T>) {\n      const chain = this._executor.chain();\n      const promise = chain.push(task);\n\n      if (then) {\n         taskCallback(task, promise, then);\n      }\n\n      return Object.create(this, {\n         then: {value: promise.then.bind(promise)},\n         catch: {value: promise.catch.bind(promise)},\n         _executor: {value: chain},\n      });\n   }\n\n   add(files: string | string[]) {\n      return this._runTask(\n         straightThroughStringTask(['add', ...asArray(files)]),\n         trailingFunctionArgument(arguments),\n      );\n   }\n\n   cwd(directory: string | { path: string, root?: boolean }) {\n      const next = trailingFunctionArgument(arguments);\n\n      if (typeof directory === 'string') {\n         return this._runTask(changeWorkingDirectoryTask(directory, this._executor), next);\n      }\n\n      if (typeof directory?.path === 'string') {\n         return this._runTask(changeWorkingDirectoryTask(directory.path, directory.root && this._executor || undefined), next);\n      }\n\n      return this._runTask(\n         configurationErrorTask('Git.cwd: workingDirectory must be supplied as a string'),\n         next\n      );\n   }\n\n   hashObject(path: string, write: boolean | unknown) {\n      return this._runTask(\n         hashObjectTask(path, write === true),\n         trailingFunctionArgument(arguments),\n      );\n   }\n\n   init(bare?: boolean | unknown) {\n      return this._runTask(\n         initTask(bare === true, this._executor.cwd, getTrailingOptions(arguments)),\n         trailingFunctionArgument(arguments),\n      );\n   }\n\n   merge() {\n      return this._runTask(\n         mergeTask(getTrailingOptions(arguments)),\n         trailingFunctionArgument(arguments),\n      );\n   }\n\n   mergeFromTo(remote: string, branch: string) {\n      if (!(filterString(remote) && filterString(branch))) {\n         return this._runTask(configurationErrorTask(\n            `Git.mergeFromTo requires that the 'remote' and 'branch' arguments are supplied as strings`\n         ));\n      }\n\n      return this._runTask(\n         mergeTask([remote, branch, ...getTrailingOptions(arguments)]),\n         trailingFunctionArgument(arguments, false),\n      );\n   }\n\n   outputHandler(handler: outputHandler) {\n      this._executor.outputHandler = handler;\n      return this;\n   }\n\n   push() {\n      const task = pushTask(\n         {\n            remote: filterType(arguments[0], filterString),\n            branch: filterType(arguments[1], filterString),\n         },\n         getTrailingOptions(arguments),\n      );\n\n      return this._runTask(\n         task,\n         trailingFunctionArgument(arguments),\n      );\n   }\n\n   stash() {\n      return this._runTask(\n         straightThroughStringTask(['stash', ...getTrailingOptions(arguments)]),\n         trailingFunctionArgument(arguments),\n      );\n   }\n\n   status() {\n      return this._runTask(statusTask(getTrailingOptions(arguments)), trailingFunctionArgument(arguments));\n   }\n}\n\nObject.assign(SimpleGitApi.prototype, commit(), config(), grep(), log());\n", "import { append, remove } from '../utils';\nimport { createDeferred, DeferredPromise } from '@kwsites/promise-deferred';\nimport { createLogger } from '../git-logger';\n\ntype ScheduleCompleteCallback = () => void;\ntype ScheduledTask = Pick<DeferredPromise<ScheduleCompleteCallback>, 'promise' | 'done'> & {id: number};\n\nconst createScheduledTask: () => ScheduledTask = (() => {\n   let id = 0;\n   return () => {\n      id++;\n      const {promise, done} = createDeferred<ScheduleCompleteCallback>();\n\n      return {\n         promise,\n         done,\n         id,\n      };\n   }\n})();\n\nexport class Scheduler {\n   private logger = createLogger('', 'scheduler');\n   private pending: ScheduledTask[] = [];\n   private running: ScheduledTask[] = [];\n\n   constructor(private concurrency = 2) {\n      this.logger(`Constructed, concurrency=%s`, concurrency);\n   }\n\n   private schedule() {\n      if (!this.pending.length || this.running.length >= this.concurrency) {\n         this.logger(`Schedule attempt ignored, pending=%s running=%s concurrency=%s`, this.pending.length, this.running.length, this.concurrency);\n         return;\n      }\n\n      const task = append(this.running, this.pending.shift()!);\n      this.logger(`Attempting id=%s`, task.id);\n      task.done(() => {\n         this.logger(`Completing id=`, task.id);\n         remove(this.running, task);\n         this.schedule();\n      });\n   }\n\n   next(): Promise<ScheduleCompleteCallback> {\n      const {promise, id} = append(this.pending, createScheduledTask());\n      this.logger(`Scheduling id=%s`, id);\n\n      this.schedule();\n\n      return promise;\n   }\n}\n", "import { straightThroughStringTask } from './task';\nimport { OptionFlags, Options, StringTask } from '../types';\n\nexport type ApplyOptions = Options &\n   OptionFlags<\n      | '--stat'\n      | '--numstat'\n      | '--summary'\n      | '--check'\n      | '--index'\n      | '--intent-to-add'\n      | '--3way'\n      | '--apply'\n      | '--no-add'\n      | '-R'\n      | '--reverse'\n      | '--allow-binary-replacement'\n      | '--binary'\n      | '--reject'\n      | '-z'\n      | '--inaccurate-eof'\n      | '--recount'\n      | '--cached'\n      | '--ignore-space-change'\n      | '--ignore-whitespace'\n      | '--verbose'\n      | '--unsafe-paths'> &\n   OptionFlags<\n      '--whitespace',\n      'nowarn' | 'warn' | 'fix' | 'error' | 'error-all'> &\n   OptionFlags<'--build-fake-ancestor' | '--exclude' | '--include' | '--directory',\n      string> &\n   OptionFlags<'-p' | '-C', number>;\n\nexport function applyPatchTask(patches: string[], customArgs: string[]): StringTask<string> {\n   return straightThroughStringTask(['apply', ...customArgs, ...patches]);\n}\n", "import {\n   BranchMultiDeleteResult,\n   BranchSingleDeleteFailure,\n   BranchSingleDeleteResult,\n   BranchSingleDeleteSuccess\n} from '../../../typings';\n\nexport class BranchDeletionBatch implements BranchMultiDeleteResult {\n   all: BranchSingleDeleteResult[] = [];\n   branches: { [branchName: string]: BranchSingleDeleteResult } = {};\n   errors: BranchSingleDeleteResult[] = [];\n\n   get success(): boolean {\n      return !this.errors.length;\n   }\n}\n\nexport function branchDeletionSuccess (branch: string, hash: string): BranchSingleDeleteSuccess {\n   return {\n      branch, hash, success: true,\n   };\n}\n\nexport function branchDeletionFailure (branch: string): BranchSingleDeleteFailure {\n   return {\n      branch, hash: null, success: false,\n   };\n}\n\nexport function isSingleBranchDeleteFailure (test: BranchSingleDeleteResult): test is BranchSingleDeleteSuccess {\n   return test.success;\n}\n", "import { BranchMultiDeleteResult } from '../../../typings';\nimport { BranchDeletionBatch, branchDeletionFailure, branchDeletionSuccess } from '../responses/BranchDeleteSummary';\nimport { TaskParser } from '../types';\nimport { ExitCodes, LineParser, parseStringResponse } from '../utils';\n\nconst deleteSuccessRegex = /(\\S+)\\s+\\(\\S+\\s([^)]+)\\)/;\nconst deleteErrorRegex = /^error[^']+'([^']+)'/m;\n\nconst parsers: LineParser<BranchMultiDeleteResult>[] = [\n   new LineParser(deleteSuccessRegex, (result, [branch, hash]) => {\n      const deletion = branchDeletionSuccess(branch, hash);\n\n      result.all.push(deletion);\n      result.branches[branch] = deletion;\n   }),\n   new LineParser(deleteErrorRegex, (result, [branch]) => {\n      const deletion = branchDeletionFailure(branch);\n\n      result.errors.push(deletion);\n      result.all.push(deletion);\n      result.branches[branch] = deletion;\n   }),\n];\n\nexport const parseBranchDeletions: TaskParser<string, BranchMultiDeleteResult> = (stdOut, stdErr) => {\n   return parseStringResponse(new BranchDeletionBatch(), parsers, [stdOut, stdErr]);\n}\n\nexport function hasBranchDeletionError(data: string, processExitCode: ExitCodes): boolean {\n   return processExitCode === ExitCodes.ERROR && deleteErrorRegex.test(data);\n}\n", "import type { BranchSummary, BranchSummaryBranch } from '../../../typings';\n\nexport enum BranchStatusIdentifier {\n   CURRENT = '*',\n   LINKED = '+',\n}\n\nexport class BranchSummaryResult implements BranchSummary {\n   public all: string[] = [];\n   public branches: { [p: string]: BranchSummaryBranch } = {};\n   public current: string = '';\n   public detached: boolean = false;\n\n   push(status: BranchStatusIdentifier | unknown, detached: boolean, name: string, commit: string, label: string) {\n      if (status === BranchStatusIdentifier.CURRENT) {\n         this.detached = detached;\n         this.current = name;\n      }\n\n      this.all.push(name);\n      this.branches[name] = {\n         current: status === BranchStatusIdentifier.CURRENT,\n         linkedWorkTree: status === BranchStatusIdentifier.LINKED,\n         name,\n         commit,\n         label\n      };\n   }\n}\n\n", "import type { BranchSummary } from '../../../typings';\nimport { BranchSummaryResult } from '../responses/BranchSummary';\nimport { LineParser, parseStringResponse } from '../utils';\n\nconst parsers: LineParser<BranchSummaryResult>[] = [\n   new LineParser(/^([*+]\\s)?\\((?:HEAD )?detached (?:from|at) (\\S+)\\)\\s+([a-z0-9]+)\\s(.*)$/, (result, [current, name, commit, label]) => {\n      result.push(\n         branchStatus(current),\n         true,\n         name, commit, label\n      );\n   }),\n   new LineParser(/^([*+]\\s)?(\\S+)\\s+([a-z0-9]+)\\s?(.*)$/s, (result, [current, name, commit, label]) => {\n      result.push(\n         branchStatus(current),\n         false,\n         name, commit, label\n      );\n   })\n];\n\nfunction branchStatus(input?: string) {\n   return input ? input.charAt(0) : '';\n}\n\nexport function parseBranchSummary(stdOut: string): BranchSummary {\n   return parseStringResponse(new BranchSummaryResult(), parsers, stdOut);\n}\n", "import { BranchMultiDeleteResult, BranchSingleDeleteResult, BranchSummary } from '../../../typings';\nimport { StringTask } from '../types';\nimport { GitResponseError } from '../errors/git-response-error';\nimport { hasBranchDeletionError, parseBranchDeletions } from '../parsers/parse-branch-delete';\nimport { parseBranchSummary } from '../parsers/parse-branch';\nimport { bufferToString } from '../utils';\n\nexport function containsDeleteBranchCommand(commands: string[]) {\n   const deleteCommands = ['-d', '-D', '--delete'];\n   return commands.some(command => deleteCommands.includes(command));\n}\n\nexport function branchTask(customArgs: string[]): StringTask<BranchSummary | BranchSingleDeleteResult> {\n   const isDelete = containsDeleteBranchCommand(customArgs);\n   const commands = ['branch', ...customArgs];\n\n   if (commands.length === 1) {\n      commands.push('-a');\n   }\n\n   if (!commands.includes('-v')) {\n      commands.splice(1, 0, '-v');\n   }\n\n   return {\n      format: 'utf-8',\n      commands,\n      parser(stdOut, stdErr) {\n         if (isDelete) {\n            return parseBranchDeletions(stdOut, stdErr).all[0];\n         }\n\n         return parseBranchSummary(stdOut);\n      },\n   }\n}\n\nexport function branchLocalTask(): StringTask<BranchSummary> {\n   const parser = parseBranchSummary;\n\n   return {\n      format: 'utf-8',\n      commands: ['branch', '-v'],\n      parser,\n   }\n}\n\nexport function deleteBranchesTask(branches: string[], forceDelete = false): StringTask<BranchMultiDeleteResult> {\n   return {\n      format: 'utf-8',\n      commands: ['branch', '-v', forceDelete ? '-D' : '-d', ...branches],\n      parser(stdOut, stdErr) {\n         return parseBranchDeletions(stdOut, stdErr);\n      },\n      onError({exitCode, stdOut}, error, done, fail) {\n         if (!hasBranchDeletionError(String(error), exitCode)) {\n            return fail(error);\n         }\n\n         done(stdOut);\n      },\n   }\n}\n\nexport function deleteBranchTask(branch: string, forceDelete = false): StringTask<BranchSingleDeleteResult> {\n   const task: StringTask<BranchSingleDeleteResult> = {\n      format: 'utf-8',\n      commands: ['branch', '-v', forceDelete ? '-D' : '-d', branch],\n      parser(stdOut, stdErr) {\n         return parseBranchDeletions(stdOut, stdErr).branches[branch]!;\n      },\n      onError({exitCode, stdErr, stdOut}, error, _, fail) {\n         if (!hasBranchDeletionError(String(error), exitCode)) {\n            return fail(error);\n         }\n\n         throw new GitResponseError(\n            task.parser(bufferToString(stdOut), bufferToString(stdErr)),\n            String(error)\n         );\n      },\n   };\n\n   return task;\n}\n", "\n/**\n * Parser for the `check-ignore` command - returns each file as a string array\n */\nexport const parseCheckIgnore = (text: string): string[] => {\n   return text.split(/\\n/g)\n      .map(line => line.trim())\n      .filter(file => !!file);\n};\n", "import { StringTask } from '../types';\nimport { parseCheckIgnore } from '../responses/CheckIgnore';\n\nexport function checkIgnoreTask(paths: string[]): StringTask<string[]> {\n   return {\n      commands: ['check-ignore', ...paths],\n      format: 'utf-8',\n      parser: parseCheckIgnore,\n   };\n}\n", "import { configurationErrorTask, EmptyTask, straightThroughStringTask } from './task';\nimport { OptionFlags, Options, StringTask } from '../types';\nimport { append, filterString } from '../utils';\n\nexport type CloneOptions = Options &\n   OptionFlags<'--bare' |\n      '--dissociate' |\n      '--mirror' |\n      '--no-checkout' |\n      '--no-remote-submodules' |\n      '--no-shallow-submodules' |\n      '--no-single-branch' |\n      '--no-tags' |\n      '--remote-submodules' |\n      '--single-branch' |\n      '--shallow-submodules' |\n      '--verbose'> &\n   OptionFlags<'--depth' | '-j' | '--jobs', number> &\n   OptionFlags<'--branch' | '--origin' | '--recurse-submodules' | '--separate-git-dir' | '--shallow-exclude' | '--shallow-since' | '--template', string>\n\nfunction disallowedCommand(command: string) {\n   return /^--upload-pack(=|$)/.test(command);\n}\n\nexport function cloneTask(repo: string | undefined, directory: string | undefined, customArgs: string[]): StringTask<string> | EmptyTask {\n   const commands = ['clone', ...customArgs];\n\n   filterString(repo) && commands.push(repo);\n   filterString(directory) && commands.push(directory);\n\n   const banned = commands.find(disallowedCommand);\n   if (banned) {\n      return configurationErrorTask(`git.fetch: potential exploit argument blocked.`);\n   }\n\n   return straightThroughStringTask(commands);\n}\n\nexport function cloneMirrorTask(repo: string | undefined, directory: string | undefined, customArgs: string[]) {\n   append(customArgs, '--mirror');\n\n   return cloneTask(repo, directory, customArgs);\n}\n", "import { FetchResult } from '../../../typings';\nimport { LineParser, parseStringResponse } from '../utils';\n\nconst parsers: LineParser<FetchResult>[] = [\n   new LineParser(/From (.+)$/, (result, [remote]) => {\n      result.remote = remote;\n   }),\n   new LineParser(/\\* \\[new branch]\\s+(\\S+)\\s*-> (.+)$/, (result, [name, tracking]) =>{\n      result.branches.push({\n         name,\n         tracking,\n      });\n   }),\n   new LineParser(/\\* \\[new tag]\\s+(\\S+)\\s*-> (.+)$/, (result, [name, tracking]) => {\n      result.tags.push({\n         name,\n         tracking,\n      });\n   })\n];\n\nexport function parseFetchResult (stdOut: string, stdErr: string): FetchResult {\n   const result: FetchResult = {\n      raw: stdOut,\n      remote: null,\n      branches: [],\n      tags: [],\n   };\n   return parseStringResponse(result, parsers, [stdOut, stdErr]);\n}\n", "import { FetchResult } from '../../../typings';\nimport { parseFetchResult } from '../parsers/parse-fetch';\nimport { StringTask } from '../types';\n\nimport { configurationErrorTask, EmptyTask } from './task';\n\nfunction disallowedCommand(command: string) {\n   return /^--upload-pack(=|$)/.test(command);\n}\n\nexport function fetchTask(remote: string, branch: string, customArgs: string[]): StringTask<FetchResult> | EmptyTask {\n   const commands = ['fetch', ...customArgs];\n   if (remote && branch) {\n      commands.push(remote, branch);\n   }\n\n   const banned = commands.find(disallowedCommand);\n   if (banned) {\n      return configurationErrorTask(`git.fetch: potential exploit argument blocked.`);\n   }\n\n   return {\n      commands,\n      format: 'utf-8',\n      parser: parseFetchResult,\n   }\n}\n", "import { MoveResult } from '../../../typings';\nimport { LineParser, parseStringResponse } from '../utils';\n\nconst parsers: LineParser<MoveResult>[] = [\n   new LineParser(/^Renaming (.+) to (.+)$/, (result, [from, to]) => {\n      result.moves.push({from, to});\n   }),\n];\n\nexport function parseMoveResult (stdOut: string): MoveResult {\n   return parseStringResponse({moves: []}, parsers, stdOut);\n}\n", "import { MoveResult } from '../../../typings';\nimport { parseMoveResult } from '../parsers/parse-move';\nimport { StringTask } from '../types';\nimport { asArray } from '../utils';\n\nexport function moveTask(from: string | string[], to: string): StringTask<MoveResult> {\n   return {\n      commands: ['mv', '-v', ...asArray(from), to],\n      format: 'utf-8',\n      parser: parseMoveResult,\n   };\n}\n", "import { PullResult } from '../../../typings';\nimport { GitResponseError } from '../errors/git-response-error';\nimport { parsePullErrorResult, parsePullResult } from '../parsers/parse-pull';\nimport { Maybe, StringTask } from '../types';\nimport { bufferToString } from '../utils';\n\nexport function pullTask(remote: Maybe<string>, branch: Maybe<string>, customArgs: string[]): StringTask<PullResult> {\n   const commands: string[] = ['pull', ...customArgs];\n   if (remote && branch) {\n      commands.splice(1, 0, remote, branch);\n   }\n\n   return {\n      commands,\n      format: 'utf-8',\n      parser(stdOut, stdErr): PullResult {\n         return parsePullResult(stdOut, stdErr);\n      },\n      onError(result, _error, _done, fail) {\n         const pullError = parsePullErrorResult(bufferToString(result.stdOut), bufferToString(result.stdErr));\n         if (pullError) {\n            return fail(new GitResponseError(pullError));\n         }\n\n         fail(_error);\n      }\n   }\n}\n", "import { forEachLineWithContent } from '../utils';\n\nexport interface RemoteWithoutRefs {\n   name: string;\n}\n\nexport interface RemoteWithRefs extends RemoteWithoutRefs {\n   refs: {\n      fetch: string;\n      push: string;\n   };\n}\n\nexport function parseGetRemotes (text: string): RemoteWithoutRefs[] {\n   const remotes: {[name: string]: RemoteWithoutRefs} = {};\n\n   forEach(text, ([name]) => remotes[name] = { name });\n\n   return Object.values(remotes);\n}\n\nexport function parseGetRemotesVerbose (text: string): RemoteWithRefs[] {\n   const remotes: {[name: string]: RemoteWithRefs} = {};\n\n   forEach(text, ([name, url, purpose]) => {\n      if (!remotes.hasOwnProperty(name)) {\n         remotes[name] = {\n            name: name,\n            refs: { fetch: '', push: '' },\n         };\n      }\n\n      if (purpose && url) {\n         remotes[name].refs[purpose.replace(/[^a-z]/g, '') as keyof RemoteWithRefs['refs']] = url;\n      }\n   });\n\n   return Object.values(remotes);\n}\n\nfunction forEach(text: string, handler: (line: string[]) => void) {\n   forEachLineWithContent(text, (line) => handler(line.split(/\\s+/)));\n}\n", "import { parseGetRemotes, parseGetRemotesVerbose } from '../responses/GetRemoteSummary';\nimport { StringTask } from '../types';\nimport { straightThroughStringTask } from './task';\n\nexport function addRemoteTask(remoteName: string, remoteRepo: string, customArgs: string[] = []): StringTask<string> {\n   return straightThroughStringTask(['remote', 'add', ...customArgs, remoteName, remoteRepo]);\n}\n\nexport function getRemotesTask(verbose: boolean): StringTask<any> {\n   const commands = ['remote'];\n   if (verbose) {\n      commands.push('-v');\n   }\n\n   return {\n      commands,\n      format: 'utf-8',\n      parser: verbose ? parseGetRemotesVerbose : parseGetRemotes,\n   };\n}\n\nexport function listRemotesTask(customArgs: string[] = []): StringTask<string> {\n   const commands = [...customArgs];\n   if (commands[0] !== 'ls-remote') {\n      commands.unshift('ls-remote');\n   }\n\n   return straightThroughStringTask(commands);\n}\n\nexport function remoteTask(customArgs: string[] = []): StringTask<string> {\n   const commands = [...customArgs];\n   if (commands[0] !== 'remote') {\n      commands.unshift('remote');\n   }\n\n   return straightThroughStringTask(commands);\n}\n\nexport function removeRemoteTask(remoteName: string) {\n   return straightThroughStringTask(['remote', 'remove', remoteName]);\n}\n", "import { LogOptions, LogResult } from '../../../typings';\nimport { logFormatFromCommand } from '../args/log-format';\nimport { createListLogSummaryParser } from '../parsers/parse-list-log-summary';\nimport type { StringTask } from '../types';\nimport { validateLogFormatConfig } from './diff';\nimport { parseLogOptions } from './log';\nimport type { EmptyTask } from './task';\n\nexport function stashListTask(opt: LogOptions = {}, customArgs: string[]): EmptyTask | StringTask<LogResult> {\n   const options = parseLogOptions<any>(opt);\n   const commands = ['stash', 'list', ...options.commands, ...customArgs];\n   const parser = createListLogSummaryParser(options.splitter, options.fields, logFormatFromCommand(commands));\n\n   return validateLogFormatConfig(commands) || {\n      commands,\n      format: 'utf-8',\n      parser,\n   };\n}\n", "import { StringTask } from '../types';\nimport { straightThroughStringTask } from './task';\n\nexport function addSubModuleTask(repo: string, path: string): StringTask<string> {\n   return subModuleTask(['add', repo, path]);\n}\n\nexport function initSubModuleTask(customArgs: string[]): StringTask<string> {\n   return subModuleTask(['init', ...customArgs]);\n}\n\nexport function subModuleTask(customArgs: string[]): StringTask<string> {\n   const commands = [...customArgs];\n   if (commands[0] !== 'submodule') {\n      commands.unshift('submodule');\n   }\n\n   return straightThroughStringTask(commands);\n}\n\nexport function updateSubModuleTask(customArgs: string[]): StringTask<string> {\n   return subModuleTask(['update', ...customArgs]);\n}\n", "import { TagResult } from '../../../typings';\n\nexport class TagList implements TagResult {\n   constructor(\n      public readonly all: string[],\n      public readonly latest: string | undefined,\n   ) {\n   }\n}\n\nexport const parseTagList = function (data: string, customSort = false) {\n   const tags = data\n      .split('\\n')\n      .map(trimmed)\n      .filter(Boolean);\n\n   if (!customSort) {\n      tags.sort(function (tagA, tagB) {\n         const partsA = tagA.split('.');\n         const partsB = tagB.split('.');\n\n         if (partsA.length === 1 || partsB.length === 1) {\n            return singleSorted(toNumber(partsA[0]), toNumber(partsB[0]));\n         }\n\n         for (let i = 0, l = Math.max(partsA.length, partsB.length); i < l; i++) {\n            const diff = sorted(toNumber(partsA[i]), toNumber(partsB[i]));\n\n            if (diff) {\n               return diff;\n            }\n         }\n\n         return 0;\n      });\n   }\n\n   const latest = customSort ? tags[0] : [...tags].reverse().find((tag) => tag.indexOf('.') >= 0);\n\n   return new TagList(tags, latest);\n};\n\nfunction singleSorted(a: number, b:  number): number {\n   const aIsNum = isNaN(a);\n   const bIsNum = isNaN(b);\n\n   if (aIsNum !== bIsNum) {\n      return aIsNum ? 1 : -1;\n   }\n\n   return aIsNum ? sorted(a, b) : 0;\n}\n\nfunction sorted(a: number, b: number) {\n   return a === b ? 0 : a > b ? 1 : -1;\n}\n\nfunction trimmed(input: string) {\n   return input.trim();\n}\n\nfunction toNumber(input: string | undefined) {\n   if (typeof input === 'string') {\n      return parseInt(input.replace(/^\\D+/g, ''), 10) || 0;\n   }\n\n   return 0;\n}\n", "import { TagResult } from '../../../typings';\nimport { parseTagList } from '../responses/TagList';\nimport { StringTask } from '../types';\n\n/**\n * Task used by `git.tags`\n */\nexport function tagListTask (customArgs: string[] = []): StringTask<TagResult> {\n   const hasCustomSort = customArgs.some((option) => /^--sort=/.test(option));\n\n   return {\n      format: 'utf-8',\n      commands: ['tag', '-l', ...customArgs],\n      parser (text: string) {\n         return parseTagList(text, hasCustomSort);\n      },\n   }\n}\n\n/**\n * Task used by `git.addTag`\n */\nexport function addTagTask (name: string): StringTask<{name: string}> {\n   return {\n      format: 'utf-8',\n      commands: ['tag', name],\n      parser () {\n         return {name};\n      }\n   }\n}\n\n/**\n * Task used by `git.addTag`\n */\nexport function addAnnotatedTagTask (name: string, tagMessage: string): StringTask<{name: string}> {\n   return {\n      format: 'utf-8',\n      commands: ['tag', '-a', '-m', tagMessage, name],\n      parser () {\n         return {name};\n      }\n   }\n}\n", "const {GitExecutor} = require('./lib/runners/git-executor');\nconst {SimpleGitApi} = require('./lib/simple-git-api');\n\nconst {Scheduler} = require('./lib/runners/scheduler');\nconst {configurationErrorTask} = require('./lib/tasks/task');\nconst {\n   asArray,\n   filterArray,\n   filterPrimitives,\n   filterString,\n   filterStringOrStringArray,\n   filterType,\n   getTrailingOptions,\n   trailingFunctionArgument,\n   trailingOptionsArgument\n} = require('./lib/utils');\nconst {applyPatchTask} = require('./lib/tasks/apply-patch')\nconst {branchTask, branchLocalTask, deleteBranchesTask, deleteBranchTask} = require('./lib/tasks/branch');\nconst {checkIgnoreTask} = require('./lib/tasks/check-ignore');\nconst {checkIsRepoTask} = require('./lib/tasks/check-is-repo');\nconst {cloneTask, cloneMirrorTask} = require('./lib/tasks/clone');\nconst {cleanWithOptionsTask, isCleanOptionsArray} = require('./lib/tasks/clean');\nconst {commitTask} = require('./lib/tasks/commit');\nconst {diffSummaryTask} = require('./lib/tasks/diff');\nconst {fetchTask} = require('./lib/tasks/fetch');\nconst {moveTask} = require(\"./lib/tasks/move\");\nconst {pullTask} = require('./lib/tasks/pull');\nconst {pushTagsTask} = require('./lib/tasks/push');\nconst {addRemoteTask, getRemotesTask, listRemotesTask, remoteTask, removeRemoteTask} = require('./lib/tasks/remote');\nconst {getResetMode, resetTask} = require('./lib/tasks/reset');\nconst {stashListTask} = require('./lib/tasks/stash-list');\nconst {addSubModuleTask, initSubModuleTask, subModuleTask, updateSubModuleTask} = require('./lib/tasks/sub-module');\nconst {addAnnotatedTagTask, addTagTask, tagListTask} = require('./lib/tasks/tag');\nconst {straightThroughBufferTask, straightThroughStringTask} = require('./lib/tasks/task');\n\nfunction Git (options, plugins) {\n   this._executor = new GitExecutor(\n      options.binary, options.baseDir,\n      new Scheduler(options.maxConcurrentProcesses), plugins,\n   );\n}\n\n(Git.prototype = Object.create(SimpleGitApi.prototype)).constructor = Git;\n\n/**\n * Sets the path to a custom git binary, should either be `git` when there is an installation of git available on\n * the system path, or a fully qualified path to the executable.\n *\n * @param {string} command\n * @returns {Git}\n */\nGit.prototype.customBinary = function (command) {\n   this._executor.binary = command;\n   return this;\n};\n\n/**\n * Sets an environment variable for the spawned child process, either supply both a name and value as strings or\n * a single object to entirely replace the current environment variables.\n *\n * @param {string|Object} name\n * @param {string} [value]\n * @returns {Git}\n */\nGit.prototype.env = function (name, value) {\n   if (arguments.length === 1 && typeof name === 'object') {\n      this._executor.env = name;\n   } else {\n      (this._executor.env = this._executor.env || {})[name] = value;\n   }\n\n   return this;\n};\n\n/**\n * List the stash(s) of the local repo\n */\nGit.prototype.stashList = function (options) {\n   return this._runTask(\n      stashListTask(\n         trailingOptionsArgument(arguments) || {},\n         filterArray(options) && options || []\n      ),\n      trailingFunctionArgument(arguments),\n   );\n};\n\nfunction createCloneTask (api, task, repoPath, localPath) {\n   if (typeof repoPath !== 'string') {\n      return configurationErrorTask(`git.${ api }() requires a string 'repoPath'`);\n   }\n\n   return task(repoPath, filterType(localPath, filterString), getTrailingOptions(arguments));\n}\n\n\n/**\n * Clone a git repo\n */\nGit.prototype.clone = function () {\n   return this._runTask(\n      createCloneTask('clone', cloneTask, ...arguments),\n      trailingFunctionArgument(arguments),\n   );\n};\n\n/**\n * Mirror a git repo\n */\nGit.prototype.mirror = function () {\n   return this._runTask(\n      createCloneTask('mirror', cloneMirrorTask, ...arguments),\n      trailingFunctionArgument(arguments),\n   );\n};\n\n/**\n * Moves one or more files to a new destination.\n *\n * @see https://git-scm.com/docs/git-mv\n *\n * @param {string|string[]} from\n * @param {string} to\n */\nGit.prototype.mv = function (from, to) {\n   return this._runTask(moveTask(from, to), trailingFunctionArgument(arguments));\n};\n\n/**\n * Internally uses pull and tags to get the list of tags then checks out the latest tag.\n *\n * @param {Function} [then]\n */\nGit.prototype.checkoutLatestTag = function (then) {\n   var git = this;\n   return this.pull(function () {\n      git.tags(function (err, tags) {\n         git.checkout(tags.latest, then);\n      });\n   });\n};\n\n/**\n * Pull the updated contents of the current repo\n */\nGit.prototype.pull = function (remote, branch, options, then) {\n   return this._runTask(\n      pullTask(filterType(remote, filterString), filterType(branch, filterString), getTrailingOptions(arguments)),\n      trailingFunctionArgument(arguments),\n   );\n};\n\n/**\n * Fetch the updated contents of the current repo.\n *\n * @example\n *   .fetch('upstream', 'master') // fetches from master on remote named upstream\n *   .fetch(function () {}) // runs fetch against default remote and branch and calls function\n *\n * @param {string} [remote]\n * @param {string} [branch]\n */\nGit.prototype.fetch = function (remote, branch) {\n   return this._runTask(\n      fetchTask(filterType(remote, filterString), filterType(branch, filterString), getTrailingOptions(arguments)),\n      trailingFunctionArgument(arguments),\n   );\n};\n\n/**\n * Disables/enables the use of the console for printing warnings and errors, by default messages are not shown in\n * a production environment.\n *\n * @param {boolean} silence\n * @returns {Git}\n */\nGit.prototype.silent = function (silence) {\n   console.warn('simple-git deprecation notice: git.silent: logging should be configured using the `debug` library / `DEBUG` environment variable, this will be an error in version 3');\n   return this;\n};\n\n/**\n * List all tags. When using git 2.7.0 or above, include an options object with `\"--sort\": \"property-name\"` to\n * sort the tags by that property instead of using the default semantic versioning sort.\n *\n * Note, supplying this option when it is not supported by your Git version will cause the operation to fail.\n *\n * @param {Object} [options]\n * @param {Function} [then]\n */\nGit.prototype.tags = function (options, then) {\n   return this._runTask(\n      tagListTask(getTrailingOptions(arguments)),\n      trailingFunctionArgument(arguments),\n   );\n};\n\n/**\n * Rebases the current working copy. Options can be supplied either as an array of string parameters\n * to be sent to the `git rebase` command, or a standard options object.\n */\nGit.prototype.rebase = function () {\n   return this._runTask(\n      straightThroughStringTask(['rebase', ...getTrailingOptions(arguments)]),\n      trailingFunctionArgument(arguments)\n   );\n};\n\n/**\n * Reset a repo\n */\nGit.prototype.reset = function (mode) {\n   return this._runTask(\n      resetTask(getResetMode(mode), getTrailingOptions(arguments)),\n      trailingFunctionArgument(arguments),\n   );\n};\n\n/**\n * Revert one or more commits in the local working copy\n */\nGit.prototype.revert = function (commit) {\n   const next = trailingFunctionArgument(arguments);\n\n   if (typeof commit !== 'string') {\n      return this._runTask(\n         configurationErrorTask('Commit must be a string'),\n         next,\n      );\n   }\n\n   return this._runTask(\n      straightThroughStringTask(['revert', ...getTrailingOptions(arguments, 0, true), commit]),\n      next\n   );\n};\n\n/**\n * Add a lightweight tag to the head of the current branch\n */\nGit.prototype.addTag = function (name) {\n   const task = (typeof name === 'string')\n      ? addTagTask(name)\n      : configurationErrorTask('Git.addTag requires a tag name');\n\n   return this._runTask(task, trailingFunctionArgument(arguments));\n};\n\n/**\n * Add an annotated tag to the head of the current branch\n */\nGit.prototype.addAnnotatedTag = function (tagName, tagMessage) {\n   return this._runTask(\n      addAnnotatedTagTask(tagName, tagMessage),\n      trailingFunctionArgument(arguments),\n   );\n};\n\n/**\n * Check out a tag or revision, any number of additional arguments can be passed to the `git checkout` command\n * by supplying either a string or array of strings as the first argument.\n */\nGit.prototype.checkout = function () {\n   const commands = ['checkout', ...getTrailingOptions(arguments, true)];\n   return this._runTask(\n      straightThroughStringTask(commands),\n      trailingFunctionArgument(arguments),\n   );\n};\n\n/**\n * Check out a remote branch\n *\n * @param {string} branchName name of branch\n * @param {string} startPoint (e.g origin/development)\n * @param {Function} [then]\n */\nGit.prototype.checkoutBranch = function (branchName, startPoint, then) {\n   return this.checkout(['-b', branchName, startPoint], trailingFunctionArgument(arguments));\n};\n\n/**\n * Check out a local branch\n */\nGit.prototype.checkoutLocalBranch = function (branchName, then) {\n   return this.checkout(['-b', branchName], trailingFunctionArgument(arguments));\n};\n\n/**\n * Delete a local branch\n */\nGit.prototype.deleteLocalBranch = function (branchName, forceDelete, then) {\n   return this._runTask(\n      deleteBranchTask(branchName, typeof forceDelete === \"boolean\" ? forceDelete : false),\n      trailingFunctionArgument(arguments),\n   );\n};\n\n/**\n * Delete one or more local branches\n */\nGit.prototype.deleteLocalBranches = function (branchNames, forceDelete, then) {\n   return this._runTask(\n      deleteBranchesTask(branchNames, typeof forceDelete === \"boolean\" ? forceDelete : false),\n      trailingFunctionArgument(arguments),\n   );\n};\n\n/**\n * List all branches\n *\n * @param {Object | string[]} [options]\n * @param {Function} [then]\n */\nGit.prototype.branch = function (options, then) {\n   return this._runTask(\n      branchTask(getTrailingOptions(arguments)),\n      trailingFunctionArgument(arguments),\n   );\n};\n\n/**\n * Return list of local branches\n *\n * @param {Function} [then]\n */\nGit.prototype.branchLocal = function (then) {\n   return this._runTask(\n      branchLocalTask(),\n      trailingFunctionArgument(arguments),\n   );\n};\n\n/**\n * Executes any command against the git binary.\n */\nGit.prototype.raw = function (commands) {\n   const createRestCommands = !Array.isArray(commands);\n   const command = [].slice.call(createRestCommands ? arguments : commands, 0);\n\n   for (let i = 0; i < command.length && createRestCommands; i++) {\n      if (!filterPrimitives(command[i])) {\n         command.splice(i, command.length - i);\n         break;\n      }\n   }\n\n   command.push(\n      ...getTrailingOptions(arguments, 0, true),\n   );\n\n   var next = trailingFunctionArgument(arguments);\n\n   if (!command.length) {\n      return this._runTask(\n         configurationErrorTask('Raw: must supply one or more command to execute'),\n         next,\n      );\n   }\n\n   return this._runTask(straightThroughStringTask(command), next);\n};\n\nGit.prototype.submoduleAdd = function (repo, path, then) {\n   return this._runTask(\n      addSubModuleTask(repo, path),\n      trailingFunctionArgument(arguments),\n   );\n};\n\nGit.prototype.submoduleUpdate = function (args, then) {\n   return this._runTask(\n      updateSubModuleTask(getTrailingOptions(arguments, true)),\n      trailingFunctionArgument(arguments),\n   );\n};\n\nGit.prototype.submoduleInit = function (args, then) {\n   return this._runTask(\n      initSubModuleTask(getTrailingOptions(arguments, true)),\n      trailingFunctionArgument(arguments),\n   );\n};\n\nGit.prototype.subModule = function (options, then) {\n   return this._runTask(\n      subModuleTask(getTrailingOptions(arguments)),\n      trailingFunctionArgument(arguments),\n   );\n};\n\nGit.prototype.listRemote = function () {\n   return this._runTask(\n      listRemotesTask(getTrailingOptions(arguments)),\n      trailingFunctionArgument(arguments),\n   );\n};\n\n/**\n * Adds a remote to the list of remotes.\n */\nGit.prototype.addRemote = function (remoteName, remoteRepo, then) {\n   return this._runTask(\n      addRemoteTask(remoteName, remoteRepo, getTrailingOptions(arguments)),\n      trailingFunctionArgument(arguments),\n   );\n};\n\n/**\n * Removes an entry by name from the list of remotes.\n */\nGit.prototype.removeRemote = function (remoteName, then) {\n   return this._runTask(\n      removeRemoteTask(remoteName),\n      trailingFunctionArgument(arguments),\n   );\n};\n\n/**\n * Gets the currently available remotes, setting the optional verbose argument to true includes additional\n * detail on the remotes themselves.\n */\nGit.prototype.getRemotes = function (verbose, then) {\n   return this._runTask(\n      getRemotesTask(verbose === true),\n      trailingFunctionArgument(arguments),\n   );\n};\n\n/**\n * Call any `git remote` function with arguments passed as an array of strings.\n *\n * @param {string[]} options\n * @param {Function} [then]\n */\nGit.prototype.remote = function (options, then) {\n   return this._runTask(\n      remoteTask(getTrailingOptions(arguments)),\n      trailingFunctionArgument(arguments),\n   );\n};\n\n/**\n * Call any `git tag` function with arguments passed as an array of strings.\n *\n * @param {string[]} options\n * @param {Function} [then]\n */\nGit.prototype.tag = function (options, then) {\n   const command = getTrailingOptions(arguments);\n\n   if (command[0] !== 'tag') {\n      command.unshift('tag');\n   }\n\n   return this._runTask(\n      straightThroughStringTask(command),\n      trailingFunctionArgument(arguments)\n   );\n};\n\n/**\n * Updates repository server info\n *\n * @param {Function} [then]\n */\nGit.prototype.updateServerInfo = function (then) {\n   return this._runTask(\n      straightThroughStringTask(['update-server-info']),\n      trailingFunctionArgument(arguments),\n   );\n};\n\n/**\n * Pushes the current tag changes to a remote which can be either a URL or named remote. When not specified uses the\n * default configured remote spec.\n *\n * @param {string} [remote]\n * @param {Function} [then]\n */\nGit.prototype.pushTags = function (remote, then) {\n   const task = pushTagsTask({remote: filterType(remote, filterString)}, getTrailingOptions(arguments));\n\n   return this._runTask(task, trailingFunctionArgument(arguments));\n};\n\n/**\n * Removes the named files from source control.\n */\nGit.prototype.rm = function (files) {\n   return this._runTask(\n      straightThroughStringTask(['rm', '-f', ...asArray(files)]),\n      trailingFunctionArgument(arguments)\n   );\n};\n\n/**\n * Removes the named files from source control but keeps them on disk rather than deleting them entirely. To\n * completely remove the files, use `rm`.\n *\n * @param {string|string[]} files\n */\nGit.prototype.rmKeepLocal = function (files) {\n   return this._runTask(\n      straightThroughStringTask(['rm', '--cached', ...asArray(files)]),\n      trailingFunctionArgument(arguments)\n   );\n};\n\n/**\n * Returns a list of objects in a tree based on commit hash. Passing in an object hash returns the object's content,\n * size, and type.\n *\n * Passing \"-p\" will instruct cat-file to determine the object type, and display its formatted contents.\n *\n * @param {string[]} [options]\n * @param {Function} [then]\n */\nGit.prototype.catFile = function (options, then) {\n   return this._catFile('utf-8', arguments);\n};\n\nGit.prototype.binaryCatFile = function () {\n   return this._catFile('buffer', arguments);\n};\n\nGit.prototype._catFile = function (format, args) {\n   var handler = trailingFunctionArgument(args);\n   var command = ['cat-file'];\n   var options = args[0];\n\n   if (typeof options === 'string') {\n      return this._runTask(\n         configurationErrorTask('Git.catFile: options must be supplied as an array of strings'),\n         handler,\n      );\n   }\n\n   if (Array.isArray(options)) {\n      command.push.apply(command, options);\n   }\n\n   const task = format === 'buffer'\n      ? straightThroughBufferTask(command)\n      : straightThroughStringTask(command);\n\n   return this._runTask(task, handler);\n};\n\nGit.prototype.diff = function (options, then) {\n   const task = filterString(options)\n      ? configurationErrorTask('git.diff: supplying options as a single string is no longer supported, switch to an array of strings')\n      : straightThroughStringTask(['diff', ...getTrailingOptions(arguments)]);\n\n   return this._runTask(\n      task,\n      trailingFunctionArgument(arguments),\n   );\n};\n\nGit.prototype.diffSummary = function () {\n   return this._runTask(\n      diffSummaryTask(getTrailingOptions(arguments, 1)),\n      trailingFunctionArgument(arguments),\n   );\n};\n\nGit.prototype.applyPatch = function (patches) {\n   const task = !filterStringOrStringArray(patches)\n      ? configurationErrorTask(`git.applyPatch requires one or more string patches as the first argument`)\n      : applyPatchTask(asArray(patches), getTrailingOptions([].slice.call(arguments, 1)));\n\n   return this._runTask(\n      task,\n      trailingFunctionArgument(arguments),\n   );\n}\n\nGit.prototype.revparse = function () {\n   const commands = ['rev-parse', ...getTrailingOptions(arguments, true)];\n   return this._runTask(\n      straightThroughStringTask(commands, true),\n      trailingFunctionArgument(arguments),\n   );\n};\n\n/**\n * Show various types of objects, for example the file at a certain commit\n *\n * @param {string[]} [options]\n * @param {Function} [then]\n */\nGit.prototype.show = function (options, then) {\n   return this._runTask(\n      straightThroughStringTask(['show', ...getTrailingOptions(arguments, 1)]),\n      trailingFunctionArgument(arguments)\n   );\n};\n\n/**\n */\nGit.prototype.clean = function (mode, options, then) {\n   const usingCleanOptionsArray = isCleanOptionsArray(mode);\n   const cleanMode = usingCleanOptionsArray && mode.join('') || filterType(mode, filterString) || '';\n   const customArgs = getTrailingOptions([].slice.call(arguments, usingCleanOptionsArray ? 1 : 0));\n\n   return this._runTask(\n      cleanWithOptionsTask(cleanMode, customArgs),\n      trailingFunctionArgument(arguments),\n   );\n};\n\nGit.prototype.exec = function (then) {\n   const task = {\n      commands: [],\n      format: 'utf-8',\n      parser () {\n         if (typeof then === 'function') {\n            then();\n         }\n      }\n   };\n\n   return this._runTask(task);\n};\n\n/**\n * Clears the queue of pending commands and returns the wrapper instance for chaining.\n *\n * @returns {Git}\n */\nGit.prototype.clearQueue = function () {\n   // TODO:\n   // this._executor.clear();\n   return this;\n};\n\n/**\n * Check if a pathname or pathnames are excluded by .gitignore\n *\n * @param {string|string[]} pathnames\n * @param {Function} [then]\n */\nGit.prototype.checkIgnore = function (pathnames, then) {\n   return this._runTask(\n      checkIgnoreTask(asArray((filterType(pathnames, filterStringOrStringArray, [])))),\n      trailingFunctionArgument(arguments),\n   );\n};\n\nGit.prototype.checkIsRepo = function (checkType, then) {\n   return this._runTask(\n      checkIsRepoTask(filterType(checkType, filterString)),\n      trailingFunctionArgument(arguments),\n   );\n};\n\nmodule.exports = Git;\n", "import { GitError } from './git-error';\nimport { SimpleGitOptions } from '../types';\n\n/**\n * The `GitConstructError` is thrown when an error occurs in the constructor\n * of the `simple-git` instance itself. Most commonly as a result of using\n * a `baseDir` option that points to a folder that either does not exist,\n * or cannot be read by the user the node script is running as.\n *\n * Check the `.message` property for more detail including the properties\n * passed to the constructor.\n */\nexport class GitConstructError extends GitError {\n\n   constructor (\n      public readonly config: SimpleGitOptions,\n      message: string,\n   ) {\n      super(undefined, message);\n   }\n\n}\n", "import { GitConstructError } from './errors/git-construct-error';\nimport { GitError } from './errors/git-error';\nimport { GitPluginError } from './errors/git-plugin-error';\nimport { GitResponseError } from './errors/git-response-error';\nimport { TaskConfigurationError } from './errors/task-configuration-error';\nimport { CheckRepoActions } from './tasks/check-is-repo';\nimport { CleanOptions } from './tasks/clean';\nimport { GitConfigScope } from './tasks/config';\nimport { grepQueryBuilder } from './tasks/grep';\nimport { ResetMode } from './tasks/reset';\n\nexport {\n   CheckRepoActions,\n   CleanOptions,\n   GitConfigScope,\n   GitConstructError,\n   GitError,\n   GitPluginError,\n   GitResponseError,\n   ResetMode,\n   TaskConfigurationError,\n   grepQueryBuilder,\n};\n", "import { SimpleGitOptions, SimpleGitTask } from '../types';\nimport { GitError } from './git-error';\n\nexport class GitPluginError extends GitError {\n\n   constructor (\n      public task?: SimpleGitTask<any>,\n      public readonly plugin?: keyof SimpleGitOptions,\n      message?: string,\n   ) {\n      super(task, message);\n      Object.setPrototypeOf(this, new.target.prototype);\n   }\n\n}\n", "import { prefixedArray } from '../utils';\nimport { SimpleGitPlugin } from './simple-git-plugin';\n\nexport function commandConfigPrefixingPlugin(configuration: string[]): SimpleGitPlugin<'spawn.args'> {\n   const prefix = prefixedArray(configuration, '-c');\n\n   return {\n      type: 'spawn.args',\n      action(data) {\n         return [...prefix, ...data];\n      },\n   };\n}\n", "import { deferred, DeferredPromise } from '@kwsites/promise-deferred';\nimport { SimpleGitPluginConfig } from '../types';\nimport { delay } from '../utils';\nimport { SimpleGitPlugin } from './simple-git-plugin';\n\nconst never = deferred().promise;\n\nexport function completionDetectionPlugin({\n                                             onClose = true,\n                                             onExit = 50\n                                          }: SimpleGitPluginConfig['completion'] = {}): SimpleGitPlugin<'spawn.after'> {\n\n   function createEvents() {\n      let exitCode = -1;\n      const events = {\n         close: deferred(),\n         closeTimeout: deferred(),\n         exit: deferred(),\n         exitTimeout: deferred(),\n      };\n\n      const result = Promise.race([\n         onClose === false ? never : events.closeTimeout.promise,\n         onExit === false ? never : events.exitTimeout.promise,\n      ]);\n\n      configureTimeout(onClose, events.close, events.closeTimeout);\n      configureTimeout(onExit, events.exit, events.exitTimeout);\n\n      return {\n         close(code: number) {\n            exitCode = code;\n            events.close.done();\n         },\n         exit(code: number) {\n            exitCode = code;\n            events.exit.done();\n         },\n         get exitCode() {\n            return exitCode;\n         },\n         result,\n      };\n   }\n\n   function configureTimeout(flag: boolean | number, event: DeferredPromise<void>, timeout: DeferredPromise<void>) {\n      if (flag === false) {\n         return;\n      }\n\n      (flag === true ? event.promise : event.promise.then(() => delay(flag))).then(timeout.done);\n   }\n\n   return {\n      type: 'spawn.after',\n      async action(_data, {spawned, close}) {\n         const events = createEvents();\n\n         let deferClose = true;\n         let quickClose = () => void (deferClose = false);\n\n         spawned.stdout?.on('data', quickClose);\n         spawned.stderr?.on('data', quickClose);\n         spawned.on('error', quickClose);\n\n         spawned.on('close', (code: number) => events.close(code));\n         spawned.on('exit', (code: number) => events.exit(code));\n\n         try{\n            await events.result;\n            if (deferClose) {\n               await delay(50);\n            }\n            close(events.exitCode);\n         }\n         catch (err) {\n            close(events.exitCode, err as Error);\n         }\n      }\n   }\n}\n", "import { GitError } from '../errors/git-error';\nimport { GitExecutorResult, SimpleGitPluginConfig } from '../types';\nimport { SimpleGitPlugin } from './simple-git-plugin';\n\ntype TaskResult = Omit<GitExecutorResult, 'rejection'>;\n\nfunction isTaskError (result: TaskResult) {\n   return !!(result.exitCode && result.stdErr.length);\n}\n\nfunction getErrorMessage (result: TaskResult) {\n   return Buffer.concat([...result.stdOut, ...result.stdErr]);\n}\n\nexport function errorDetectionHandler (overwrite = false, isError = isTaskError, errorMessage: (result: TaskResult) => Buffer | Error = getErrorMessage) {\n\n   return (error: Buffer | Error | undefined, result: TaskResult) => {\n      if ((!overwrite && error) || !isError(result)) {\n         return error;\n      }\n\n      return errorMessage(result);\n   };\n}\n\nexport function errorDetectionPlugin(config: SimpleGitPluginConfig['errors']): SimpleGitPlugin<'task.error'> {\n\n   return {\n      type: 'task.error',\n      action(data, context) {\n         const error = config(data.error, {\n            stdErr: context.stdErr,\n            stdOut: context.stdOut,\n            exitCode: context.exitCode\n         });\n\n         if (Buffer.isBuffer(error)) {\n            return {error: new GitError(undefined, error.toString('utf-8'))};\n         }\n\n         return {\n            error\n         };\n      },\n   };\n\n}\n", "import { SimpleGitPlugin, SimpleGitPluginType, SimpleGitPluginTypes } from './simple-git-plugin';\nimport { append, asArray } from '../utils';\n\nexport class PluginStore {\n\n   private plugins: Set<SimpleGitPlugin<SimpleGitPluginType>> = new Set();\n\n   public add<T extends SimpleGitPluginType>(plugin: void | SimpleGitPlugin<T> | SimpleGitPlugin<T>[]) {\n      const plugins: SimpleGitPlugin<T>[] = [];\n\n      asArray(plugin).forEach(plugin => plugin && this.plugins.add(append(plugins, plugin)));\n\n      return () => {\n         plugins.forEach(plugin => this.plugins.delete(plugin));\n      };\n   }\n\n   public exec<T extends SimpleGitPluginType>(type: T, data: SimpleGitPluginTypes[T]['data'], context: SimpleGitPluginTypes[T]['context']): typeof data {\n      let output = data;\n      const contextual = Object.freeze(Object.create(context));\n\n      for (const plugin of this.plugins) {\n         if (plugin.type === type) {\n            output = plugin.action(output, contextual);\n         }\n      }\n\n      return output;\n   }\n\n}\n", "import { SimpleGitOptions } from '../types';\nimport { asNumber, including } from '../utils';\n\nimport { SimpleGitPlugin } from './simple-git-plugin';\n\nexport function progressMonitorPlugin(progress: Exclude<SimpleGitOptions['progress'], void>) {\n   const progressCommand = '--progress';\n   const progressMethods = ['checkout', 'clone', 'fetch', 'pull', 'push'];\n\n   const onProgress: SimpleGitPlugin<'spawn.after'> = {\n      type: 'spawn.after',\n      action(_data, context) {\n         if (!context.commands.includes(progressCommand)) {\n            return;\n         }\n\n         context.spawned.stderr?.on('data', (chunk: Buffer) => {\n            const message = /^([\\s\\S]+?):\\s*(\\d+)% \\((\\d+)\\/(\\d+)\\)/.exec(chunk.toString('utf8'));\n            if (!message) {\n               return;\n            }\n\n            progress({\n               method: context.method,\n               stage: progressEventStage(message[1]),\n               progress: asNumber(message[2]),\n               processed: asNumber(message[3]),\n               total: asNumber(message[4]),\n            });\n         });\n      }\n   };\n\n   const onArgs: SimpleGitPlugin<'spawn.args'> = {\n      type: 'spawn.args',\n      action(args, context) {\n         if (!progressMethods.includes(context.method)) {\n            return args;\n         }\n\n         return including(args, progressCommand);\n      }\n   }\n\n   return [onArgs, onProgress];\n}\n\nfunction progressEventStage (input: string) {\n   return String(input.toLowerCase().split(' ', 1)) || 'unknown';\n}\n", "import { SpawnOptions } from 'child_process';\nimport { pick } from '../utils';\nimport { SimpleGitPlugin } from './simple-git-plugin';\n\nexport function spawnOptionsPlugin(spawnOptions: Partial<SpawnOptions>): SimpleGitPlugin<'spawn.options'> {\n   const options = pick(spawnOptions, ['uid', 'gid']);\n\n   return {\n      type: 'spawn.options',\n      action(data) {\n         return {...options, ...data};\n      },\n   };\n}\n", "import { SimpleGitOptions } from '../types';\n\nimport { SimpleGitPlugin } from './simple-git-plugin';\nimport { GitPluginError } from '../errors/git-plugin-error';\n\nexport function timeoutPlugin({block}: Exclude<SimpleGitOptions['timeout'], undefined>): SimpleGitPlugin<'spawn.after'> | void {\n\n   if (block > 0) {\n      return {\n         type: 'spawn.after',\n         action(_data, context) {\n            let timeout: NodeJS.Timeout;\n\n            function wait() {\n               timeout && clearTimeout(timeout);\n               timeout = setTimeout(kill, block);\n            }\n\n            function stop() {\n               context.spawned.stdout?.off('data', wait);\n               context.spawned.stderr?.off('data', wait);\n               context.spawned.off('exit', stop);\n               context.spawned.off('close', stop);\n               timeout && clearTimeout(timeout);\n            }\n\n            function kill() {\n               stop()\n               context.kill(\n                  new GitPluginError(undefined, 'timeout', `block timeout reached`)\n               );\n            }\n\n            context.spawned.stdout?.on('data', wait);\n            context.spawned.stderr?.on('data', wait);\n            context.spawned.on('exit', stop);\n            context.spawned.on('close', stop);\n\n            wait();\n         }\n      }\n   }\n\n}\n", "import { SimpleGitFactory } from '../../typings';\n\nimport * as api from './api';\nimport {\n   commandConfigPrefixingPlugin,\n   completionDetectionPlugin,\n   errorDetectionHandler,\n   errorDetectionPlugin,\n   PluginStore,\n   progressMonitorPlugin,\n   spawnOptionsPlugin,\n   timeoutPlugin\n} from './plugins';\nimport { createInstanceConfig, folderExists } from './utils';\nimport { SimpleGitOptions } from './types';\n\nconst Git = require('../git');\n\n/**\n * Adds the necessary properties to the supplied object to enable it for use as\n * the default export of a module.\n *\n * Eg: `module.exports = esModuleFactory({ something () {} })`\n */\nexport function esModuleFactory<T>(defaultExport: T) {\n   return Object.defineProperties(defaultExport, {\n      __esModule: {value: true},\n      default: {value: defaultExport},\n   }) as T & { __esModule: true, default: T };\n}\n\nexport function gitExportFactory(factory: SimpleGitFactory) {\n   return Object.assign(factory.bind(null), api);\n}\n\nexport function gitInstanceFactory(baseDir?: string | Partial<SimpleGitOptions>, options?: Partial<SimpleGitOptions>) {\n   const plugins = new PluginStore();\n   const config = createInstanceConfig(\n      baseDir && (typeof baseDir === 'string' ? {baseDir} : baseDir) || {},\n      options\n   );\n\n   if (!folderExists(config.baseDir)) {\n      throw new api.GitConstructError(config, `Cannot use simple-git on a directory that does not exist`);\n   }\n\n   if (Array.isArray(config.config)) {\n      plugins.add(commandConfigPrefixingPlugin(config.config));\n   }\n\n   plugins.add(completionDetectionPlugin(config.completion));\n   config.progress && plugins.add(progressMonitorPlugin(config.progress));\n   config.timeout && plugins.add(timeoutPlugin(config.timeout));\n   config.spawnOptions && plugins.add(spawnOptionsPlugin(config.spawnOptions));\n\n   plugins.add(errorDetectionPlugin(errorDetectionHandler(true)));\n   config.errors && plugins.add(errorDetectionPlugin(config.errors));\n\n   return new Git(config, plugins);\n}\n", "import { SimpleGit, SimpleGitOptions } from '../../../typings';\n\nimport { GitResponseError } from '../errors/git-response-error';\nimport { gitInstanceFactory } from '../git-factory';\nimport { SimpleGitTaskCallback } from '../types';\n\nconst functionNamesBuilderApi = [\n   'customBinary', 'env', 'outputHandler', 'silent',\n];\n\nconst functionNamesPromiseApi = [\n   'add',\n   'addAnnotatedTag',\n   'addConfig',\n   'addRemote',\n   'addTag',\n   'applyPatch',\n   'binaryCatFile',\n   'branch',\n   'branchLocal',\n   'catFile',\n   'checkIgnore',\n   'checkIsRepo',\n   'checkout',\n   'checkoutBranch',\n   'checkoutLatestTag',\n   'checkoutLocalBranch',\n   'clean',\n   'clone',\n   'commit',\n   'cwd',\n   'deleteLocalBranch',\n   'deleteLocalBranches',\n   'diff',\n   'diffSummary',\n   'exec',\n   'fetch',\n   'getRemotes',\n   'init',\n   'listConfig',\n   'listRemote',\n   'log',\n   'merge',\n   'mergeFromTo',\n   'mirror',\n   'mv',\n   'pull',\n   'push',\n   'pushTags',\n   'raw',\n   'rebase',\n   'remote',\n   'removeRemote',\n   'reset',\n   'revert',\n   'revparse',\n   'rm',\n   'rmKeepLocal',\n   'show',\n   'stash',\n   'stashList',\n   'status',\n   'subModule',\n   'submoduleAdd',\n   'submoduleInit',\n   'submoduleUpdate',\n   'tag',\n   'tags',\n   'updateServerInfo'\n];\n\nexport function gitP(...args: [] | [string] | [Partial<SimpleGitOptions>] | [string, Partial<SimpleGitOptions>]): SimpleGit {\n\n   let git: any;\n\n   let chain = Promise.resolve();\n\n   try {\n      git = gitInstanceFactory(...args);\n   } catch (e) {\n      chain = Promise.reject(e);\n   }\n\n   function builderReturn() {\n      return promiseApi;\n   }\n\n   function chainReturn() {\n      return chain;\n   }\n\n   const promiseApi = [...functionNamesBuilderApi, ...functionNamesPromiseApi].reduce((api: any, name: string) => {\n      const isAsync = functionNamesPromiseApi.includes(name);\n\n      const valid = isAsync ? asyncWrapper(name, git) : syncWrapper(name, git, api);\n      const alternative = isAsync ? chainReturn : builderReturn;\n\n      Object.defineProperty(api, name, {\n         enumerable: false,\n         configurable: false,\n         value: git ? valid : alternative,\n      });\n\n      return api;\n   }, {});\n\n   return promiseApi as SimpleGit;\n\n   function asyncWrapper(fn: string, git: any): (...args: any[]) => Promise<any> {\n      return function (...args: any[]) {\n         if (typeof args[args.length] === 'function') {\n            throw new TypeError(\n               'Promise interface requires that handlers are not supplied inline, ' +\n               'trailing function not allowed in call to ' + fn);\n         }\n\n         return chain.then(function () {\n            return new Promise(function (resolve, reject) {\n               const callback: SimpleGitTaskCallback = (err: Error | null, result?: any) => {\n                  if (err) {\n                     return reject(toError(err));\n                  }\n\n                  resolve(result);\n               };\n               args.push(callback);\n\n               git[fn].apply(git, args);\n            });\n         });\n      };\n   }\n\n   function syncWrapper(fn: string, git: any, api: SimpleGit) {\n      return (...args: any[]) => {\n         git[fn](...args);\n\n         return api;\n      };\n   }\n}\n\nfunction toError(error: Error | string | any): Error {\n\n   if (error instanceof Error) {\n      return error;\n   }\n\n   if (typeof error === 'string') {\n      return new Error(error);\n   }\n\n   return new GitResponseError(error);\n}\n", "import { gitInstanceFactory } from './lib/git-factory';\n\nexport {gitP} from './lib/runners/promise-wrapped';\nexport * from './lib/api';\n\nexport const simpleGit = gitInstanceFactory;\n\nexport default gitInstanceFactory;\n"],
-  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,IA2BO;AA3BP;AAAA;AA2BO,6BAAuB,MAAM;AAAA,MAEjC,YACU,MACP,SACD;AACC,cAAM;AAHC;AAIP,eAAO,eAAe,MAAM,WAAW;AAAA;AAAA;AAAA;AAAA;;;AClC7C,IAsBO;AAtBP;AAAA;AAAA;AAsBO,qCAAwC,SAAS;AAAA,MAErD,YAImB,KAChB,SACD;AACC,cAAM,QAAW,WAAW,OAAO;AAHnB;AAAA;AAAA;AAAA;AAAA;;;AC5BtB,IAUO;AAVP;AAAA;AAAA;AAUO,2CAAqC,SAAS;AAAA,MAElD,YACG,SACD;AACC,cAAM,QAAW;AAAA;AAAA;AAAA;AAAA;;;ACfvB;AAYO,oBAAyC,QAAoB;AACjE,SAAO,OAAO,WAAW,aAAa,SAAS;AAAA;AAO3C,wBAA4C,QAA8B;AAC9E,SAAQ,OAAO,WAAW,cAAc,WAAW;AAAA;AAG/C,iBAAiB,OAAe,MAAgC;AACpE,QAAM,QAAQ,MAAM,QAAQ;AAC5B,MAAI,SAAS,GAAG;AACb,WAAO,CAAC,OAAO;AAAA;AAGlB,SAAO;AAAA,IACJ,MAAM,OAAO,GAAG;AAAA,IAChB,MAAM,OAAO,QAAQ;AAAA;AAAA;AAMpB,eAAe,OAA2B,SAAS,GAAmB;AAC1E,SAAO,YAAY,UAAU,MAAM,SAAS,SAAS,MAAM,UAAU;AAAA;AAMjE,cAAc,OAAgB,SAAS,GAAG;AAC9C,MAAI,YAAY,UAAU,MAAM,SAAS,QAAQ;AAC9C,WAAO,MAAM,MAAM,SAAS,IAAI;AAAA;AAAA;AAMtC,qBAAqB,OAAgC;AAClD,SAAO,CAAC,CAAE,UAAS,OAAO,MAAM,WAAW;AAAA;AAGvC,4BAA4B,QAAQ,IAAI,WAAU,MAAM,YAAY,MAAgB;AACxF,SAAO,MAAM,MAAM,WACf,OAAO,CAAC,QAAQ,SAAS;AACvB,UAAM,cAAc,WAAU,KAAK,SAAS;AAC5C,QAAI,aAAa;AACd,aAAO,KAAK;AAAA;AAEf,WAAO;AAAA,KACP;AAAA;AAKF,gCAAmC,OAAe,UAA2C;AACjG,SAAO,mBAAmB,OAAO,MAAM,IAAI,UAAQ,SAAS;AAAA;AAGxD,sBAAsB,MAAuB;AACjD,SAAO,OAAO,MAAM;AAAA;AAMhB,gBAAmB,QAAsB,MAAsB;AACnE,MAAI,MAAM,QAAQ,SAAS;AACxB,QAAI,CAAC,OAAO,SAAS,OAAO;AACzB,aAAO,KAAK;AAAA;AAAA,SAEX;AACJ,WAAO,IAAI;AAAA;AAEd,SAAO;AAAA;AAMH,mBAAsB,QAAa,MAAwB;AAC/D,MAAI,MAAM,QAAQ,WAAW,CAAC,OAAO,SAAS,OAAO;AAClD,WAAO,KAAK;AAAA;AAGf,SAAO;AAAA;AAGH,gBAAmB,QAAsB,MAAY;AACzD,MAAI,MAAM,QAAQ,SAAS;AACxB,UAAM,QAAQ,OAAO,QAAQ;AAC7B,QAAI,SAAS,GAAG;AACb,aAAO,OAAO,OAAO;AAAA;AAAA,SAEpB;AACJ,WAAO,OAAO;AAAA;AAEjB,SAAO;AAAA;AAKH,iBAAoB,QAAsB;AAC9C,SAAO,MAAM,QAAQ,UAAU,SAAS,CAAC;AAAA;AAGrC,uBAA0B,QAA2B;AACzD,SAAO,QAAQ,QAAQ,IAAI;AAAA;AAGvB,kBAAkB,QAAmC,QAAQ,GAAG;AACpE,MAAI,UAAU,MAAM;AACjB,WAAO;AAAA;AAGV,QAAM,MAAM,SAAS,QAAQ;AAC7B,SAAO,MAAM,OAAO,QAAQ;AAAA;AAGxB,uBAA0B,OAAY,QAAgB;AAC1D,QAAM,SAAc;AACpB,WAAS,IAAI,GAAG,MAAM,MAAM,QAAQ,IAAI,KAAK,KAAK;AAC/C,WAAO,KAAK,QAAQ,MAAM;AAAA;AAE7B,SAAO;AAAA;AAGH,wBAAwB,OAAkC;AAC9D,SAAQ,OAAM,QAAQ,SAAS,OAAO,OAAO,SAAS,OAAO,SAAS;AAAA;AAMlE,cAAc,QAA6B,YAAsB;AACrE,SAAO,OAAO,OAAO,IAAI,GAAG,WAAW,IAAI,CAAC,aAAa,YAAY,SAAS,GAAE,WAAW,OAAO,cAAa;AAAA;AAG3G,eAAe,WAAW,GAAkB;AAChD,SAAO,IAAI,QAAQ,UAAQ,WAAW,MAAM;AAAA;AA1J/C,IAGa,MAEA,MA8GA;AAnHb;AAAA;AAGO,IAAM,OAAO;AAEb,IAAM,OAAiC,MAAM;AAAA;AA8G7C,IAAM,iBAAiB,OAAO,UAAU,SAAS,KAAK,KAAK,OAAO,UAAU;AAAA;AAAA;;;AC1G5E,oBAA0B,OAAU,QAAoC,KAAmB;AAC/F,MAAI,OAAO,QAAQ;AAChB,WAAO;AAAA;AAEV,SAAQ,UAAU,SAAS,IAAK,MAAM;AAAA;AAOlC,0BAA0B,OAAgB,MAAoE;AAClH,SAAO,wBAAwB,KAAK,OAAO,UAAW,EAAC,QAAQ,CAAC,KAAK,SAAU,OAAO;AAAA;AAgBlF,2BAA6C,OAAgC;AACjF,SAAO,CAAC,CAAC,SAAS,eAAe,WAAW;AAAA;AAGxC,wBAAwB,OAAmC;AAC/D,SAAO,OAAO,UAAU;AAAA;AA1C3B,IAgBa,aAQA,cAIA,mBAIA,2BAaA;AA7Cb;AAAA;AACA;AAeO,IAAM,cAAmD,CAAC,UAA+B;AAC7F,aAAO,MAAM,QAAQ;AAAA;AAOjB,IAAM,eAAgD,CAAC,UAA2B;AACtF,aAAO,OAAO,UAAU;AAAA;AAGpB,IAAM,oBAAuD,CAAC,UAA6B;AAC/F,aAAO,MAAM,QAAQ,UAAU,MAAM,MAAM;AAAA;AAGvC,IAAM,4BAAwE,CAAC,UAAsC;AACzH,aAAO,aAAa,UAAW,MAAM,QAAQ,UAAU,MAAM,MAAM;AAAA;AAY/D,IAAM,kBAA+D,CAAC,UAAuC;AACjH,UAAI,SAAS,QAAQ,0BAA0B,SAAS,OAAO,QAAQ;AACpE,eAAO;AAAA;AAEV,aAAO,MAAM,QAAQ,UAAU,OAAO,UAAU,YAAY,OAAO,MAAM,WAAW;AAAA;AAAA;AAAA;;;ACjDvF,IAIY;AAJZ;AAAA;AAIO,IAAK,YAAL,kBAAK,eAAL;AACJ;AACA;AACA,yCAAU,OAAV;AAHS;AAAA;AAAA;AAAA;;;ACJZ,IAEO;AAFP;AAAA;AAEO,6BAA8D;AAAA,MAElE,YAA4B,QAA2B,QAAW;AAAtC;AAA2B;AAAA;AAAA,MAGvD,YAAsC;AACnC,eAAO,IAAI,iBAAiB,KAAK,OAAO,SAAS,SAAS,KAAK,OAAO,SAAS;AAAA;AAAA;AAAA;AAAA;;;ACRrF,IAAO,YAsDA;AAtDP;AAAA;AAAO,uBAAoB;AAAA,MAMxB,YACG,QACA,YACD;AAPQ,uBAAoB;AAc9B,qBAAQ,CAAC,MAAgD,WAAuB;AAC7E,eAAK;AAEL,cAAI,CAAC,KAAK,QAAQ,MAAM,CAAC,KAAK,UAAU,KAAK,SAAS,KAAK,OAAO,KAAK,UAAU;AAC9E,mBAAO;AAAA;AAGV,iBAAO,KAAK,WAAW,QAAQ,KAAK,sBAAsB;AAAA;AAb1D,aAAK,UAAU,MAAM,QAAQ,UAAU,SAAS,CAAC;AACjD,YAAI,YAAY;AACb,eAAK,aAAa;AAAA;AAAA;AAAA,MAed,WAAW,QAAW,OAAiC;AAC9D,cAAM,IAAI,MAAM;AAAA;AAAA,MAGT,eAAe;AACtB,aAAK,QAAQ,SAAS;AAAA;AAAA,MAGf,iBAAiB;AACxB,eAAO,KAAK;AAAA;AAAA,MAGL,SAAS,KAAa,OAAe,MAAe;AAC3D,cAAM,UAAU,QAAQ,IAAI,KAAK;AACjC,YAAI,SAAS;AACV,eAAK,UAAU,OAAO;AAAA;AAGzB,eAAO,CAAC,CAAC;AAAA;AAAA,MAGF,UAAU,QAAgB,SAAmB;AACpD,aAAK,QAAQ,KAAK,GAAG,QAAQ,MAAM;AAAA;AAAA;AAKlC,qCAAkC,WAAc;AAAA,MAE1C,SAAS,KAAa,OAAe,MAAwB;AACpE,eAAO,aAAa,KAAK,OAAO,UAAU,MAAM,SAAS,KAAK,OAAO;AAAA;AAAA,MAG9D,UAAU,OAAe,SAAmB;AACnD,YAAI,QAAQ,KAAK,QAAQ,SAAS,GAAG;AAClC,gBAAM,UAAU,OAAO;AAAA;AAAA;AAAA;AAAA;AAAA;;;ACtDzB,iCAAiC,SAAyE;AAC9G,QAAM,UAAU,QAAQ;AACxB,QAAM,SAA2B,OAAO,OAAO,iBAAC,WAAY,iBACzD,GAAI,QAAQ,OAAO,OAAK,OAAO,MAAM,YAAY;AAGpD,SAAO,UAAU,OAAO,WAAW;AAEnC,SAAO;AAAA;AAhBV,IAEM;AAFN;AAAA;AAEA,IAAM,iBAAoD;AAAA,MACvD,QAAQ;AAAA,MACR,wBAAwB;AAAA,MACxB,QAAQ;AAAA;AAAA;AAAA;;;ACDJ,2BAAwD,SAAmB,WAAqB,IAAc;AAClH,MAAI,CAAC,kBAA2B,UAAU;AACvC,WAAO;AAAA;AAGV,SAAO,OAAO,KAAK,SAAS,OAAO,CAAC,WAAoB,QAAgB;AACrE,UAAM,QAAuB,QAAQ;AAErC,QAAI,iBAAiB,OAAO,CAAC,aAAa;AACvC,gBAAS,KAAK,MAAM,MAAM;AAAA,WACtB;AACJ,gBAAS,KAAK;AAAA;AAGjB,WAAO;AAAA,KACP;AAAA;AAGC,4BAA4B,MAAkB,mBAAmB,GAAG,aAAa,OAAiB;AACtG,QAAM,UAAoB;AAE1B,WAAS,IAAI,GAAG,MAAM,mBAAmB,IAAI,KAAK,SAAS,kBAAkB,IAAI,KAAK,KAAK;AACxF,QAAI,gBAAgB,SAAS,OAAO,KAAK,KAAK;AAC3C,cAAQ,KAAK,OAAO,KAAK;AAAA;AAAA;AAI/B,oBAAkB,wBAAwB,OAAO;AACjD,MAAI,CAAC,YAAY;AACd,YAAQ,KAAK,GAAG,sBAAsB;AAAA;AAGzC,SAAO;AAAA;AAGV,+BAA+B,MAAkB;AAC9C,QAAM,sBAAsB,OAAO,KAAK,UAAU;AAClD,SAAO,WACJ,KAAK,MAAM,sBAAsB,IAAI,IAAI,aAAa;AAAA;AAQrD,iCAAiC,MAAkC;AACvE,QAAM,sBAAsB,eAAe,KAAK;AAChD,SAAO,WAAW,KAAK,MAAM,sBAAsB,IAAI,IAAI;AAAA;AAOvD,kCAAkC,MAAwC,cAAc,MAA0C;AACtI,QAAM,WAAW,WAAW,KAAK;AACjC,SAAO,eAAe,eAAe,YAAY,WAAW;AAAA;AA7D/D;AAAA;AAAA;AACA;AAAA;AAAA;;;ACIO,wBAAoE,SAAqC,SAAkC;AAC/I,SAAO,QAAO,QAAQ,QAAQ,QAAQ;AAAA;AAGlC,6BAAgC,QAAW,WAA0B,OAA2B,OAAO,MAAS;AACpH,UAAQ,OAAO,QAAQ,UAAQ;AAC5B,aAAS,QAAQ,mBAAmB,MAAM,OAAO,IAAI,GAAG,MAAM,MAAM,QAAQ,IAAI,KAAK,KAAK;AACvF,YAAM,OAAO,CAAC,SAAS,MAAM;AAC1B,YAAK,IAAI,UAAW,KAAK;AACtB;AAAA;AAEH,eAAO,MAAM,IAAI;AAAA;AAGpB,gBAAQ,KAAK,CAAC,EAAC,YAAW,MAAM,MAAM;AAAA;AAAA;AAI5C,SAAO;AAAA;AAvBV;AAAA;AAGA;AAAA;AAAA;;;ACHA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;;;ACRA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAqBO,yBAAyB,QAAsD;AACnF,UAAQ;AAAA,SACA;AACF,aAAO;AAAA,SACL;AACF,aAAO;AAAA;AAGb,QAAM,WAAW,CAAC,aAAa;AAE/B,SAAO;AAAA,IACJ;AAAA,IACA,QAAQ;AAAA,IACR;AAAA,IACA;AAAA;AAAA;AAKC,+BAAoD;AACxD,QAAM,WAAW,CAAC,aAAa;AAE/B,SAAO;AAAA,IACJ;AAAA,IACA,QAAQ;AAAA,IACR;AAAA,IACA,OAAO,MAAM;AACV,aAAO,aAAa,KAAK,KAAK;AAAA;AAAA;AAAA;AAMhC,+BAAoD;AACxD,QAAM,WAAW,CAAC,aAAa;AAE/B,SAAO;AAAA,IACJ;AAAA,IACA,QAAQ;AAAA,IACR;AAAA,IACA;AAAA;AAAA;AAKN,0BAA0B,OAAuB;AAC9C,SAAO,8CAA8C,KAAK,OAAO;AAAA;AAnEpE,IAGY,kBAMN,SAQA;AAjBN;AAAA;AAAA;AAGO,IAAK,mBAAL,kBAAK,sBAAL;AACJ,kCAAO;AACP,qCAAU;AACV,0CAAe;AAHN;AAAA;AAMZ,IAAM,UAA0C,CAAC,EAAC,YAAW,OAAO,MAAM,SAAS;AAChF,UAAI,aAAa,qBAAqB,iBAAiB,QAAQ;AAC5D,eAAO,KAAK,OAAO,KAAK;AAAA;AAG3B,WAAK;AAAA;AAGR,IAAM,SAAwC,CAAC,SAAS;AACrD,aAAO,KAAK,WAAW;AAAA;AAAA;AAAA;;;ACCnB,4BAA6B,QAAiB,MAA4B;AAC9E,QAAM,UAAU,IAAI,cAAc;AAClC,QAAM,SAAS,SAAS,sBAAsB;AAE9C,qBAAmB,MAAM,QAAQ,UAAQ;AACtC,UAAM,UAAU,KAAK,QAAQ,QAAQ;AAErC,YAAQ,MAAM,KAAK;AACnB,IAAC,gBAAe,KAAK,WAAW,QAAQ,UAAU,QAAQ,OAAO,KAAK;AAAA;AAGzE,SAAO;AAAA;AA9BV,IAGO,eAYD,eACA,qBACA;AAjBN;AAAA;AACA;AAEO,0BAA4C;AAAA,MAMhD,YACmB,QACjB;AADiB;AALZ,qBAAkB;AAClB,qBAAkB;AAClB,uBAAoB;AAAA;AAAA;AAQ9B,IAAM,gBAAgB;AACtB,IAAM,sBAAsB;AAC5B,IAAM,iBAAiB;AAAA;AAAA;;;ACjBvB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAaO,uBAAuB,SAAoC;AAC/D,SAAO;AAAA,IACJ,UAAU;AAAA,IACV,QAAQ;AAAA,IACR;AAAA;AAAA;AAIC,gCAAgC,OAAkC;AACtE,SAAO;AAAA,IACJ,UAAU;AAAA,IACV,QAAQ;AAAA,IACR,SAAS;AACN,YAAM,OAAO,UAAU,WAAW,IAAI,uBAAuB,SAAS;AAAA;AAAA;AAAA;AAKxE,mCAAmC,UAAoB,WAAU,OAA2B;AAChG,SAAO;AAAA,IACJ;AAAA,IACA,QAAQ;AAAA,IACR,OAAO,MAAM;AACV,aAAO,WAAU,OAAO,MAAM,SAAS;AAAA;AAAA;AAAA;AAKzC,mCAAmC,UAAqC;AAC5E,SAAO;AAAA,IACJ;AAAA,IACA,QAAQ;AAAA,IACR,OAAO,QAAQ;AACZ,aAAO;AAAA;AAAA;AAAA;AAKT,sBAAyB,MAA+C;AAC5E,SAAO,KAAK,WAAW;AAAA;AAGnB,qBAAwB,MAA2C;AACvE,SAAO,KAAK,WAAW,WAAW,CAAC,KAAK,SAAS;AAAA;AAxDpD,IAGa;AAHb;AAAA;AAAA;AAGO,IAAM,iBAAqB;AAAA;AAAA;;;ACHlC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AA+BO,8BAA8B,MAA0B,YAAsB;AAClF,QAAM,EAAC,WAAW,SAAS,UAAS,gBAAgB;AAEpD,MAAI,CAAC,WAAW;AACb,WAAO,uBAAuB;AAAA;AAGjC,MAAI,CAAC,MAAM,SAAS;AACjB,WAAO,uBAAuB,8BAA8B,KAAK,UAAU;AAAA;AAG9E,UAAQ,KAAK,GAAG;AAEhB,MAAI,QAAQ,KAAK,oBAAoB;AAClC,WAAO,uBAAuB;AAAA;AAGjC,SAAO,UAAU,WAAW;AAAA;AAGxB,mBAAmB,MAAiB,YAAgD;AACxF,QAAM,WAAqB,CAAC,SAAS,IAAI,QAAQ,GAAG;AAEpD,SAAO;AAAA,IACJ;AAAA,IACA,QAAQ;AAAA,IACR,OAAO,MAA4B;AAChC,aAAO,mBAAmB,SAAS,mBAAsB;AAAA;AAAA;AAAA;AAK3D,6BAA8B,OAA0C;AAC5E,SAAO,MAAM,QAAQ,UAAU,MAAM,MAAM,UAAQ,kBAAkB,IAAI;AAAA;AAG5E,yBAAyB,OAAe;AACrC,MAAI;AACJ,MAAI,UAAoB;AACxB,MAAI,QAAQ,EAAC,WAAW,OAAO,SAAS;AAExC,QAAM,QAAQ,YAAY,IAAI,MAAM,IAAI,QAAQ,UAAQ;AACrD,QAAI,YAAY,OAAO;AACpB,kBAAY;AACZ,YAAM,YAAY;AAAA,WAEhB;AACF,YAAM,UAAU,MAAM,WAAW,cAAc,QAAQ,QAAQ,UAAW,IAAI;AAAA;AAAA;AAIpF,SAAO;AAAA,IACJ;AAAA,IACA;AAAA,IACA;AAAA;AAAA;AAIN,qBAAqB,WAA4C;AAC9D,SAAO,cAAc,mBAAsB,cAAc;AAAA;AAG5D,uBAAuB,QAAyB;AAC7C,SAAO,YAAY,KAAK,WAAW,kBAAkB,IAAI,OAAO,OAAO;AAAA;AAG1E,2BAA2B,QAAyB;AACjD,MAAI,UAAU,KAAK,SAAS;AACzB,WAAO,OAAO,QAAQ,OAAO;AAAA;AAGhC,SAAO,WAAW;AAAA;AAtGrB,IAMa,+BACA,4BACA,6BAKD,cAgBN;AA7BN;AAAA;AACA;AAEA;AACA;AAEO,IAAM,gCAAgC;AACtC,IAAM,6BAA6B;AACnC,IAAM,8BAA8B;AAKpC,IAAK,eAAL,kBAAK,kBAAL;AACJ,iCAAU;AACV,+BAAQ;AACR,0CAAmB;AACnB,sCAAe;AACf,mCAAY;AACZ,+BAAQ;AACR,mCAAY;AAPH;AAAA;AAgBZ,IAAM,oBAAiC,oBAAI,IAAI,CAAC,KAAK,GAAG,cAAc,OAAO,OAAO;AAAA;AAAA;;;ACkB7E,0BAA0B,MAA0B;AACxD,QAAM,SAAS,IAAI;AAEnB,aAAW,QAAQ,aAAa,OAAO;AACpC,WAAO,SAAS,KAAK,MAAM,OAAO,KAAK,MAAM,KAAK;AAAA;AAGrD,SAAO;AAAA;AAGH,yBAAyB,MAAc,KAA8B;AACzE,MAAI,QAAuB;AAC3B,QAAM,SAAmB;AACzB,QAAM,SAAgC,oBAAI;AAE1C,aAAW,QAAQ,aAAa,MAAM,MAAM;AACzC,QAAI,KAAK,QAAQ,KAAK;AACnB;AAAA;AAGH,WAAO,KAAK,QAAQ,KAAK;AAEzB,QAAI,CAAC,OAAO,IAAI,KAAK,OAAO;AACzB,aAAO,IAAI,KAAK,MAAM;AAAA;AAGzB,WAAO,IAAI,KAAK,MAAO,KAAK;AAAA;AAG/B,SAAO;AAAA,IACJ;AAAA,IACA,OAAO,MAAM,KAAK,OAAO;AAAA,IACzB;AAAA,IACA;AAAA,IACA;AAAA;AAAA;AAIN,wBAAwB,UAA0B;AAC/C,SAAO,SAAS,QAAQ,YAAY;AAAA;AAGvC,uBAAuB,MAAc,eAA8B,MAAM;AACtE,QAAM,QAAQ,KAAK,MAAM;AAEzB,WAAS,IAAI,GAAG,MAAM,MAAM,SAAS,GAAG,IAAI,OAAM;AAC/C,UAAM,OAAO,eAAe,MAAM;AAElC,QAAI,QAAQ,MAAM;AAClB,QAAI,MAAM;AAEV,QAAI,MAAM,SAAS,OAAO;AACvB,YAAM,OAAO,QAAQ,OAAO;AAC5B,YAAM,KAAK;AACX,cAAQ,KAAK;AAAA;AAGhB,UAAM,EAAC,MAAM,KAAK;AAAA;AAAA;AAxGxB,IAGO;AAHP;AAAA;AACA;AAEO,uBAA8C;AAAA,MAA9C,cAHP;AAKU,qBAAkB;AAClB,sBAA+C,uBAAO,OAAO;AAAA;AAAA,UAIzD,MAAoB;AAC5B,YAAI,CAAC,KAAK,MAAM;AACb,eAAK,OAAO,KAAK,MAAM,OAAO,CAAC,KAAmB,SAAiB;AAChE,mBAAO,OAAO,OAAO,KAAK,KAAK,OAAO;AAAA,aACtC;AAAA;AAGN,eAAO,KAAK;AAAA;AAAA,MAGR,QAAQ,MAA4B;AACxC,YAAI,CAAE,SAAQ,KAAK,SAAS;AACzB,gBAAM,SAAS,KAAK,KAAK;AACzB,eAAK,OAAO,QAAQ,SAAS,OAAO,OAAO,KAAK,OAAO,WAAW;AAElE,eAAK,MAAM,KAAK;AAAA;AAGnB,eAAO,KAAK,OAAO;AAAA;AAAA,MAGf,SAAS,MAAc,KAAa,OAAe;AACvD,cAAM,SAAS,KAAK,QAAQ;AAE5B,YAAI,CAAC,OAAO,eAAe,MAAM;AAC9B,iBAAO,OAAO;AAAA,mBACN,MAAM,QAAQ,OAAO,OAAO;AACpC,UAAC,OAAO,KAAkB,KAAK;AAAA,eAC3B;AACJ,iBAAO,OAAO,CAAC,OAAO,MAAgB;AAAA;AAGzC,aAAK,OAAO;AAAA;AAAA;AAAA;AAAA;;;AC7BlB,uBAA6D,OAAiC,UAAiC;AAC5H,MAAI,OAAO,UAAU,YAAY,eAAe,eAAe,QAAQ;AACpE,WAAO;AAAA;AAEV,SAAO;AAAA;AAGV,uBAAuB,KAAa,OAAe,SAAiB,OAA2C;AAC5G,QAAM,WAAqB,CAAC,UAAU,KAAK;AAE3C,MAAI,SAAQ;AACT,aAAS,KAAK;AAAA;AAGjB,WAAS,KAAK,KAAK;AAEnB,SAAO;AAAA,IACJ;AAAA,IACA,QAAQ;AAAA,IACR,OAAO,MAAsB;AAC1B,aAAO;AAAA;AAAA;AAAA;AAKhB,uBAAuB,KAAa,OAAqD;AACtF,QAAM,WAAqB,CAAC,UAAU,UAAU,iBAAiB,aAAa;AAE9E,MAAI,OAAO;AACR,aAAS,OAAO,GAAG,GAAG,KAAK;AAAA;AAG9B,SAAO;AAAA,IACJ;AAAA,IACA,QAAQ;AAAA,IACR,OAAO,MAAM;AACV,aAAO,gBAAgB,MAAM;AAAA;AAAA;AAAA;AAKtC,wBAAwB,OAAuD;AAC5E,QAAM,WAAW,CAAC,UAAU,UAAU,iBAAiB;AAEvD,MAAI,OAAO;AACR,aAAS,KAAK,KAAK;AAAA;AAGtB,SAAO;AAAA,IACJ;AAAA,IACA,QAAQ;AAAA,IACR,OAAO,MAAc;AAClB,aAAO,iBAAiB;AAAA;AAAA;AAAA;AAKlB,0BAAuE;AACnF,SAAO;AAAA,IACJ,UAA8B,KAAa,UAAkB,MAAiB;AAC3E,aAAO,KAAK,SACT,cAAc,KAAK,OAAO,KAAK,OAAO,MAAM,cAAc,KAAK,IAAI,uBACnE,yBAAyB;AAAA;AAAA,IAI/B,UAA8B,KAAa,OAAwB;AAChE,aAAO,KAAK,SACT,cAAc,KAAK,cAAc,OAAO,UACxC,yBAAyB;AAAA;AAAA,IAI/B,cAAkC,MAAiB;AAChD,aAAO,KAAK,SACT,eAAe,cAAc,KAAK,IAAI,UACtC,yBAAyB;AAAA;AAAA;AAAA;AAzFrC,IAMY;AANZ;AAAA;AACA;AAGA;AAEO,IAAK,iBAAL,kBAAK,oBAAL;AACJ,kCAAS;AACT,kCAAS;AACT,iCAAQ;AACR,oCAAW;AAJF;AAAA;AAAA;AAAA;;;AC0CL,6BAA6B,QAAgC;AACjE,SAAO,IAAI,YAAY,MAAM,GAAG;AAAA;AAGnC,mBAAmB,MAA0B;AAC1C,QAAM,QAA6B,oBAAI;AACvC,QAAM,UAAiC;AAEvC,yBAAuB,MAAM,CAAC,UAAU;AACrC,UAAM,CAAC,MAAM,MAAM,WAAW,MAAM,MAAM;AAC1C,UAAM,IAAI;AACV,IAAC,SAAQ,QAAQ,QAAQ,SAAS,IAAI,KAAK;AAAA,MACxC,MAAM,SAAS;AAAA,MACf;AAAA,MACA;AAAA;AAAA;AAIN,SAAO;AAAA,IACJ;AAAA,IACA;AAAA;AAAA;AAIS,wBAAqC;AACjD,SAAO;AAAA,IACJ,KAAyB,YAAmC;AACzD,YAAM,OAAO,yBAAyB;AACtC,YAAM,UAAU,mBAAmB;AAEnC,iBAAW,UAAU,mBAAmB;AACrC,YAAI,QAAQ,SAAS,SAAS;AAC3B,iBAAO,KAAK,SACT,uBAAuB,qBAAqB,8BAC5C;AAAA;AAAA;AAKT,UAAI,OAAO,eAAe,UAAU;AACjC,qBAAa,mBAAmB,MAAM;AAAA;AAGzC,YAAM,WAAW,CAAC,QAAQ,UAAU,MAAM,eAAe,GAAG,SAAS,GAAG;AAExE,aAAO,KAAK,SAAS;AAAA,QAClB;AAAA,QACA,QAAQ;AAAA,QACR,OAAO,QAAQ;AACZ,iBAAO,UAAU;AAAA;AAAA,SAEpB;AAAA;AAAA;AAAA;AAnGZ,IAaM,mBAEA,OAfN,IAyBA;AAzBA;AAAA;AAEA;AASA;AAEA,IAAM,oBAAoB,CAAC;AAE3B,IAAM,QAAQ,OAAO;AAUrB,sBAAwC;AAAA,MAAxC,cAzBA;AA0BY,mBAAmB;AAAA;AAAA,QAAnB,aAEN,OAAO,aAAY;AACnB,mBAAW,SAAS,KAAK,QAAQ;AAC9B,gBAAM;AAAA;AAAA;AAAA,MAIZ,OAAO,KAAe;AACnB,YAAI,UAAU,KAAK,OAAO,KAAK,SAAS,KAAK,GAAG,cAAc,KAAK,OAAO;AAC1E,eAAO;AAAA;AAAA,MAGV,SAAS,OAAiB;AACvB,aAAK,OAAO,KAAK,GAAG,cAAc,OAAO;AACzC,eAAO;AAAA;AAAA;AAAA;AAAA;;;ACzCb;AAAA;AAAA;AAAA;AAAA;AAAA;AAiBO,mBAAmB,MAAwB,YAAsB;AACrE,QAAM,WAAqB,CAAC;AAC5B,MAAI,iBAAiB,OAAO;AACzB,aAAS,KAAK,KAAK;AAAA;AAEtB,WAAS,KAAK,GAAG;AAEjB,SAAO,0BAA0B;AAAA;AAG7B,sBAAsB,MAAyC;AACnE,MAAI,iBAAiB,OAAO;AACzB,WAAO;AAAA;AAGV,UAAQ,OAAO;AAAA,SACP;AAAA,SACA;AACF,aAAO;AAAA;AAGb;AAAA;AAGH,0BAA0B,MAA0C;AACjE,SAAO,WAAW,SAAS;AAAA;AA1C9B,IAGY,WAQN;AAXN;AAAA;AAAA;AAGO,IAAK,YAAL,kBAAK,eAAL;AACJ,4BAAQ;AACR,2BAAO;AACP,2BAAO;AACP,4BAAQ;AACR,2BAAO;AALE;AAAA;AAQZ,IAAM,aAAa,MAAM,KAAK,OAAO,OAAO;AAAA;AAAA;;;ACX5C;AAcA,qBAAsB;AACnB,SAAO,MAAM;AAAA;AAWhB,wBAAyB,IAAc,QAAgB,SAAsD;AAC1G,MAAI,CAAC,UAAU,CAAC,OAAO,QAAQ,QAAQ,OAAO,KAAK;AAChD,WAAO,CAAC,UAAU,KAAK,CAAC,YAAY,SAAS;AAC1C,SAAG,SAAS,GAAG;AACf,cAAQ,SAAS,GAAG;AAAA;AAAA;AAI1B,SAAO,CAAC,YAAY,SAAS;AAC1B,OAAG,MAAM,WAAW,QAAQ,GAAG;AAC/B,QAAI,SAAS;AACV,cAAQ,SAAS,GAAG;AAAA;AAAA;AAAA;AAK7B,yBAA0B,MAAqB,eAAgC,EAAC,WAAW,mBAAoC;AAC5H,MAAI,OAAO,SAAS,UAAU;AAC3B,WAAO;AAAA;AAEV,QAAM,iBAAiB,iBAAiB,cAAc,aAAa;AAEnE,MAAI,eAAe,WAAW,kBAAkB;AAC7C,WAAO,eAAe,OAAO,gBAAgB,SAAS;AAAA;AAGzD,SAAO,kBAAkB;AAAA;AAGrB,sBAAuB,OAAe,SAA6B,aAAsB,eAAe,aAA2B;AACvI,QAAM,cAAc,SAAS,IAAI,YAAY;AAE7C,QAAM,UAA0B;AAChC,QAAM,gBAAkC,OAAO,YAAY,WAAY,aAAa,OAAO,WAAW;AACtG,QAAM,MAAM,gBAAgB,WAAW,SAAS,eAAe,eAAe;AAE9E,SAAO,KAAK;AAEZ,mBAAiB,MAAc,SAAkB;AAC9C,WAAO,OAAO,SAAS,aAAa,OAAO,IAAI,QAAQ,UAAU,OAAO,SAAS;AAAA;AAGpF,gBAAc,OAAgB;AAC3B,UAAM,aAAa,SAAS,IAAI,YAAY;AAC5C,UAAM,SAAQ,iBAAiB,eAAe,eAAe,eAAe;AAC5E,UAAM,OAAO,eAAe,cAAc,GAAG,eAAgB,cAAc;AAE3E,WAAO,OAAO,OAAO,gBAAgB,SAAQ,MAAM;AAAA,MAChD;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA;AAAA;AAAA;AA7ET;AAAA;AACA;AAGA,UAAM,WAAW,IAAI,CAAC,UAAe,OAAO,gBAAgB,SAAS,MAAM,SAAS;AACpF,UAAM,WAAW,IAAI,CAAC,UAAkB;AACrC,UAAI,OAAO,SAAS,QAAQ;AACzB,eAAO,MAAM,SAAS;AAAA;AAEzB,aAAO,eAAe;AAAA;AAAA;AAAA;;;ACTzB,IAYO;AAZP;AAAA;AACA;AACA;AAUO,+BAAwB;AAAA,MAI5B,YAAoB,WAAW,eAAe;AAA1B;AAFZ,sBAAgD,oBAAI;AAAA;AAAA,MAKpD,aAAa,MAAwB;AAC1C,eAAO,KAAK,OAAO,IAAI;AAAA;AAAA,MAGlB,eAAgB,MAAwC;AAC7D,cAAM,OAAO,mBAAkB,QAAQ,KAAK,SAAS;AACrD,cAAM,SAAS,aAAa,KAAK,UAAU;AAE3C,eAAO;AAAA,UACJ;AAAA,UACA;AAAA,UACA;AAAA;AAAA;AAAA,MAIN,KAAK,MAAwC;AAC1C,cAAM,WAAW,KAAK,eAAe;AACrC,iBAAS,OAAO,2CAA2C,KAAK;AAEhE,aAAK,OAAO,IAAI,MAAM;AAEtB,eAAO;AAAA;AAAA,MAGV,MAAM,KAAe;AAClB,mBAAW,CAAC,MAAM,EAAC,aAAY,MAAM,KAAK,KAAK,OAAO,YAAY;AAC/D,cAAI,SAAS,IAAI,MAAM;AACpB,mBAAO,KAAK,aAAa;AACzB,mBAAO;AAAA,iBACH;AACJ,mBAAO,KAAK,gFAAgF,IAAI;AAAA;AAGnG,eAAK,SAAS;AAAA;AAGjB,YAAI,KAAK,OAAO,SAAS,GAAG;AACzB,gBAAM,IAAI,MAAM,0CAA0C,KAAK,OAAO;AAAA;AAAA;AAAA,MAI5E,SAAS,MAAwB;AAC9B,cAAM,WAAW,KAAK,aAAa;AACnC,YAAI,UAAU;AACX,eAAK,OAAO,OAAO;AAAA;AAAA;AAAA,MAIzB,QAAQ,MAAwC;AAC7C,cAAM,WAAW,KAAK,aAAa;AACnC,YAAI,CAAC,UAAU;AACZ,gBAAM,IAAI,SAAS,QAAW;AAAA;AAEjC,iBAAS,OAAO;AAEhB,eAAO;AAAA;AAAA,aAGH,QAAS,OAAO,SAAS;AAC7B,eAAO,QAAQ,QAAQ,EAAE,mBAAkB;AAAA;AAAA;AAlE1C;AAqEW,IArEX,kBAqEW,UAAU;AAAA;AAAA;;;ACjF5B;AA2MA,uBAA0B,MAAwB,UAAoB;AACnE,SAAO;AAAA,IACJ,QAAQ,MAAM,KAAK,aAAa;AAAA,IAChC;AAAA;AAAA;AAIN,yBAAyB,QAAkB,QAAsB;AAC9D,SAAO,CAAC,QAAe;AACpB,WAAO,sCAAsC;AAC7C,WAAO,KAAK,OAAO,KAAK,OAAO,IAAI,QAAQ;AAAA;AAAA;AAIjD,wBAAwB,QAAkB,MAAc,QAAsB,QAAsB;AACjG,SAAO,CAAC,WAAmB;AACxB,WAAO,wBAAwB,MAAM;AACrC,WAAO,MAAM;AACb,WAAO,KAAK;AAAA;AAAA;AA7NlB,IAUO;AAVP;AAAA;AACA;AAGA;AAEA;AAEA;AAEO,6BAAoD;AAAA,MA0BxD,YACW,WACA,YACA,UACT;AAHS;AACA;AACA;AA3BH,sBAAuB,QAAQ;AAC/B,sBAAS,IAAI;AAAA;AAAA,UAGV,SAAS;AACjB,eAAO,KAAK,UAAU;AAAA;AAAA,UAGd,MAAM;AACd,eAAO,KAAK,QAAQ,KAAK,UAAU;AAAA;AAAA,UAG3B,IAAI,KAAa;AACzB,aAAK,OAAO;AAAA;AAAA,UAGJ,MAAM;AACd,eAAO,KAAK,UAAU;AAAA;AAAA,UAGd,gBAAgB;AACxB,eAAO,KAAK,UAAU;AAAA;AAAA,MAUlB,QAAQ;AACZ,eAAO;AAAA;AAAA,MAGH,KAAQ,MAAoC;AAChD,aAAK,OAAO,KAAK;AAEjB,eAAO,KAAK,SAAS,KAAK,OAAO,KAAK,MAAM,KAAK,YAAY;AAAA;AAAA,MAGlD,YAAe,MAA2C;AAAA;AACrE,gBAAM,qBAAqB,MAAM,KAAK,WAAW;AACjD,gBAAM,kBAAkB,MAAM,KAAK,OAAO,SAAS;AAEnD,cAAI;AACD,kBAAM,EAAC,WAAU,KAAK,OAAO,QAAQ;AACrC,mBAAO,MAAO,YAAY,QAClB,KAAK,iBAAiB,MAAM,UAC5B,KAAK,kBAAkB,MAAM;AAAA,mBAE/B,GAAP;AACC,kBAAM,KAAK,iBAAiB,MAAM;AAAA,oBACnC;AACC;AACA;AAAA;AAAA;AAAA;AAAA,MAIE,iBAAoB,MAAwB,GAAU;AAC3D,cAAM,WAAY,aAAa,WAAY,OAAO,OAAO,GAAG,EAAC,UAAS,IAAI,SAAS,MAAM,KAAK,OAAO;AAErG,aAAK,SAAS,QAAQ;AACtB,aAAK,OAAO,MAAM;AAElB,eAAO;AAAA;AAAA,MAGI,kBAAqB,MAAuB,QAAsB;AAAA;AAC7E,gBAAM,OAAO,KAAK,SAAS,KAAK,cAAc,CAAC,GAAG,KAAK,WAAW,cAAc,MAAM,KAAK;AAE3F,gBAAM,MAAM,MAAM,KAAK,YACpB,MACA,KAAK,QAAQ,MAAM,KAAK,eAAe,OAAO,KAAK;AAEtD,gBAAM,gBAAgB,MAAM,KAAK,eAAe,MAAM,MAAM,KAAK,OAAO,KAAK;AAE7E,iBAAO,6CAA6C,KAAK;AAEzD,cAAI,aAAa,OAAO;AACrB,mBAAO,eAAe,KAAK,QAAQ;AAAA;AAGtC,iBAAO,eAAe,KAAK,QAAQ,cAAc;AAAA;AAAA;AAAA,MAGtC,iBAAiB,MAAiB,QAAsB;AAAA;AACnE,iBAAO;AACP,iBAAO,KAAK,OAAO;AAAA;AAAA;AAAA,MAGd,eACL,MACA,MACA,QAA2B,QAAiD;AAE5E,cAAM,EAAC,UAAU,WAAW,QAAQ,WAAU;AAE9C,eAAO,IAAI,QAAQ,CAAC,MAAM,SAAS;AAChC,iBAAO,4DAA4D;AAEnE,gBAAM,EAAC,UAAS,KAAK,SAAS,KAAK,cAAc,EAAC,OAAO,aAAY,kCAC/D,cAAc,MAAM,QACpB;AAGN,cAAI,SAAS,KAAK,SAAS;AACxB,mBAAO,KAAK;AAEZ,mBAAO,KAAK,QACT,QACA,OACA,CAAC,cAAc;AACZ,qBAAO,KAAK;AACZ,qBAAO,8BAA8B,eAAe;AAEpD,mBAAK,IAAI,iBACN,MAAM,QAAQ,aAAa,OAAO,OAAO,aAAa,WACtD,OAAO,OAAO;AAAA,eAGpB;AAAA;AAIN,cAAI,OAAO;AACR,mBAAO,KAAK,yDAAyD,UAAU,OAAO,QAAQ;AAC9F,mBAAO,KAAK;AAAA;AAGf,iBAAO,KAAK;AACZ,eAAK,IAAI,iBACN,OAAO,OAAO,SACd,OAAO,OAAO;AAAA;AAAA;AAAA,MAKT,YAAe,MAAwB,SAAiB,MAAgB,eAAqC,QAAkD;AAAA;AAC1K,gBAAM,eAAe,OAAO,QAAQ;AACpC,gBAAM,eAA6B,KAAK,SAAS,KAAK,iBAAiB;AAAA,YACpE,KAAK,KAAK;AAAA,YACV,KAAK,KAAK;AAAA,YACV,aAAa;AAAA,aACb,cAAc,MAAM,KAAK;AAE5B,iBAAO,IAAI,QAAQ,CAAC,SAAS;AAC1B,kBAAM,SAAmB;AACzB,kBAAM,SAAmB;AAEzB,gBAAI;AAEJ,mBAAO,KAAK,SAAS,SAAS;AAC9B,mBAAO,MAAM;AACb,kBAAM,UAAU,MAAM,SAAS,MAAM;AAErC,oBAAQ,OAAQ,GAAG,QAAQ,eAAe,QAAQ,UAAU,QAAQ,aAAa,KAAK;AACtF,oBAAQ,OAAQ,GAAG,QAAQ,eAAe,QAAQ,UAAU,QAAQ,aAAa,KAAK;AAEtF,oBAAQ,GAAG,SAAS,gBAAgB,QAAQ;AAE5C,gBAAI,eAAe;AAChB,qBAAO;AACP,4BAAc,SAAS,QAAQ,QAAS,QAAQ,QAAS,CAAC,GAAG;AAAA;AAGhE,iBAAK,SAAS,KAAK,eAAe,QAAW,iCACvC,cAAc,MAAM,QADmB;AAAA,cAE1C;AAAA,cACA,MAAM,UAAkB,QAAgB;AACrC,qBAAK;AAAA,kBACF;AAAA,kBACA;AAAA,kBACA;AAAA,kBACA,WAAW,aAAa;AAAA;AAAA;AAAA,cAG9B,KAAK,QAAe;AACjB,oBAAI,QAAQ,QAAQ;AACjB;AAAA;AAGH,4BAAY;AACZ,wBAAQ,KAAK;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;ACnM5B;AAAA;AAAA;AAAA;AAAA,IAMO;AANP;AAAA;AAGA;AAGO,wBAA+C;AAAA,MAOnD,YACU,SAAiB,OACjB,KACC,YACA,UACT;AAJQ;AACA;AACC;AACA;AATH,sBAAS,IAAI,iBAAiB,MAAM,KAAK,YAAY,KAAK;AAAA;AAAA,MAalE,QAA2B;AACxB,eAAO,IAAI,iBAAiB,MAAM,KAAK,YAAY,KAAK;AAAA;AAAA,MAG3D,KAAQ,MAAoC;AACzC,eAAO,KAAK,OAAO,KAAK;AAAA;AAAA;AAAA;AAAA;;;ACrBvB,sBAAyB,MAAwB,UAAsB,WAAqC,MAAM;AAEtH,QAAM,YAAY,CAAC,SAAY;AAC5B,aAAS,MAAM;AAAA;AAGlB,QAAM,WAAU,CAAC,QAAqC;AACnD,QAAI,4BAAK,UAAS,MAAM;AACrB,eAAU,eAAe,mBAAoB,4BAA4B,OAAO,KAAK;AAAA;AAAA;AAI3F,WAAS,KAAK,WAAW;AAAA;AAI5B,qCAAsC,KAAuB;AAC1D,MAAI,MAAM,CAAC,SAAiB;AACzB,YAAQ,KAAK,6DAA6D,uCAAuC;AACjH,UAAM;AAAA;AAGT,SAAO,OAAO,OAAO,KAAK,OAAO,oBAAoB,IAAI,KAAK,OAAO,mBAAmB;AAExF,6BAA2B,KAA4B,MAA0B;AAC9E,QAAI,QAAQ,KAAK;AACd,aAAO;AAAA;AAGV,QAAI,QAAQ;AAAA,MACT,YAAY;AAAA,MACZ,cAAc;AAAA,MACd,MAAO;AACJ,YAAI;AACJ,eAAO,IAAI,IAAI;AAAA;AAAA;AAIrB,WAAO;AAAA;AAAA;AA3Cb;AAAA;AACA;AAEA;AAAA;AAAA;;;ACCO,oCAAqC,WAAmB,MAA0B;AACtF,SAAO,cAAc,CAAC,aAAgC;AACnD,QAAI,CAAC,aAAa,YAAY;AAC3B,YAAM,IAAI,MAAM,4CAA6C;AAAA;AAGhE,WAAS,SAAQ,UAAU,MAAM;AAAA;AAAA;AAVvC;AAAA;AAAA;AAEA;AAAA;AAAA;;;ACoCO,2BAA2B,QAA8B;AAC7D,QAAM,SAAuB;AAAA,IAC1B,QAAQ;AAAA,IACR,QAAQ;AAAA,IACR,QAAQ;AAAA,IACR,MAAM;AAAA,IACN,SAAS;AAAA,MACN,SAAS;AAAA,MACT,YAAY;AAAA,MACZ,WAAW;AAAA;AAAA;AAGjB,SAAO,oBAAoB,QAAQ,SAAS;AAAA;AAlD/C,IAGM;AAHN;AAAA;AACA;AAEA,IAAM,UAAsC;AAAA,MACzC,IAAI,WAAW,qCAAqC,CAAC,QAAQ,CAAC,QAAQ,MAAM,YAAY;AACrF,eAAO,SAAS;AAChB,eAAO,SAAS;AAChB,eAAO,OAAO,CAAC,CAAC;AAAA;AAAA,MAEnB,IAAI,WAAW,qBAAqB,CAAC,QAAQ,CAAC,YAAY;AACvD,cAAM,QAAQ,OAAO,MAAM;AAC3B,cAAM,QAAQ,MAAM;AAEpB,YAAI,CAAC,SAAS,CAAC,MAAM,SAAS,MAAM;AACjC;AAAA;AAGH,eAAO,SAAS;AAAA,UACb,OAAO,MAAM,OAAO,GAAG,MAAM,SAAS;AAAA,UACtC,MAAM,MAAM,KAAK,KAAK;AAAA;AAAA;AAAA,MAG5B,IAAI,WAAW,8CAA8C,CAAC,QAAQ,CAAC,SAAS,YAAY,eAAe;AACxG,eAAO,QAAQ,UAAU,SAAS,SAAS,OAAO;AAClD,eAAO,QAAQ,aAAa,SAAS,YAAY,OAAO;AACxD,eAAO,QAAQ,YAAY,SAAS,WAAW,OAAO;AAAA;AAAA,MAEzD,IAAI,WAAW,0CAA0C,CAAC,QAAQ,CAAC,SAAS,OAAO,eAAe;AAC/F,eAAO,QAAQ,UAAU,SAAS,SAAS,OAAO;AAClD,cAAM,QAAQ,SAAS,OAAO,OAAO;AACrC,YAAI,cAAc,KAAK;AACpB,iBAAO,QAAQ,YAAY;AAAA,mBACnB,cAAc,KAAK;AAC3B,iBAAO,QAAQ,aAAa;AAAA;AAAA;AAAA;AAAA;AAAA;;;ACjCrC;AAAA;AAAA;AAAA;AAAA;AAcO,oBAAoB,SAAmB,OAAiB,YAAgD;AAC5G,QAAM,WAAqB;AAAA,IACxB;AAAA,IACA;AAAA,IACA;AAAA,IACA,GAAG,cAAc,SAAS;AAAA,IAC1B,GAAG;AAAA,IACH,GAAG;AAAA;AAGN,SAAO;AAAA,IACJ;AAAA,IACA,QAAQ;AAAA,IACR,QAAQ;AAAA;AAAA;AAIC,0BAAuC;AACnD,SAAO;AAAA,IACJ,OAA2B,YAA+B,MAAiB;AACxE,YAAM,OAAO,yBAAyB;AACtC,YAAM,OAAO,2BAA2B,YACrC,WACG,QAAQ,UACR,QAAQ,WAAW,KAAK,IAAI,2BAA2B,MACvD,CAAC,GAAG,WAAW,KAAK,IAAI,aAAa,KAAK,GAAG,mBAAmB,WAAW,GAAG;AAGpF,aAAO,KAAK,SAAS,MAAM;AAAA;AAAA;AAIjC,sCAAoC,SAAmB;AACpD,WACG,CAAC,0BAA0B,YAC3B,uBAAuB;AAAA;AAAA;AAjDhC;AAAA;AAGA;AACA;AAQA;AAAA;AAAA;;;ACNO,wBAAwB,UAAkB,OAAoC;AAClF,QAAM,WAAW,CAAC,eAAe;AACjC,MAAI,OAAO;AACR,aAAS,KAAK;AAAA;AAGjB,SAAO,0BAA0B,UAAU;AAAA;AAZ9C;AAAA;AAAA;AAAA;AAAA;;;ACcO,mBAAmB,MAAe,MAAc,MAAc;AAClE,QAAM,WAAW,OAAO,MAAM;AAC9B,MAAI;AAEJ,MAAK,SAAS,kBAAkB,KAAK,WAAY;AAC9C,WAAO,IAAI,YAAY,MAAM,MAAM,OAAO,OAAO;AAAA;AAGpD,MAAK,SAAS,oBAAoB,KAAK,WAAY;AAChD,WAAO,IAAI,YAAY,MAAM,MAAM,MAAM,OAAO;AAAA;AAGnD,MAAI,SAAS;AACb,QAAM,SAAS,SAAS,MAAM;AAC9B,SAAO,OAAO,QAAQ;AACnB,UAAM,QAAQ,OAAO;AACrB,QAAI,UAAU,MAAM;AACjB,eAAS,OAAO,KAAK;AACrB;AAAA;AAAA;AAIN,SAAO,IAAI,YAAY,MAAM,MAAM,OAAO,KAAK,WAAW;AAAA;AApC7D,IAEO,aASD,mBACA;AAZN;AAAA;AAEO,wBAAwC;AAAA,MAC5C,YACmB,MACA,MACA,UACA,QACjB;AAJiB;AACA;AACA;AACA;AAAA;AAAA;AAItB,IAAM,oBAAoB;AAC1B,IAAM,sBAAsB;AAAA;AAAA;;;ACN5B,wBAAwB,SAAmB;AACxC,SAAO,QAAQ,SAAS;AAAA;AAGpB,kBAAkB,OAAO,OAAO,MAAc,YAA8C;AAChG,QAAM,WAAW,CAAC,QAAQ,GAAG;AAC7B,MAAI,QAAQ,CAAC,eAAe,WAAW;AACpC,aAAS,OAAO,GAAG,GAAG;AAAA;AAGzB,SAAO;AAAA,IACJ;AAAA,IACA,QAAQ;AAAA,IACR,OAAO,MAA0B;AAC9B,aAAO,UAAU,SAAS,SAAS,WAAW,MAAM;AAAA;AAAA;AAAA;AApB7D,IAIM;AAJN;AAAA;AACA;AAGA,IAAM,cAAc;AAAA;AAAA;;;ACMb,8BAA8B,YAAsB;AACxD,WAAS,IAAI,GAAG,IAAI,WAAW,QAAQ,KAAK;AACzC,UAAM,SAAS,eAAe,KAAK,WAAW;AAC9C,QAAI,QAAQ;AACT,aAAO,KAAK,OAAO;AAAA;AAAA;AAIzB,SAAO;AAAA;AAGH,qBAAqB,WAA6B;AACtD,SAAO,eAAe,KAAK;AAAA;AAtB9B,IAQM;AARN;AAAA;AAQA,IAAM,iBAAiB;AAAA;AAAA;;;ACRvB,IAKO;AALP;AAAA;AAKO,wBAAwC;AAAA,MAAxC,cALP;AAMG,uBAAU;AACV,yBAAY;AACZ,0BAAa;AAEb,qBAA0D;AAAA;AAAA;AAAA;AAAA;;;ACsFtD,uBAAuB,SAAS,eAAgB;AACpD,QAAM,UAAS,mBAAmB;AAElC,SAAO,CAAC,WAAmB,oBAAoB,IAAI,eAAe,SAAQ,QAAQ;AAAA;AAnGrF,IAKM,YA4BA,eA6BA,gBAaA,kBAaA;AAxFN;AAAA;AACA;AACA;AACA;AAEA,IAAM,aAAa;AAAA,MAChB,IAAI,WAAuB,kCAAkC,CAAC,QAAQ,CAAC,MAAM,SAAS,cAAc,QAAQ;AACzG,eAAO,MAAM,KAAK;AAAA,UACf,MAAM,KAAK;AAAA,UACX,SAAS,SAAS;AAAA,UAClB,YAAY,YAAY,QAAQ,SAAS,IAAI;AAAA,UAC7C,WAAW,YAAY,QAAQ,SAAS,IAAI;AAAA,UAC5C,QAAQ;AAAA;AAAA;AAAA,MAGd,IAAI,WAAuB,iDAAiD,CAAC,QAAQ,CAAC,MAAM,QAAQ,WAAW;AAC5G,eAAO,MAAM,KAAK;AAAA,UACf,MAAM,KAAK;AAAA,UACX,QAAQ,SAAS;AAAA,UACjB,OAAO,SAAS;AAAA,UAChB,QAAQ;AAAA;AAAA;AAAA,MAGd,IAAI,WAAuB,iDAAiD,CAAC,QAAQ,CAAC,SAAS,aAAa;AACzG,cAAM,WAAW,UAAU,KAAK;AAChC,cAAM,UAAU,UAAU,KAAK;AAE/B,eAAO,UAAU,SAAS;AAC1B,eAAO,aAAa,SAAS,qCAAW;AACxC,eAAO,YAAY,SAAS,mCAAU;AAAA;AAAA;AAI5C,IAAM,gBAAgB;AAAA,MACnB,IAAI,WAAuB,uBAAuB,CAAC,QAAQ,CAAC,eAAe,eAAe,UAAU;AACjG,cAAM,aAAa,SAAS;AAC5B,cAAM,YAAY,SAAS;AAE3B,eAAO;AACP,eAAO,cAAc;AACrB,eAAO,aAAa;AAEpB,eAAO,MAAM,KAAK;AAAA,UACf;AAAA,UACA,SAAS,aAAa;AAAA,UACtB;AAAA,UACA;AAAA,UACA,QAAQ;AAAA;AAAA;AAAA,MAGd,IAAI,WAAuB,eAAe,CAAC,QAAQ,CAAC,UAAU;AAC3D,eAAO;AAEP,eAAO,MAAM,KAAK;AAAA,UACf;AAAA,UACA,OAAO;AAAA,UACP,QAAQ;AAAA,UACR,QAAQ;AAAA;AAAA;AAAA;AAKjB,IAAM,iBAAiB;AAAA,MACpB,IAAI,WAAuB,SAAS,CAAC,QAAQ,CAAC,UAAU;AACrD,eAAO;AACP,eAAO,MAAM,KAAK;AAAA,UACf;AAAA,UACA,SAAS;AAAA,UACT,YAAY;AAAA,UACZ,WAAW;AAAA,UACX,QAAQ;AAAA;AAAA;AAAA;AAKjB,IAAM,mBAAmB;AAAA,MACtB,IAAI,WAAuB,yBAAyB,CAAC,QAAQ,CAAC,SAAS,UAAU;AAC9E,eAAO;AACP,eAAO,MAAM,KAAK;AAAA,UACf;AAAA,UACA,SAAS;AAAA,UACT,YAAY;AAAA,UACZ,WAAW;AAAA,UACX,QAAQ;AAAA;AAAA;AAAA;AAKjB,IAAM,qBAAkE;AAAA,OACpE,gBAAiB;AAAA,OACjB,sBAAiB;AAAA,OACjB,6BAAqB;AAAA,OACrB,oCAAwB;AAAA,OACxB,gCAAsB;AAAA;AAAA;AAAA;;;AChF1B,qBAAqB,QAAkB,QAAuB;AAC3D,SAAO,OAAO,OAAO,CAAC,MAAM,OAAO,UAAU;AAC1C,SAAK,SAAS,OAAO,UAAU;AAC/B,WAAO;AAAA,KACP,uBAAO,OAAO,EAAC,MAAM;AAAA;AAGpB,oCAA8C,WAAW,UAAU,SAAS,mBAAmB,YAAY,eAAgB;AAC/H,QAAM,kBAAkB,cAAc;AAEtC,SAAO,SAAU,QAA8B;AAC5C,UAAM,MAAsC,mBAAmB,QAAQ,MAAM,gBACzE,IAAI,SAAU,MAAM;AAClB,YAAM,aAAa,KAAK,OAAO,MAAM;AACrC,YAAM,cAA+B,YAAY,WAAW,GAAG,OAAO,MAAM,WAAW;AAEvF,UAAI,WAAW,SAAS,KAAK,CAAC,CAAC,WAAW,GAAG,QAAQ;AAClD,oBAAY,OAAO,gBAAgB,WAAW;AAAA;AAGjD,aAAO;AAAA;AAGb,WAAO;AAAA,MACJ;AAAA,MACA,QAAQ,IAAI,UAAU,IAAI,MAAM;AAAA,MAChC,OAAO,IAAI;AAAA;AAAA;AAAA;AAvCpB,IAKa,gBAEA,iBAEA,UAEP;AAXN;AAAA;AACA;AACA;AACA;AAEO,IAAM,iBAAiB;AAEvB,IAAM,kBAAkB;AAExB,IAAM,WAAW;AAExB,IAAM,oBAAoB,CAAC,QAAQ,QAAQ,WAAW,QAAQ,eAAe;AAAA;AAAA;;;ACX7E;AAAA;AAAA;AAAA;AAAA;AAMO,yBAAyB,YAA0D;AACvF,MAAI,YAAY,qBAAqB;AAErC,QAAM,WAAW,CAAC;AAElB,MAAI,cAAc,eAAgB;AAC/B,gBAAY;AACZ,aAAS,KAAK;AAAA;AAGjB,WAAS,KAAK,GAAG;AAEjB,SAAO,wBAAwB,aAAa;AAAA,IACzC;AAAA,IACA,QAAQ;AAAA,IACR,QAAQ,cAAc;AAAA;AAAA;AAIrB,iCAAiC,YAAyC;AAC9E,QAAM,QAAQ,WAAW,OAAO;AAEhC,MAAI,MAAM,SAAS,GAAG;AACnB,WAAO,uBAAuB,sDAAsD,MAAM,KAAK;AAAA;AAGlG,MAAI,MAAM,UAAU,WAAW,SAAS,OAAO;AAC5C,WAAO,uBAAuB,gBAAgB;AAAA;AAAA;AAjCpD;AAAA;AAEA;AACA;AACA;AAAA;AAAA;;;AC+DA,sBAAsB,QAA0C,UAAsC;AACnG,QAAM,SAAmB;AACzB,QAAM,YAAsB;AAE5B,SAAO,KAAK,QAAQ,QAAQ,CAAC,UAAU;AACpC,WAAO,KAAK;AACZ,cAAU,KAAK,OAAO,OAAO;AAAA;AAGhC,SAAO;AAAA,IACJ;AAAA,IAAQ,UAAU,KAAK;AAAA;AAAA;AAI7B,qBAAwC,OAAmB;AACxD,SAAO,OAAO,KAAK,OAAO,OAAO,CAAC,KAAK,QAAQ;AAC5C,QAAI,CAAE,QAAO,iBAAiB;AAC3B,UAAI,OAAO,MAAM;AAAA;AAEpB,WAAO;AAAA,KACP;AAAA;AAGC,yBAA4C,MAA+B,IAAI,aAAuB,IAAsB;AAChI,QAAM,WAAW,WAAW,IAAI,UAAU,cAAc;AACxD,QAAM,SAAS,CAAC,iBAAiB,IAAI,WAAW,IAAI,SAAS,IAAI,SAAS;AAAA,IACvE,MAAM;AAAA,IACN,MAAM,IAAI,eAAe,QAAQ,QAAQ;AAAA,IACzC,SAAS;AAAA,IACT,MAAM;AAAA,IACN,MAAM,IAAI,YAAY,OAAO;AAAA,IAC7B,aAAa,IAAI,YAAY,QAAQ,QAAQ;AAAA,IAC7C,cAAc,IAAI,YAAY,QAAQ,QAAQ;AAAA;AAGjD,QAAM,CAAC,QAAQ,aAAa,aAAa,QAAQ;AAEjD,QAAM,SAAmB;AACzB,QAAM,UAAoB;AAAA,IACvB,mBAAmB,iBAAiB,YAAY;AAAA,IAChD,GAAG;AAAA;AAGN,QAAM,WAAgC,IAAY,KAAM,IAAY,gBAAgB,IAAI;AACxF,MAAI,UAAU;AACX,YAAQ,KAAK,eAAe;AAAA;AAG/B,MAAI,IAAI,QAAQ,IAAI,IAAI;AACrB,UAAM,gBAAiB,IAAI,cAAc,QAAS,QAAQ;AAC1D,WAAO,KAAK,GAAG,IAAI,OAAO,gBAAgB,IAAI;AAAA;AAGjD,MAAI,aAAa,IAAI,OAAO;AACzB,WAAO,KAAK,YAAY,IAAI;AAAA;AAG/B,oBAAkB,YAAY,MAAiB;AAE/C,SAAO;AAAA,IACJ;AAAA,IACA;AAAA,IACA,UAAU;AAAA,MACP,GAAG;AAAA,MACH,GAAG;AAAA;AAAA;AAAA;AAKL,iBAAoB,UAAkB,QAAkB,YAAgD;AAC5G,QAAM,UAAS,2BAA2B,UAAU,QAAQ,qBAAqB;AAEjF,SAAO;AAAA,IACJ,UAAU,CAAC,OAAO,GAAG;AAAA,IACrB,QAAQ;AAAA,IACR;AAAA;AAAA;AAIS,uBAAoC;AAChD,SAAO;AAAA,IACJ,OAA8C,MAAiB;AAC5D,YAAM,OAAO,yBAAyB;AACtC,YAAM,UAAU,gBAAmB,wBAAwB,YAAY,WAAW,UAAU,IAAI;AAChG,YAAM,OAAO,2BAA2B,GAAG,SACxC,wBAAwB,QAAQ,aAChC,cAAc;AAEjB,aAAO,KAAK,SAAS,MAAM;AAAA;AAAA;AAIjC,yBAAuB,SAA2B;AAC/C,WAAO,QAAQ,QAAQ,UAAU,QAAQ,QAAQ,QAAQ;AAAA;AAG5D,sCAAoC,MAAgB,IAAc;AAC/D,WACG,aAAa,SACb,aAAa,OACb,uBAAuB;AAAA;AAAA;AAvKhC,IAsBK;AAtBL;AAAA;AAEA;AACA;AAMA;AAUA;AACA;AAEA,IAAK,iBAAL,kBAAK,oBAAL;AACG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAbE;AAAA;AAAA;AAAA;;;ACtBL,IAEO,sBAaA;AAfP;AAAA;AAEO,iCAAoD;AAAA,MACxD,YACmB,QACA,OAAsB,MACtB,MACjB;AAHiB;AACA;AACA;AAAA;AAAA,MAInB,WAAW;AACR,eAAO,GAAG,KAAK,QAAQ,KAAK;AAAA;AAAA;AAI3B,+BAAgD;AAAA,MAAhD,cAfP;AAgBU,yBAA6B;AAC7B,sBAAmB;AACnB,sBAA4B;AAAA;AAAA,UAE/B,SAAS;AACV,eAAO,KAAK,UAAU,SAAS;AAAA;AAAA,UAG9B,SAAS;AACV,eAAO,KAAK;AAAA;AAAA,MAGf,WAAW;AACR,YAAI,KAAK,UAAU,QAAQ;AACxB,iBAAO,cAAc,KAAK,UAAU,KAAK;AAAA;AAG5C,eAAO;AAAA;AAAA;AAAA;AAAA;;;ACjCb,IAEO,aAgBA;AAlBP;AAAA;AAEO,wBAAwC;AAAA,MAAxC,cAFP;AAGU,8BAAiB;AAAA,UACrB,KAAK;AAAA;AAED,uBAAU;AACV,uBAAoB;AACpB,qBAAkB;AAClB,yBAAmC;AACnC,0BAAoC;AACpC,uBAA6B;AAAA,UACjC,SAAS;AAAA,UACT,WAAW;AAAA,UACX,YAAY;AAAA;AAAA;AAAA;AAIX,8BAAoD;AAAA,MAApD,cAlBP;AAmBG,sBAAS;AACT,oBAAO;AAAA,UACJ,OAAO;AAAA,UACP,QAAQ;AAAA;AAEX,sBAAS;AAAA,UACN,OAAO;AAAA,UACP,QAAQ;AAAA;AAEX,uBAAU;AAAA;AAAA,MAEV,WAAW;AACR,eAAO,KAAK;AAAA;AAAA;AAAA;AAAA;;;AC5BlB,iCAA4E,gBAAoD;AAC7H,SAAQ,eAAe,UAAU,eAAe,WAAW;AAAA,IACxD,aAAa;AAAA,IACb,UAAU;AAAA,IACV,aAAa;AAAA,IACb,YAAY;AAAA,IACZ,QAAQ,EAAC,OAAO,GAAG,OAAO;AAAA,IAC1B,OAAO,EAAC,OAAO,GAAG,OAAO;AAAA;AAAA;AAI/B,uBAAuB,QAAgB;AACpC,QAAM,QAAQ,YAAY,KAAK;AAC/B,QAAM,QAAQ,eAAe,KAAK;AAElC,SAAO;AAAA,IACJ,OAAO,SAAS,SAAS,MAAM,MAAM;AAAA,IACrC,OAAO,SAAS,SAAS,MAAM,MAAM;AAAA;AAAA;AApB3C,IAwBa;AAxBb;AAAA;AACA;AAuBO,IAAM,8BAAuF;AAAA,MACjG,IAAI,iBAAiB,kEAAkE,CAAC,QAAQ,CAAC,QAAQ,WAAW;AACjH,cAAM,MAAM,OAAO;AACnB,cAAM,cAAc,wBAAwB,OAAO;AAEnD,eAAO,OAAO,aAAa,GAAE,MAAM,SAAS;AAAA;AAAA,MAE/C,IAAI,iBAAiB,gFAAgF,CAAC,QAAQ,CAAC,QAAQ,WAAW;AAC/H,cAAM,MAAM,OAAO;AACnB,cAAM,cAAc,wBAAwB,OAAO;AAEnD,eAAO,OAAO,aAAa,GAAE,MAAM,SAAS;AAAA;AAAA,MAE/C,IAAI,iBAAiB,qDAAqD,CAAC,QAAQ,CAAC,OAAO,QAAQ,gBAAgB;AAChH,cAAM,UAAU,wBAAwB,OAAO;AAC/C,gBAAQ,QAAQ,cAAc;AAC9B,gBAAQ,SAAS,cAAc;AAC/B,gBAAQ,aAAa,SAAS;AAAA;AAAA;AAAA;AAAA;;;ACnB7B,6BACJ,SAAiB,QACG;AACpB,SAAO,oBAAoB,EAAC,gBAAgB,IAAI,0BAA8B,UAAS;AAAA;AAzB1F,IAIM,UAwBC;AA5BP;AAAA;AACA;AACA;AAEA,IAAM,WAA8F;AAAA,MACjG,IAAI,iBAAiB,oBAAoB,CAAC,QAAQ,CAAC,UAAU;AAC1D,eAAO,eAAe,IAAI,KAAK,KAAK;AACpC,eAAO;AAAA;AAAA,MAEV,GAAG;AAAA,MACH,IAAI,iBAAiB,CAAC,oCAAoC,wBAAwB,CAAC,QAAQ,CAAC,oBAAoB;AAC7G,QAAC,OAAO,eAA4C,iBAAiB;AAAA;AAAA,MAExE,IAAI,iBAAiB,CAAC,6CAA6C,wBAAwB,CAAC,QAAQ,CAAC,OAAO,SAAS,SAAS;AAC3H,QAAC,OAAO,eAA4C,kBAAkB;AAAA,UACnE,OAAO,SAAS;AAAA,UAChB;AAAA,UACA;AAAA;AAAA;AAAA;AAWF,iCAAqD;AAAA,MAArD,cA5BP;AA6BmB,mBAAgB;AAAA;AAAA;AAAA;AAAA;;;AC+B5B,8BAA8B,QAAgB,QAAgB;AAClE,QAAM,YAAY,oBAAoB,IAAI,qBAAqB,cAAc,CAAC,QAAQ;AAEtF,SAAO,UAAU,WAAW;AAAA;AA/D/B,IAMM,mBACA,eACA,cAEA,UA2BA,cAWO,iBAIA;AApDb;AAAA;AACA;AAEA;AACA;AAEA,IAAM,oBAAoB;AAC1B,IAAM,gBAAgB;AACtB,IAAM,eAAe;AAErB,IAAM,WAAoC;AAAA,MACvC,IAAI,WAAW,mBAAmB,CAAC,QAAQ,CAAC,MAAM,YAAY,eAAe;AAC1E,eAAO,MAAM,KAAK;AAElB,YAAI,YAAY;AACb,iBAAO,WAAW,QAAQ,WAAW;AAAA;AAGxC,YAAI,WAAW;AACZ,iBAAO,UAAU,QAAQ,UAAU;AAAA;AAAA;AAAA,MAGzC,IAAI,WAAW,eAAe,CAAC,QAAQ,CAAC,SAAS,EAAE,YAAY,EAAE,eAAe;AAC7E,YAAI,eAAe,UAAa,cAAc,QAAW;AACtD,iBAAO,QAAQ,UAAU,CAAC,WAAW;AACrC,iBAAO,QAAQ,aAAa,CAAC,cAAc;AAC3C,iBAAO,QAAQ,YAAY,CAAC,aAAa;AACzC,iBAAO;AAAA;AAEV,eAAO;AAAA;AAAA,MAEV,IAAI,WAAW,cAAc,CAAC,QAAQ,CAAC,QAAQ,UAAU;AACtD,eAAO,OAAO,OAAO;AACrB,eAAQ,WAAW,WAAY,OAAO,UAAU,OAAO,SAAS;AAAA;AAAA;AAItE,IAAM,eAA+C;AAAA,MAClD,IAAI,WAAW,iBAAiB,CAAC,QAAQ,CAAC,YAAY,KAAM,QAAO,SAAS;AAAA,MAC5E,IAAI,WAAW,kBAAkB,CAAC,QAAQ,CAAC,aAAa,KAAM,QAAO,UAAU;AAAA,MAC/E,IAAI,WAAW,oDAAoD,CAAC,QAAQ,CAAC,WAAW,YAAY,aAAa,kBAAkB;AAChI,eAAO,OAAO,QAAQ;AACtB,eAAO,KAAK,QAAQ;AACpB,eAAO,OAAO,SAAS;AACvB,eAAO,KAAK,SAAS;AAAA;AAAA;AAIpB,IAAM,kBAAkD,CAAC,QAAQ,WAAW;AAChF,aAAO,oBAAoB,IAAI,eAAe,UAAS,CAAC,QAAQ;AAAA;AAG5D,IAAM,kBAAkD,CAAC,QAAQ,WAAW;AAChF,aAAO,OAAO,OACX,IAAI,eACJ,gBAAgB,QAAQ,SACxB,oBAAoC,QAAQ;AAAA;AAAA;AAAA;;;ACxDlD,IAMM,UAqBO,kBAWA;AAtCb;AAAA;AACA;AAEA;AACA;AAEA,IAAM,WAAqC;AAAA,MACxC,IAAI,WAAW,yBAAyB,CAAC,SAAS,CAAC,eAAe;AAC/D,gBAAQ,OAAO,KAAK;AAAA;AAAA,MAEvB,IAAI,WAAW,iDAAiD,CAAC,SAAS,CAAC,QAAQ,UAAU;AAC1F,gBAAQ,UAAU,KAAK,IAAI,qBAAqB,QAAQ;AAAA;AAAA,MAE3D,IAAI,WAAW,0DAA0D,CAAC,SAAS,CAAC,QAAQ,MAAM,eAAe;AAC9G,gBAAQ,UAAU,KAAK,IAAI,qBAAqB,QAAQ,MAAM,EAAC;AAAA;AAAA,MAElE,IAAI,WAAW,yBAAyB,CAAC,SAAS,CAAC,YAAY;AAC5D,gBAAQ,UAAU,KAAK,IAAI,qBAAqB,QAAQ;AAAA;AAAA,MAE3D,IAAI,WAAW,oCAAoC,CAAC,SAAS,CAAC,YAAY;AACvE,gBAAQ,SAAS;AAAA;AAAA;AAOhB,IAAM,mBAAoD,CAAC,QAAQ,WAAW;AAClF,aAAO,OAAO,OACX,iBAAiB,QAAQ,SACzB,gBAAgB,QAAQ;AAAA;AAQvB,IAAM,mBAAoD,CAAC,WAAW;AAC1E,aAAO,oBAAoB,IAAI,sBAAsB,UAAS;AAAA;AAAA;AAAA;;;ACjC1D,mBAAmB,YAA2D;AAClF,MAAI,CAAC,WAAW,QAAQ;AACrB,WAAO,uBAAuB;AAAA;AAGjC,SAAO;AAAA,IACJ,UAAU,CAAC,SAAS,GAAG;AAAA,IACvB,QAAQ;AAAA,IACR,OAAO,QAAQ,QAAqB;AACjC,YAAM,QAAQ,iBAAiB,QAAQ;AACvC,UAAI,MAAM,QAAQ;AACf,cAAM,IAAI,iBAAiB;AAAA;AAG9B,aAAO;AAAA;AAAA;AAAA;AApBhB;AAAA;AACA;AACA;AAEA;AAAA;AAAA;;;ACCA,8BAA8B,OAAe,QAAgB,QAAsC;AAChG,QAAM,UAAU,OAAO,SAAS;AAChC,QAAM,MAAM,OAAO,SAAS,UAAU,cAAc,KAAK;AACzD,QAAM,iBAAiB,CAAC,OAAO,SAAS;AAExC,SAAO;AAAA,IACJ;AAAA,IACA;AAAA,IACA,QAAQ,CAAC;AAAA,IACT,KAAK,CAAC;AAAA,IACN;AAAA,IACA;AAAA,IACA;AAAA;AAAA;AAjBN,IAqBM,UAmCO,iBAUA;AAlEb;AAAA;AAEA;AACA;AAkBA,IAAM,WAAoC;AAAA,MACvC,IAAI,WAAW,qBAAqB,CAAC,QAAQ,CAAC,UAAU;AACrD,eAAO,OAAO;AAAA;AAAA,MAEjB,IAAI,WAAW,uCAAuC,CAAC,QAAQ,CAAC,WAAW;AACxE,eAAO,MAAM,iCACN,OAAO,OAAO,KADR;AAAA,UAEV;AAAA;AAAA;AAAA,MAGN,IAAI,WAAW,qCAAqC,CAAC,QAAQ,CAAC,OAAO,QAAQ,UAAU;AACpF,eAAO,OAAO,KAAK,qBAAqB,OAAO,QAAQ;AAAA;AAAA,MAE1D,IAAI,WAAW,4EAA4E,CAAC,QAAQ,CAAC,OAAO,QAAQ,gBAAgB;AACjI,eAAO,SAAS,iCACT,OAAO,UAAU,KADR;AAAA,UAEb;AAAA,UACA;AAAA,UACA;AAAA;AAAA;AAAA,MAGN,IAAI,WAAW,gDAAgD,CAAC,QAAQ,CAAC,OAAO,QAAQ,MAAM,QAAQ;AACnG,eAAO,SAAS;AAAA,UACb,MAAM;AAAA,YACH;AAAA,YACA;AAAA;AAAA,UAEH,MAAM;AAAA,YACH;AAAA,YACA;AAAA;AAAA;AAAA;AAAA;AAML,IAAM,kBAAkD,CAAC,QAAQ,WAAW;AAChF,YAAM,aAAa,gBAAgB,QAAQ;AAC3C,YAAM,iBAAiB,oBAA8C,QAAQ;AAE7E,aAAO,kCACD,aACA;AAAA;AAIF,IAAM,kBAAkD,CAAC,QAAQ,WAAW;AAChF,aAAO,oBAAoB,EAAC,QAAQ,MAAK,UAAS,CAAC,QAAQ;AAAA;AAAA;AAAA;;;ACnE9D;AAAA;AAAA;AAAA;AAAA;AAOO,sBAAsB,MAAe,IAAI,YAA8C;AAC3F,SAAO,YAAY;AACnB,SAAO,SAAS,KAAK;AAAA;AAGjB,kBAAkB,MAAe,IAAI,YAA8C;AACvF,QAAM,WAAW,CAAC,QAAQ,GAAG;AAC7B,MAAI,IAAI,QAAQ;AACb,aAAS,OAAO,GAAG,GAAG,IAAI;AAAA;AAE7B,MAAI,IAAI,QAAQ;AACb,aAAS,OAAO,GAAG,GAAG,IAAI;AAAA;AAG7B,SAAO,UAAU;AACjB,SAAO,UAAU;AACjB,SAAO,UAAU;AAEjB,SAAO;AAAA,IACJ;AAAA,IACA,QAAQ;AAAA,IACR;AAAA;AAAA;AA5BN;AAAA;AACA;AAEA;AAAA;AAAA;;;ACHA,IAEa,eAEN;AAJP;AAAA;AAEO,IAAM,gBAAgB;AAEtB,8BAAoD;AAAA,MAIxD,YACU,MACA,OACA,aAAqB;AAFrB;AACA;AACA;AAEP,YAAI,AAAS,QAAQ,gBAAjB,KAA+B;AAChC,gBAAM,SAAS,cAAc,KAAK,SAAS,CAAC,MAAM,MAAM;AACxD,eAAK,OAAO,OAAO,MAAM;AACzB,eAAK,OAAO,OAAO,MAAM;AAAA;AAAA;AAAA;AAAA;AAAA;;;ACuBlC,qBAAqB,MAAc;AAChC,QAAM,CAAC,IAAI,QAAQ,KAAK,MAAM;AAE9B,SAAO;AAAA,IACJ,MAAM,QAAQ;AAAA,IACd;AAAA;AAAA;AAIN,iBAAgB,QAA6B,QAA6B,SAAuD;AAC9H,SAAO,CAAC,GAAG,SAAS,UAAU;AAAA;AAGjC,mBAAmB,WAAgC,QAA+B;AAC/E,SAAO,OAAO,IAAI,OAAK,QAAO,QAAQ,GAAG,CAAC,QAAQ,SAAS,OAAO,OAAO,YAAY;AAAA;AAmFxF,mBAAmB,QAAsB,SAAiB;AACvD,QAAM,WAAU,QAAQ;AACxB,UAAQ;AAAA,SACA,SAAQ,OAAO;AACjB,aAAO,KAAK,SAAQ,OAAO,IAAI,SAAQ,OAAO,IAAI,SAAQ,OAAO;AAAA,SAC/D,SAAQ,OAAO;AACjB,aAAO,KAAK,gBAA0B,SAAQ,OAAO,IAAI,SAAQ,OAAO;AAAA;AAExE;AAAA;AAGN,gBAAc,OAAe,YAAoB,MAAc;AAC5D,UAAM,MAAM,GAAG,QAAQ;AACvB,UAAM,UAAU,SAAQ,IAAI;AAE5B,QAAI,SAAS;AACV,cAAQ,QAAQ;AAAA;AAGnB,QAAI,QAAQ,QAAQ,QAAQ,MAAM;AAC/B,aAAO,MAAM,KAAK,IAAI,kBAAkB,KAAK,QAAQ,SAAS,KAAK,OAAO;AAAA;AAAA;AAAA;AA5JnF,IAMO,eAkDD,UA2DO;AAnHb;AAAA;AACA;AACA;AAIO,0BAA4C;AAAA,MAA5C,cANP;AAOU,yBAAY;AACZ,0BAAa;AACb,uBAAU;AACV,uBAAU;AACV,uBAAU;AACV,wBAAW;AACX,uBAAU;AACV,qBAAQ;AACR,sBAAS;AACT,qBAAQ;AACR,sBAAS;AACT,uBAAU;AACV,wBAAW;AACX,wBAAW;AAEX,uBAAU,MAAM;AACpB,iBAAO,CAAC,KAAK,MAAM;AAAA;AAAA;AAAA;AAiCzB,IAAM,WAAyC,IAAI,IAAI;AAAA,MACpD,QAAO,gBAA0B,iBAA2B,CAAC,QAAQ,SAAS,OAAO,OAAO,SAAS;AAAA,MACrG,QAAO,gBAA0B,mBAA6B,CAAC,QAAQ,SAAS,OAAO,OAAO,SAAS;AAAA,MACvG,QAAO,gBAA0B,oBAA8B,CAAC,QAAQ,SAAS,OAAO,OAAO,UAAU;AAAA,MAEzG,QAAO,iBAA2B,gBAA0B,CAAC,QAAQ,SAAS,OAAO,OAAO,SAAS,SAAS,OAAO,OAAO,QAAQ;AAAA,MACpI,QAAO,iBAA2B,oBAA8B,CAAC,QAAQ,SACtE,OAAO,OAAO,SAAS,SAAS,OAAO,OAAO,QAAQ,SAAS,OAAO,OAAO,UAAU;AAAA,MAE1F,QAAO,mBAA6B,gBAA0B,CAAC,QAAQ,SAAS,OAAO,OAAO,SAAS,SAAS,OAAO,OAAO,QAAQ;AAAA,MAEtI,QAAO,oBAA8B,gBAA0B,CAAC,QAAQ,SAAS,OAAO,OAAO,UAAU,SAAS,OAAO,OAAO,QAAQ;AAAA,MACxI,QAAO,oBAA8B,oBAA8B,CAAC,QAAQ,SAAS,OAAO,OAAO,UAAU,SAAS,OAAO,OAAO,QAAQ;AAAA,MAE5I,QAAO,mBAA6B,gBAA0B,CAAC,QAAQ,SAAS;AAC7E,eAAO,OAAO,SAAS,YAAY;AAAA;AAAA,MAEtC,QAAO,mBAA6B,oBAA8B,CAAC,QAAQ,SAAS;AACjF,cAAM,UAAU,YAAY;AAC5B,eAAO,OAAO,SAAS;AACvB,eAAO,OAAO,UAAU,QAAQ;AAAA;AAAA,MAEnC,QAAO,mBAA6B,mBAA6B,CAAC,SAAS,UAAU;AAClF,eAAQ,QAAQ,UAAU,QAAQ,WAAW,IAAK;AAAA;AAAA,MAGrD,QAAO,qBAA+B,qBAA+B,CAAC,QAAQ,SAAS,OAAO,OAAO,WAAW;AAAA,MAEhH,GAAG,UAAU,iBAA2B,iBAA2B;AAAA,MACnE,GAAG,UAAU,mBAA6B,mBAA6B;AAAA,MACvE,GAAG,UAAU,oBAA8B,iBAA2B,mBAA6B;AAAA,MAEnG,CAAC,MAAM,CAAC,QAAQ,SAAS;AACtB,cAAM,WAAW;AACjB,cAAM,YAAY;AAClB,cAAM,aAAa;AACnB,cAAM,cAAc;AACpB,cAAM,mBAAmB;AACzB,YAAI;AAEJ,sBAAc,SAAS,KAAK;AAC5B,eAAO,QAAQ,eAAe,CAAC,YAAY,MAAM;AAEjD,sBAAc,UAAU,KAAK;AAC7B,eAAO,SAAS,eAAe,CAAC,YAAY,MAAM;AAElD,sBAAc,WAAW,KAAK;AAC9B,eAAO,UAAU,eAAe,YAAY;AAE5C,sBAAc,YAAY,KAAK;AAC/B,eAAO,WAAW,eAAe,YAAY;AAE7C,sBAAc,iBAAiB,KAAK;AACpC,eAAO,UAAU,eAAe,YAAY,MAAM,OAAO;AAEzD,eAAO,WAAW,gBAAgB,KAAK;AAAA;AAAA;AAItC,IAAM,qBAAqB,SAAU,MAA4B;AACrE,YAAM,QAAQ,KAAK,MAAM;AACzB,YAAM,SAAS,IAAI;AAEnB,eAAS,IAAI,GAAG,IAAI,MAAM,QAAQ,IAAI,KAAI;AACvC,YAAI,OAAO,MAAM,KAAK;AAEtB,YAAI,CAAC,MAAM;AACR;AAAA;AAGH,YAAI,KAAK,OAAO,OAAO,mBAA6B;AACjD,kBAAQ,OAAQ,OAAM,QAAQ;AAAA;AAGjC,kBAAU,QAAQ;AAAA;AAGrB,aAAO;AAAA;AAAA;AAAA;;;AC/HH,oBAAoB,YAAgD;AACxE,QAAM,WAAW;AAAA,IACd;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA,GAAG,WAAW,OAAO,SAAO,CAAC,eAAe,SAAS;AAAA;AAGxD,SAAO;AAAA,IACJ,QAAQ;AAAA,IACR;AAAA,IACA,OAAO,MAAc;AAClB,aAAO,mBAAmB;AAAA;AAAA;AAAA;AApBnC,IAIM;AAJN;AAAA;AACA;AAGA,IAAM,iBAAiB,CAAC,UAAU;AAAA;AAAA;;;ACJlC;AAAA;AAAA;AAAA;AAAA,IAgBO;AAhBP;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEO,yBAA4C;AAAA,MAEhD,YAAoB,WAA8B;AAA9B;AAAA;AAAA,MAGV,SAAY,MAAwB,MAAiC;AAC5E,cAAM,QAAQ,KAAK,UAAU;AAC7B,cAAM,UAAU,MAAM,KAAK;AAE3B,YAAI,MAAM;AACP,uBAAa,MAAM,SAAS;AAAA;AAG/B,eAAO,OAAO,OAAO,MAAM;AAAA,UACxB,MAAM,EAAC,OAAO,QAAQ,KAAK,KAAK;AAAA,UAChC,OAAO,EAAC,OAAO,QAAQ,MAAM,KAAK;AAAA,UAClC,WAAW,EAAC,OAAO;AAAA;AAAA;AAAA,MAIzB,IAAI,OAA0B;AAC3B,eAAO,KAAK,SACT,0BAA0B,CAAC,OAAO,GAAG,QAAQ,UAC7C,yBAAyB;AAAA;AAAA,MAI/B,IAAI,WAAsD;AACvD,cAAM,OAAO,yBAAyB;AAEtC,YAAI,OAAO,cAAc,UAAU;AAChC,iBAAO,KAAK,SAAS,2BAA2B,WAAW,KAAK,YAAY;AAAA;AAG/E,YAAI,OAAO,wCAAW,UAAS,UAAU;AACtC,iBAAO,KAAK,SAAS,2BAA2B,UAAU,MAAM,UAAU,QAAQ,KAAK,aAAa,SAAY;AAAA;AAGnH,eAAO,KAAK,SACT,uBAAuB,2DACvB;AAAA;AAAA,MAIN,WAAW,MAAc,OAA0B;AAChD,eAAO,KAAK,SACT,eAAe,MAAM,UAAU,OAC/B,yBAAyB;AAAA;AAAA,MAI/B,KAAK,MAA0B;AAC5B,eAAO,KAAK,SACT,SAAS,SAAS,MAAM,KAAK,UAAU,KAAK,mBAAmB,aAC/D,yBAAyB;AAAA;AAAA,MAI/B,QAAQ;AACL,eAAO,KAAK,SACT,UAAU,mBAAmB,aAC7B,yBAAyB;AAAA;AAAA,MAI/B,YAAY,QAAgB,QAAgB;AACzC,YAAI,CAAE,cAAa,WAAW,aAAa,UAAU;AAClD,iBAAO,KAAK,SAAS,uBAClB;AAAA;AAIN,eAAO,KAAK,SACT,UAAU,CAAC,QAAQ,QAAQ,GAAG,mBAAmB,cACjD,yBAAyB,WAAW;AAAA;AAAA,MAI1C,cAAc,SAAwB;AACnC,aAAK,UAAU,gBAAgB;AAC/B,eAAO;AAAA;AAAA,MAGV,OAAO;AACJ,cAAM,OAAO,SACV;AAAA,UACG,QAAQ,WAAW,UAAU,IAAI;AAAA,UACjC,QAAQ,WAAW,UAAU,IAAI;AAAA,WAEpC,mBAAmB;AAGtB,eAAO,KAAK,SACT,MACA,yBAAyB;AAAA;AAAA,MAI/B,QAAQ;AACL,eAAO,KAAK,SACT,0BAA0B,CAAC,SAAS,GAAG,mBAAmB,cAC1D,yBAAyB;AAAA;AAAA,MAI/B,SAAS;AACN,eAAO,KAAK,SAAS,WAAW,mBAAmB,aAAa,yBAAyB;AAAA;AAAA;AAI/F,WAAO,OAAO,aAAa,WAAW,kBAAU,kBAAU,gBAAQ;AAAA;AAAA;;;AC9HlE;AAAA;AAAA;AAAA;AACA;AADA,IAOM,qBAcC;AArBP;AAAA;AAAA;AAEA;AAKA,IAAM,sBAA4C,OAAM;AACrD,UAAI,KAAK;AACT,aAAO,MAAM;AACV;AACA,cAAM,EAAC,SAAS,SAAQ;AAExB,eAAO;AAAA,UACJ;AAAA,UACA;AAAA,UACA;AAAA;AAAA;AAAA;AAKF,sBAAgB;AAAA,MAKpB,YAAoB,cAAc,GAAG;AAAjB;AAJZ,sBAAS,aAAa,IAAI;AAC1B,uBAA2B;AAC3B,uBAA2B;AAGhC,aAAK,OAAO,+BAA+B;AAAA;AAAA,MAGtC,WAAW;AAChB,YAAI,CAAC,KAAK,QAAQ,UAAU,KAAK,QAAQ,UAAU,KAAK,aAAa;AAClE,eAAK,OAAO,kEAAkE,KAAK,QAAQ,QAAQ,KAAK,QAAQ,QAAQ,KAAK;AAC7H;AAAA;AAGH,cAAM,OAAO,OAAO,KAAK,SAAS,KAAK,QAAQ;AAC/C,aAAK,OAAO,oBAAoB,KAAK;AACrC,aAAK,KAAK,MAAM;AACb,eAAK,OAAO,kBAAkB,KAAK;AACnC,iBAAO,KAAK,SAAS;AACrB,eAAK;AAAA;AAAA;AAAA,MAIX,OAA0C;AACvC,cAAM,EAAC,SAAS,OAAM,OAAO,KAAK,SAAS;AAC3C,aAAK,OAAO,oBAAoB;AAEhC,aAAK;AAEL,eAAO;AAAA;AAAA;AAAA;AAAA;;;ACnDb;AAAA;AAAA;AAAA;AAkCO,wBAAwB,SAAmB,YAA0C;AACzF,SAAO,0BAA0B,CAAC,SAAS,GAAG,YAAY,GAAG;AAAA;AAnChE;AAAA;AAAA;AAAA;AAAA;;;ACiBO,+BAAgC,QAAgB,MAAyC;AAC7F,SAAO;AAAA,IACJ;AAAA,IAAQ;AAAA,IAAM,SAAS;AAAA;AAAA;AAItB,+BAAgC,QAA2C;AAC/E,SAAO;AAAA,IACJ;AAAA,IAAQ,MAAM;AAAA,IAAM,SAAS;AAAA;AAAA;AAzBnC,IAOO;AAPP;AAAA;AAOO,gCAA6D;AAAA,MAA7D,cAPP;AAQG,mBAAkC;AAClC,wBAA+D;AAC/D,sBAAqC;AAAA;AAAA,UAEjC,UAAmB;AACpB,eAAO,CAAC,KAAK,OAAO;AAAA;AAAA;AAAA;AAAA;;;ACenB,gCAAgC,MAAc,iBAAqC;AACvF,SAAO,oBAAoB,iBAAmB,iBAAiB,KAAK;AAAA;AA7BvE,IAKM,oBACA,kBAEA,UAgBO;AAxBb;AAAA;AACA;AAEA;AAEA,IAAM,qBAAqB;AAC3B,IAAM,mBAAmB;AAEzB,IAAM,WAAiD;AAAA,MACpD,IAAI,WAAW,oBAAoB,CAAC,QAAQ,CAAC,QAAQ,UAAU;AAC5D,cAAM,WAAW,sBAAsB,QAAQ;AAE/C,eAAO,IAAI,KAAK;AAChB,eAAO,SAAS,UAAU;AAAA;AAAA,MAE7B,IAAI,WAAW,kBAAkB,CAAC,QAAQ,CAAC,YAAY;AACpD,cAAM,WAAW,sBAAsB;AAEvC,eAAO,OAAO,KAAK;AACnB,eAAO,IAAI,KAAK;AAChB,eAAO,SAAS,UAAU;AAAA;AAAA;AAIzB,IAAM,uBAAoE,CAAC,QAAQ,WAAW;AAClG,aAAO,oBAAoB,IAAI,uBAAuB,UAAS,CAAC,QAAQ;AAAA;AAAA;AAAA;;;ACzB3E,IAOO;AAPP;AAAA;AAOO,gCAAmD;AAAA,MAAnD,cAPP;AAQU,mBAAgB;AAChB,wBAAiD;AACjD,uBAAkB;AAClB,wBAAoB;AAAA;AAAA,MAE3B,KAAK,QAA0C,UAAmB,MAAc,QAAgB,OAAe;AAC5G,YAAI,WAAW,mBAAgC;AAC5C,eAAK,WAAW;AAChB,eAAK,UAAU;AAAA;AAGlB,aAAK,IAAI,KAAK;AACd,aAAK,SAAS,QAAQ;AAAA,UACnB,SAAS,WAAW;AAAA,UACpB,gBAAgB,WAAW;AAAA,UAC3B;AAAA,UACA;AAAA,UACA;AAAA;AAAA;AAAA;AAAA;AAAA;;;ACJT,sBAAsB,OAAgB;AACnC,SAAO,QAAQ,MAAM,OAAO,KAAK;AAAA;AAG7B,4BAA4B,QAA+B;AAC/D,SAAO,oBAAoB,IAAI,uBAAuB,UAAS;AAAA;AA1BlE,IAIM;AAJN;AAAA;AACA;AACA;AAEA,IAAM,WAA6C;AAAA,MAChD,IAAI,WAAW,2EAA2E,CAAC,QAAQ,CAAC,SAAS,MAAM,QAAQ,WAAW;AACnI,eAAO,KACJ,aAAa,UACb,MACA,MAAM,QAAQ;AAAA;AAAA,MAGpB,IAAI,WAAW,0CAA0C,CAAC,QAAQ,CAAC,SAAS,MAAM,QAAQ,WAAW;AAClG,eAAO,KACJ,aAAa,UACb,OACA,MAAM,QAAQ;AAAA;AAAA;AAAA;AAAA;;;AChBvB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAOO,qCAAqC,UAAoB;AAC7D,QAAM,iBAAiB,CAAC,MAAM,MAAM;AACpC,SAAO,SAAS,KAAK,aAAW,eAAe,SAAS;AAAA;AAGpD,oBAAoB,YAA4E;AACpG,QAAM,WAAW,4BAA4B;AAC7C,QAAM,WAAW,CAAC,UAAU,GAAG;AAE/B,MAAI,SAAS,WAAW,GAAG;AACxB,aAAS,KAAK;AAAA;AAGjB,MAAI,CAAC,SAAS,SAAS,OAAO;AAC3B,aAAS,OAAO,GAAG,GAAG;AAAA;AAGzB,SAAO;AAAA,IACJ,QAAQ;AAAA,IACR;AAAA,IACA,OAAO,QAAQ,QAAQ;AACpB,UAAI,UAAU;AACX,eAAO,qBAAqB,QAAQ,QAAQ,IAAI;AAAA;AAGnD,aAAO,mBAAmB;AAAA;AAAA;AAAA;AAK5B,2BAAsD;AAC1D,QAAM,UAAS;AAEf,SAAO;AAAA,IACJ,QAAQ;AAAA,IACR,UAAU,CAAC,UAAU;AAAA,IACrB;AAAA;AAAA;AAIC,4BAA4B,UAAoB,cAAc,OAA4C;AAC9G,SAAO;AAAA,IACJ,QAAQ;AAAA,IACR,UAAU,CAAC,UAAU,MAAM,cAAc,OAAO,MAAM,GAAG;AAAA,IACzD,OAAO,QAAQ,QAAQ;AACpB,aAAO,qBAAqB,QAAQ;AAAA;AAAA,IAEvC,QAAQ,EAAC,UAAU,UAAS,OAAO,MAAM,MAAM;AAC5C,UAAI,CAAC,uBAAuB,OAAO,QAAQ,WAAW;AACnD,eAAO,KAAK;AAAA;AAGf,WAAK;AAAA;AAAA;AAAA;AAKP,0BAA0B,QAAgB,cAAc,OAA6C;AACzG,QAAM,OAA6C;AAAA,IAChD,QAAQ;AAAA,IACR,UAAU,CAAC,UAAU,MAAM,cAAc,OAAO,MAAM;AAAA,IACtD,OAAO,QAAQ,QAAQ;AACpB,aAAO,qBAAqB,QAAQ,QAAQ,SAAS;AAAA;AAAA,IAExD,QAAQ,EAAC,UAAU,QAAQ,UAAS,OAAO,GAAG,MAAM;AACjD,UAAI,CAAC,uBAAuB,OAAO,QAAQ,WAAW;AACnD,eAAO,KAAK;AAAA;AAGf,YAAM,IAAI,iBACP,KAAK,OAAO,eAAe,SAAS,eAAe,UACnD,OAAO;AAAA;AAAA;AAKhB,SAAO;AAAA;AAnFV;AAAA;AAEA;AACA;AACA;AACA;AAAA;AAAA;;;ACLA,IAIa;AAJb;AAAA;AAIO,IAAM,mBAAmB,CAAC,SAA2B;AACzD,aAAO,KAAK,MAAM,OACd,IAAI,UAAQ,KAAK,QACjB,OAAO,UAAQ,CAAC,CAAC;AAAA;AAAA;AAAA;;;ACPxB;AAAA;AAAA;AAAA;AAGO,yBAAyB,OAAuC;AACpE,SAAO;AAAA,IACJ,UAAU,CAAC,gBAAgB,GAAG;AAAA,IAC9B,QAAQ;AAAA,IACR,QAAQ;AAAA;AAAA;AAPd;AAAA;AACA;AAAA;AAAA;;;ACDA;AAAA;AAAA;AAAA;AAAA;AAoBA,2BAA2B,SAAiB;AACzC,SAAO,sBAAsB,KAAK;AAAA;AAG9B,mBAAmB,MAA0B,WAA+B,YAAsD;AACtI,QAAM,WAAW,CAAC,SAAS,GAAG;AAE9B,eAAa,SAAS,SAAS,KAAK;AACpC,eAAa,cAAc,SAAS,KAAK;AAEzC,QAAM,SAAS,SAAS,KAAK;AAC7B,MAAI,QAAQ;AACT,WAAO,uBAAuB;AAAA;AAGjC,SAAO,0BAA0B;AAAA;AAG7B,yBAAyB,MAA0B,WAA+B,YAAsB;AAC5G,SAAO,YAAY;AAEnB,SAAO,UAAU,MAAM,WAAW;AAAA;AAzCrC;AAAA;AAAA;AAEA;AAAA;AAAA;;;ACmBO,0BAA2B,QAAgB,QAA6B;AAC5E,QAAM,SAAsB;AAAA,IACzB,KAAK;AAAA,IACL,QAAQ;AAAA,IACR,UAAU;AAAA,IACV,MAAM;AAAA;AAET,SAAO,oBAAoB,QAAQ,UAAS,CAAC,QAAQ;AAAA;AA5BxD,IAGM;AAHN;AAAA;AACA;AAEA,IAAM,WAAqC;AAAA,MACxC,IAAI,WAAW,cAAc,CAAC,QAAQ,CAAC,YAAY;AAChD,eAAO,SAAS;AAAA;AAAA,MAEnB,IAAI,WAAW,uCAAuC,CAAC,QAAQ,CAAC,MAAM,cAAa;AAChF,eAAO,SAAS,KAAK;AAAA,UAClB;AAAA,UACA;AAAA;AAAA;AAAA,MAGN,IAAI,WAAW,oCAAoC,CAAC,QAAQ,CAAC,MAAM,cAAc;AAC9E,eAAO,KAAK,KAAK;AAAA,UACd;AAAA,UACA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AChBT;AAAA;AAAA;AAAA;AAMA,4BAA2B,SAAiB;AACzC,SAAO,sBAAsB,KAAK;AAAA;AAG9B,mBAAmB,QAAgB,QAAgB,YAA2D;AAClH,QAAM,WAAW,CAAC,SAAS,GAAG;AAC9B,MAAI,UAAU,QAAQ;AACnB,aAAS,KAAK,QAAQ;AAAA;AAGzB,QAAM,SAAS,SAAS,KAAK;AAC7B,MAAI,QAAQ;AACT,WAAO,uBAAuB;AAAA;AAGjC,SAAO;AAAA,IACJ;AAAA,IACA,QAAQ;AAAA,IACR,QAAQ;AAAA;AAAA;AAxBd;AAAA;AACA;AAGA;AAAA;AAAA;;;ACKO,yBAA0B,QAA4B;AAC1D,SAAO,oBAAoB,EAAC,OAAO,MAAK,WAAS;AAAA;AAVpD,IAGM;AAHN;AAAA;AACA;AAEA,IAAM,YAAoC;AAAA,MACvC,IAAI,WAAW,2BAA2B,CAAC,QAAQ,CAAC,MAAM,QAAQ;AAC/D,eAAO,MAAM,KAAK,EAAC,MAAM;AAAA;AAAA;AAAA;AAAA;;;ACL/B;AAAA;AAAA;AAAA;AAKO,kBAAkB,MAAyB,IAAoC;AACnF,SAAO;AAAA,IACJ,UAAU,CAAC,MAAM,MAAM,GAAG,QAAQ,OAAO;AAAA,IACzC,QAAQ;AAAA,IACR,QAAQ;AAAA;AAAA;AATd;AAAA;AACA;AAEA;AAAA;AAAA;;;ACHA;AAAA;AAAA;AAAA;AAMO,kBAAkB,QAAuB,QAAuB,YAA8C;AAClH,QAAM,WAAqB,CAAC,QAAQ,GAAG;AACvC,MAAI,UAAU,QAAQ;AACnB,aAAS,OAAO,GAAG,GAAG,QAAQ;AAAA;AAGjC,SAAO;AAAA,IACJ;AAAA,IACA,QAAQ;AAAA,IACR,OAAO,QAAQ,QAAoB;AAChC,aAAO,gBAAgB,QAAQ;AAAA;AAAA,IAElC,QAAQ,QAAQ,QAAQ,OAAO,MAAM;AAClC,YAAM,YAAY,qBAAqB,eAAe,OAAO,SAAS,eAAe,OAAO;AAC5F,UAAI,WAAW;AACZ,eAAO,KAAK,IAAI,iBAAiB;AAAA;AAGpC,WAAK;AAAA;AAAA;AAAA;AAxBd;AAAA;AACA;AACA;AAEA;AAAA;AAAA;;;ACSO,yBAA0B,MAAmC;AACjE,QAAM,UAA+C;AAErD,UAAQ,MAAM,CAAC,CAAC,UAAU,QAAQ,QAAQ,EAAE;AAE5C,SAAO,OAAO,OAAO;AAAA;AAGjB,gCAAiC,MAAgC;AACrE,QAAM,UAA4C;AAElD,UAAQ,MAAM,CAAC,CAAC,MAAM,KAAK,aAAa;AACrC,QAAI,CAAC,QAAQ,eAAe,OAAO;AAChC,cAAQ,QAAQ;AAAA,QACb;AAAA,QACA,MAAM,EAAE,OAAO,IAAI,MAAM;AAAA;AAAA;AAI/B,QAAI,WAAW,KAAK;AACjB,cAAQ,MAAM,KAAK,QAAQ,QAAQ,WAAW,OAAuC;AAAA;AAAA;AAI3F,SAAO,OAAO,OAAO;AAAA;AAGxB,iBAAiB,MAAc,SAAmC;AAC/D,yBAAuB,MAAM,CAAC,SAAS,QAAQ,KAAK,MAAM;AAAA;AAzC7D;AAAA;AAAA;AAAA;AAAA;;;ACAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIO,uBAAuB,YAAoB,YAAoB,aAAuB,IAAwB;AAClH,SAAO,0BAA0B,CAAC,UAAU,OAAO,GAAG,YAAY,YAAY;AAAA;AAG1E,wBAAwB,SAAmC;AAC/D,QAAM,WAAW,CAAC;AAClB,MAAI,SAAS;AACV,aAAS,KAAK;AAAA;AAGjB,SAAO;AAAA,IACJ;AAAA,IACA,QAAQ;AAAA,IACR,QAAQ,UAAU,yBAAyB;AAAA;AAAA;AAI1C,yBAAyB,aAAuB,IAAwB;AAC5E,QAAM,WAAW,CAAC,GAAG;AACrB,MAAI,SAAS,OAAO,aAAa;AAC9B,aAAS,QAAQ;AAAA;AAGpB,SAAO,0BAA0B;AAAA;AAG7B,oBAAoB,aAAuB,IAAwB;AACvE,QAAM,WAAW,CAAC,GAAG;AACrB,MAAI,SAAS,OAAO,UAAU;AAC3B,aAAS,QAAQ;AAAA;AAGpB,SAAO,0BAA0B;AAAA;AAG7B,0BAA0B,YAAoB;AAClD,SAAO,0BAA0B,CAAC,UAAU,UAAU;AAAA;AAxCzD;AAAA;AAAA;AAEA;AAAA;AAAA;;;ACFA;AAAA;AAAA;AAAA;AAQO,uBAAuB,MAAkB,IAAI,YAAyD;AAC1G,QAAM,UAAU,gBAAqB;AACrC,QAAM,WAAW,CAAC,SAAS,QAAQ,GAAG,QAAQ,UAAU,GAAG;AAC3D,QAAM,UAAS,2BAA2B,QAAQ,UAAU,QAAQ,QAAQ,qBAAqB;AAEjG,SAAO,wBAAwB,aAAa;AAAA,IACzC;AAAA,IACA,QAAQ;AAAA,IACR;AAAA;AAAA;AAhBN;AAAA;AACA;AACA;AAEA;AACA;AAAA;AAAA;;;ACLA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGO,0BAA0B,MAAc,MAAkC;AAC9E,SAAO,cAAc,CAAC,OAAO,MAAM;AAAA;AAG/B,2BAA2B,YAA0C;AACzE,SAAO,cAAc,CAAC,QAAQ,GAAG;AAAA;AAG7B,uBAAuB,YAA0C;AACrE,QAAM,WAAW,CAAC,GAAG;AACrB,MAAI,SAAS,OAAO,aAAa;AAC9B,aAAS,QAAQ;AAAA;AAGpB,SAAO,0BAA0B;AAAA;AAG7B,6BAA6B,YAA0C;AAC3E,SAAO,cAAc,CAAC,UAAU,GAAG;AAAA;AArBtC;AAAA;AACA;AAAA;AAAA;;;ACyCA,sBAAsB,GAAW,GAAoB;AAClD,QAAM,SAAS,MAAM;AACrB,QAAM,SAAS,MAAM;AAErB,MAAI,WAAW,QAAQ;AACpB,WAAO,SAAS,IAAI;AAAA;AAGvB,SAAO,SAAS,OAAO,GAAG,KAAK;AAAA;AAGlC,gBAAgB,GAAW,GAAW;AACnC,SAAO,MAAM,IAAI,IAAI,IAAI,IAAI,IAAI;AAAA;AAGpC,iBAAiB,OAAe;AAC7B,SAAO,MAAM;AAAA;AAGhB,kBAAkB,OAA2B;AAC1C,MAAI,OAAO,UAAU,UAAU;AAC5B,WAAO,SAAS,MAAM,QAAQ,SAAS,KAAK,OAAO;AAAA;AAGtD,SAAO;AAAA;AAlEV,IAEO,SAQM;AAVb;AAAA;AAEO,oBAAmC;AAAA,MACvC,YACmB,KACA,QACjB;AAFiB;AACA;AAAA;AAAA;AAKf,IAAM,eAAe,SAAU,MAAc,aAAa,OAAO;AACrE,YAAM,OAAO,KACT,MAAM,MACN,IAAI,SACJ,OAAO;AAEX,UAAI,CAAC,YAAY;AACd,aAAK,KAAK,SAAU,MAAM,MAAM;AAC7B,gBAAM,SAAS,KAAK,MAAM;AAC1B,gBAAM,SAAS,KAAK,MAAM;AAE1B,cAAI,OAAO,WAAW,KAAK,OAAO,WAAW,GAAG;AAC7C,mBAAO,aAAa,SAAS,OAAO,KAAK,SAAS,OAAO;AAAA;AAG5D,mBAAS,IAAI,GAAG,IAAI,KAAK,IAAI,OAAO,QAAQ,OAAO,SAAS,IAAI,GAAG,KAAK;AACrE,kBAAM,OAAO,OAAO,SAAS,OAAO,KAAK,SAAS,OAAO;AAEzD,gBAAI,MAAM;AACP,qBAAO;AAAA;AAAA;AAIb,iBAAO;AAAA;AAAA;AAIb,YAAM,SAAS,aAAa,KAAK,KAAK,CAAC,GAAG,MAAM,UAAU,KAAK,CAAC,QAAQ,IAAI,QAAQ,QAAQ;AAE5F,aAAO,IAAI,QAAQ,MAAM;AAAA;AAAA;AAAA;;;ACvC5B;AAAA;AAAA;AAAA;AAAA;AAAA;AAOO,qBAAsB,aAAuB,IAA2B;AAC5E,QAAM,gBAAgB,WAAW,KAAK,CAAC,WAAW,WAAW,KAAK;AAElE,SAAO;AAAA,IACJ,QAAQ;AAAA,IACR,UAAU,CAAC,OAAO,MAAM,GAAG;AAAA,IAC3B,OAAQ,MAAc;AACnB,aAAO,aAAa,MAAM;AAAA;AAAA;AAAA;AAQ5B,oBAAqB,MAA0C;AACnE,SAAO;AAAA,IACJ,QAAQ;AAAA,IACR,UAAU,CAAC,OAAO;AAAA,IAClB,SAAU;AACP,aAAO,EAAC;AAAA;AAAA;AAAA;AAQV,6BAA8B,MAAc,YAAgD;AAChG,SAAO;AAAA,IACJ,QAAQ;AAAA,IACR,UAAU,CAAC,OAAO,MAAM,MAAM,YAAY;AAAA,IAC1C,SAAU;AACP,aAAO,EAAC;AAAA;AAAA;AAAA;AAxCjB;AAAA;AACA;AAAA;AAAA;;;ACDA;AAAA;AAAA,QAAM,EAAC,8BAAe;AACtB,QAAM,EAAC,gCAAgB;AAEvB,QAAM,EAAC,0BAAa;AACpB,QAAM,EAAC,oDAA0B;AACjC,QAAM;AAAA,MACH;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,QACC;AACJ,QAAM,EAAC,oCAAkB;AACzB,QAAM,EAAC,yBAAY,mCAAiB,yCAAoB,wCAAoB;AAC5E,QAAM,EAAC,sCAAmB;AAC1B,QAAM,EAAC,sCAAmB;AAC1B,QAAM,EAAC,uBAAW,sCAAmB;AACrC,QAAM,EAAC,6CAAsB,8CAAuB;AACpD,QAAM,EAAC,4BAAc;AACrB,QAAM,EAAC,sCAAmB;AAC1B,QAAM,EAAC,0BAAa;AACpB,QAAM,EAAC,wBAAY;AACnB,QAAM,EAAC,wBAAY;AACnB,QAAM,EAAC,gCAAgB;AACvB,QAAM,EAAC,+BAAe,iCAAgB,mCAAiB,yBAAY,wCAAoB;AACvF,QAAM,EAAC,6BAAc,0BAAa;AAClC,QAAM,EAAC,kCAAiB;AACxB,QAAM,EAAC,qCAAkB,uCAAmB,+BAAe,8CAAuB;AAClF,QAAM,EAAC,2CAAqB,yBAAY,8BAAe;AACvD,QAAM,EAAC,uDAA2B,0DAA6B;AAE/D,kBAAc,SAAS,SAAS;AAC7B,WAAK,YAAY,IAAI,aAClB,QAAQ,QAAQ,QAAQ,SACxB,IAAI,WAAU,QAAQ,yBAAyB;AAAA;AAIrD,IAAC,MAAI,YAAY,OAAO,OAAO,cAAa,YAAY,cAAc;AAStE,SAAI,UAAU,eAAe,SAAU,SAAS;AAC7C,WAAK,UAAU,SAAS;AACxB,aAAO;AAAA;AAWV,SAAI,UAAU,MAAM,SAAU,MAAM,OAAO;AACxC,UAAI,UAAU,WAAW,KAAK,OAAO,SAAS,UAAU;AACrD,aAAK,UAAU,MAAM;AAAA,aACjB;AACJ,QAAC,MAAK,UAAU,MAAM,KAAK,UAAU,OAAO,IAAI,QAAQ;AAAA;AAG3D,aAAO;AAAA;AAMV,SAAI,UAAU,YAAY,SAAU,SAAS;AAC1C,aAAO,KAAK,SACT,eACG,yBAAwB,cAAc,IACtC,aAAY,YAAY,WAAW,KAEtC,0BAAyB;AAAA;AAI/B,6BAA0B,KAAK,MAAM,UAAU,WAAW;AACvD,UAAI,OAAO,aAAa,UAAU;AAC/B,eAAO,wBAAuB,OAAQ;AAAA;AAGzC,aAAO,KAAK,UAAU,YAAW,WAAW,gBAAe,oBAAmB;AAAA;AAOjF,SAAI,UAAU,QAAQ,WAAY;AAC/B,aAAO,KAAK,SACT,gBAAgB,SAAS,YAAW,GAAG,YACvC,0BAAyB;AAAA;AAO/B,SAAI,UAAU,SAAS,WAAY;AAChC,aAAO,KAAK,SACT,gBAAgB,UAAU,kBAAiB,GAAG,YAC9C,0BAAyB;AAAA;AAY/B,SAAI,UAAU,KAAK,SAAU,MAAM,IAAI;AACpC,aAAO,KAAK,SAAS,UAAS,MAAM,KAAK,0BAAyB;AAAA;AAQrE,SAAI,UAAU,oBAAoB,SAAU,MAAM;AAC/C,UAAI,MAAM;AACV,aAAO,KAAK,KAAK,WAAY;AAC1B,YAAI,KAAK,SAAU,KAAK,MAAM;AAC3B,cAAI,SAAS,KAAK,QAAQ;AAAA;AAAA;AAAA;AAQnC,SAAI,UAAU,OAAO,SAAU,QAAQ,QAAQ,SAAS,MAAM;AAC3D,aAAO,KAAK,SACT,UAAS,YAAW,QAAQ,gBAAe,YAAW,QAAQ,gBAAe,oBAAmB,aAChG,0BAAyB;AAAA;AAc/B,SAAI,UAAU,QAAQ,SAAU,QAAQ,QAAQ;AAC7C,aAAO,KAAK,SACT,WAAU,YAAW,QAAQ,gBAAe,YAAW,QAAQ,gBAAe,oBAAmB,aACjG,0BAAyB;AAAA;AAW/B,SAAI,UAAU,SAAS,SAAU,SAAS;AACvC,cAAQ,KAAK;AACb,aAAO;AAAA;AAYV,SAAI,UAAU,OAAO,SAAU,SAAS,MAAM;AAC3C,aAAO,KAAK,SACT,aAAY,oBAAmB,aAC/B,0BAAyB;AAAA;AAQ/B,SAAI,UAAU,SAAS,WAAY;AAChC,aAAO,KAAK,SACT,2BAA0B,CAAC,UAAU,GAAG,oBAAmB,cAC3D,0BAAyB;AAAA;AAO/B,SAAI,UAAU,QAAQ,SAAU,MAAM;AACnC,aAAO,KAAK,SACT,WAAU,cAAa,OAAO,oBAAmB,aACjD,0BAAyB;AAAA;AAO/B,SAAI,UAAU,SAAS,SAAU,QAAQ;AACtC,YAAM,OAAO,0BAAyB;AAEtC,UAAI,OAAO,WAAW,UAAU;AAC7B,eAAO,KAAK,SACT,wBAAuB,4BACvB;AAAA;AAIN,aAAO,KAAK,SACT,2BAA0B,CAAC,UAAU,GAAG,oBAAmB,WAAW,GAAG,OAAO,UAChF;AAAA;AAON,SAAI,UAAU,SAAS,SAAU,MAAM;AACpC,YAAM,OAAQ,OAAO,SAAS,WACzB,YAAW,QACX,wBAAuB;AAE5B,aAAO,KAAK,SAAS,MAAM,0BAAyB;AAAA;AAMvD,SAAI,UAAU,kBAAkB,SAAU,SAAS,YAAY;AAC5D,aAAO,KAAK,SACT,qBAAoB,SAAS,aAC7B,0BAAyB;AAAA;AAQ/B,SAAI,UAAU,WAAW,WAAY;AAClC,YAAM,WAAW,CAAC,YAAY,GAAG,oBAAmB,WAAW;AAC/D,aAAO,KAAK,SACT,2BAA0B,WAC1B,0BAAyB;AAAA;AAW/B,SAAI,UAAU,iBAAiB,SAAU,YAAY,YAAY,MAAM;AACpE,aAAO,KAAK,SAAS,CAAC,MAAM,YAAY,aAAa,0BAAyB;AAAA;AAMjF,SAAI,UAAU,sBAAsB,SAAU,YAAY,MAAM;AAC7D,aAAO,KAAK,SAAS,CAAC,MAAM,aAAa,0BAAyB;AAAA;AAMrE,SAAI,UAAU,oBAAoB,SAAU,YAAY,aAAa,MAAM;AACxE,aAAO,KAAK,SACT,kBAAiB,YAAY,OAAO,gBAAgB,YAAY,cAAc,QAC9E,0BAAyB;AAAA;AAO/B,SAAI,UAAU,sBAAsB,SAAU,aAAa,aAAa,MAAM;AAC3E,aAAO,KAAK,SACT,oBAAmB,aAAa,OAAO,gBAAgB,YAAY,cAAc,QACjF,0BAAyB;AAAA;AAU/B,SAAI,UAAU,SAAS,SAAU,SAAS,MAAM;AAC7C,aAAO,KAAK,SACT,YAAW,oBAAmB,aAC9B,0BAAyB;AAAA;AAS/B,SAAI,UAAU,cAAc,SAAU,MAAM;AACzC,aAAO,KAAK,SACT,oBACA,0BAAyB;AAAA;AAO/B,SAAI,UAAU,MAAM,SAAU,UAAU;AACrC,YAAM,qBAAqB,CAAC,MAAM,QAAQ;AAC1C,YAAM,UAAU,GAAG,MAAM,KAAK,qBAAqB,YAAY,UAAU;AAEzE,eAAS,IAAI,GAAG,IAAI,QAAQ,UAAU,oBAAoB,KAAK;AAC5D,YAAI,CAAC,kBAAiB,QAAQ,KAAK;AAChC,kBAAQ,OAAO,GAAG,QAAQ,SAAS;AACnC;AAAA;AAAA;AAIN,cAAQ,KACL,GAAG,oBAAmB,WAAW,GAAG;AAGvC,UAAI,OAAO,0BAAyB;AAEpC,UAAI,CAAC,QAAQ,QAAQ;AAClB,eAAO,KAAK,SACT,wBAAuB,oDACvB;AAAA;AAIN,aAAO,KAAK,SAAS,2BAA0B,UAAU;AAAA;AAG5D,SAAI,UAAU,eAAe,SAAU,MAAM,MAAM,MAAM;AACtD,aAAO,KAAK,SACT,kBAAiB,MAAM,OACvB,0BAAyB;AAAA;AAI/B,SAAI,UAAU,kBAAkB,SAAU,MAAM,MAAM;AACnD,aAAO,KAAK,SACT,qBAAoB,oBAAmB,WAAW,QAClD,0BAAyB;AAAA;AAI/B,SAAI,UAAU,gBAAgB,SAAU,MAAM,MAAM;AACjD,aAAO,KAAK,SACT,mBAAkB,oBAAmB,WAAW,QAChD,0BAAyB;AAAA;AAI/B,SAAI,UAAU,YAAY,SAAU,SAAS,MAAM;AAChD,aAAO,KAAK,SACT,eAAc,oBAAmB,aACjC,0BAAyB;AAAA;AAI/B,SAAI,UAAU,aAAa,WAAY;AACpC,aAAO,KAAK,SACT,iBAAgB,oBAAmB,aACnC,0BAAyB;AAAA;AAO/B,SAAI,UAAU,YAAY,SAAU,YAAY,YAAY,MAAM;AAC/D,aAAO,KAAK,SACT,eAAc,YAAY,YAAY,oBAAmB,aACzD,0BAAyB;AAAA;AAO/B,SAAI,UAAU,eAAe,SAAU,YAAY,MAAM;AACtD,aAAO,KAAK,SACT,kBAAiB,aACjB,0BAAyB;AAAA;AAQ/B,SAAI,UAAU,aAAa,SAAU,SAAS,MAAM;AACjD,aAAO,KAAK,SACT,gBAAe,YAAY,OAC3B,0BAAyB;AAAA;AAU/B,SAAI,UAAU,SAAS,SAAU,SAAS,MAAM;AAC7C,aAAO,KAAK,SACT,YAAW,oBAAmB,aAC9B,0BAAyB;AAAA;AAU/B,SAAI,UAAU,MAAM,SAAU,SAAS,MAAM;AAC1C,YAAM,UAAU,oBAAmB;AAEnC,UAAI,QAAQ,OAAO,OAAO;AACvB,gBAAQ,QAAQ;AAAA;AAGnB,aAAO,KAAK,SACT,2BAA0B,UAC1B,0BAAyB;AAAA;AAS/B,SAAI,UAAU,mBAAmB,SAAU,MAAM;AAC9C,aAAO,KAAK,SACT,2BAA0B,CAAC,wBAC3B,0BAAyB;AAAA;AAW/B,SAAI,UAAU,WAAW,SAAU,QAAQ,MAAM;AAC9C,YAAM,OAAO,cAAa,EAAC,QAAQ,YAAW,QAAQ,kBAAgB,oBAAmB;AAEzF,aAAO,KAAK,SAAS,MAAM,0BAAyB;AAAA;AAMvD,SAAI,UAAU,KAAK,SAAU,OAAO;AACjC,aAAO,KAAK,SACT,2BAA0B,CAAC,MAAM,MAAM,GAAG,SAAQ,UAClD,0BAAyB;AAAA;AAU/B,SAAI,UAAU,cAAc,SAAU,OAAO;AAC1C,aAAO,KAAK,SACT,2BAA0B,CAAC,MAAM,YAAY,GAAG,SAAQ,UACxD,0BAAyB;AAAA;AAa/B,SAAI,UAAU,UAAU,SAAU,SAAS,MAAM;AAC9C,aAAO,KAAK,SAAS,SAAS;AAAA;AAGjC,SAAI,UAAU,gBAAgB,WAAY;AACvC,aAAO,KAAK,SAAS,UAAU;AAAA;AAGlC,SAAI,UAAU,WAAW,SAAU,QAAQ,MAAM;AAC9C,UAAI,UAAU,0BAAyB;AACvC,UAAI,UAAU,CAAC;AACf,UAAI,UAAU,KAAK;AAEnB,UAAI,OAAO,YAAY,UAAU;AAC9B,eAAO,KAAK,SACT,wBAAuB,iEACvB;AAAA;AAIN,UAAI,MAAM,QAAQ,UAAU;AACzB,gBAAQ,KAAK,MAAM,SAAS;AAAA;AAG/B,YAAM,OAAO,WAAW,WACnB,2BAA0B,WAC1B,2BAA0B;AAE/B,aAAO,KAAK,SAAS,MAAM;AAAA;AAG9B,SAAI,UAAU,OAAO,SAAU,SAAS,MAAM;AAC3C,YAAM,OAAO,cAAa,WACrB,wBAAuB,0GACvB,2BAA0B,CAAC,QAAQ,GAAG,oBAAmB;AAE9D,aAAO,KAAK,SACT,MACA,0BAAyB;AAAA;AAI/B,SAAI,UAAU,cAAc,WAAY;AACrC,aAAO,KAAK,SACT,iBAAgB,oBAAmB,WAAW,KAC9C,0BAAyB;AAAA;AAI/B,SAAI,UAAU,aAAa,SAAU,SAAS;AAC3C,YAAM,OAAO,CAAC,2BAA0B,WACnC,wBAAuB,8EACvB,gBAAe,SAAQ,UAAU,oBAAmB,GAAG,MAAM,KAAK,WAAW;AAElF,aAAO,KAAK,SACT,MACA,0BAAyB;AAAA;AAI/B,SAAI,UAAU,WAAW,WAAY;AAClC,YAAM,WAAW,CAAC,aAAa,GAAG,oBAAmB,WAAW;AAChE,aAAO,KAAK,SACT,2BAA0B,UAAU,OACpC,0BAAyB;AAAA;AAU/B,SAAI,UAAU,OAAO,SAAU,SAAS,MAAM;AAC3C,aAAO,KAAK,SACT,2BAA0B,CAAC,QAAQ,GAAG,oBAAmB,WAAW,MACpE,0BAAyB;AAAA;AAM/B,SAAI,UAAU,QAAQ,SAAU,MAAM,SAAS,MAAM;AAClD,YAAM,yBAAyB,qBAAoB;AACnD,YAAM,YAAY,0BAA0B,KAAK,KAAK,OAAO,YAAW,MAAM,kBAAiB;AAC/F,YAAM,aAAa,oBAAmB,GAAG,MAAM,KAAK,WAAW,yBAAyB,IAAI;AAE5F,aAAO,KAAK,SACT,sBAAqB,WAAW,aAChC,0BAAyB;AAAA;AAI/B,SAAI,UAAU,OAAO,SAAU,MAAM;AAClC,YAAM,OAAO;AAAA,QACV,UAAU;AAAA,QACV,QAAQ;AAAA,QACR,SAAU;AACP,cAAI,OAAO,SAAS,YAAY;AAC7B;AAAA;AAAA;AAAA;AAKT,aAAO,KAAK,SAAS;AAAA;AAQxB,SAAI,UAAU,aAAa,WAAY;AAGpC,aAAO;AAAA;AASV,SAAI,UAAU,cAAc,SAAU,WAAW,MAAM;AACpD,aAAO,KAAK,SACT,iBAAgB,SAAS,YAAW,WAAW,4BAA2B,OAC1E,0BAAyB;AAAA;AAI/B,SAAI,UAAU,cAAc,SAAU,WAAW,MAAM;AACpD,aAAO,KAAK,SACT,iBAAgB,YAAW,WAAW,iBACtC,0BAAyB;AAAA;AAI/B,WAAO,UAAU;AAAA;AAAA;;;ACjpBjB;AAYO,sCAAgC,SAAS;AAAA,EAE7C,YACmB,QAChB,SACD;AACC,UAAM,QAAW;AAHD;AAAA;AAAA;;;ACdtB;;;ACAA;AAEO,mCAA6B,SAAS;AAAA,EAE1C,YACU,MACS,QAChB,SACD;AACC,UAAM,MAAM;AAJL;AACS;AAIhB,WAAO,eAAe,MAAM,WAAW;AAAA;AAAA;;;ADR7C;AACA;AACA;AACA;AACA;AACA;AACA;;;AETA;AAGO,sCAAsC,eAAwD;AAClG,QAAM,SAAS,cAAc,eAAe;AAE5C,SAAO;AAAA,IACJ,MAAM;AAAA,IACN,OAAO,MAAM;AACV,aAAO,CAAC,GAAG,QAAQ,GAAG;AAAA;AAAA;AAAA;;;ACP/B;AAFA;AAKA,IAAM,QAAQ,WAAW;AAElB,mCAAmC;AAAA,EACG,UAAU;AAAA,EACV,SAAS;AAAA,IAC6B,IAAoC;AAEpH,0BAAwB;AACrB,QAAI,WAAW;AACf,UAAM,SAAS;AAAA,MACZ,OAAO;AAAA,MACP,cAAc;AAAA,MACd,MAAM;AAAA,MACN,aAAa;AAAA;AAGhB,UAAM,SAAS,QAAQ,KAAK;AAAA,MACzB,YAAY,QAAQ,QAAQ,OAAO,aAAa;AAAA,MAChD,WAAW,QAAQ,QAAQ,OAAO,YAAY;AAAA;AAGjD,qBAAiB,SAAS,OAAO,OAAO,OAAO;AAC/C,qBAAiB,QAAQ,OAAO,MAAM,OAAO;AAE7C,WAAO;AAAA,MACJ,MAAM,MAAc;AACjB,mBAAW;AACX,eAAO,MAAM;AAAA;AAAA,MAEhB,KAAK,MAAc;AAChB,mBAAW;AACX,eAAO,KAAK;AAAA;AAAA,UAEX,WAAW;AACZ,eAAO;AAAA;AAAA,MAEV;AAAA;AAAA;AAIN,4BAA0B,MAAwB,OAA8B,SAAgC;AAC7G,QAAI,SAAS,OAAO;AACjB;AAAA;AAGH,IAAC,UAAS,OAAO,MAAM,UAAU,MAAM,QAAQ,KAAK,MAAM,MAAM,QAAQ,KAAK,QAAQ;AAAA;AAGxF,SAAO;AAAA,IACJ,MAAM;AAAA,IACA,OAAO,IAAO,IAAkB;AAAA,iDAAzB,OAAO,EAAC,SAAS,SAAQ;AAvD5C;AAwDS,cAAM,SAAS;AAEf,YAAI,aAAa;AACjB,YAAI,aAAa,MAAM,KAAM,cAAa;AAE1C,uBAAQ,WAAR,oBAAgB,GAAG,QAAQ;AAC3B,sBAAQ,WAAR,mBAAgB,GAAG,QAAQ;AAC3B,gBAAQ,GAAG,SAAS;AAEpB,gBAAQ,GAAG,SAAS,CAAC,SAAiB,OAAO,MAAM;AACnD,gBAAQ,GAAG,QAAQ,CAAC,SAAiB,OAAO,KAAK;AAEjD,YAAG;AACA,gBAAM,OAAO;AACb,cAAI,YAAY;AACb,kBAAM,MAAM;AAAA;AAEf,gBAAM,OAAO;AAAA,iBAET,KAAP;AACG,gBAAM,OAAO,UAAU;AAAA;AAAA;AAAA;AAAA;AAAA;;;AC5EnC;AAMA,qBAAsB,QAAoB;AACvC,SAAO,CAAC,CAAE,QAAO,YAAY,OAAO,OAAO;AAAA;AAG9C,yBAA0B,QAAoB;AAC3C,SAAO,OAAO,OAAO,CAAC,GAAG,OAAO,QAAQ,GAAG,OAAO;AAAA;AAG9C,+BAAgC,YAAY,OAAO,UAAU,aAAa,eAAuD,iBAAiB;AAEtJ,SAAO,CAAC,OAAmC,WAAuB;AAC/D,QAAK,CAAC,aAAa,SAAU,CAAC,QAAQ,SAAS;AAC5C,aAAO;AAAA;AAGV,WAAO,aAAa;AAAA;AAAA;AAInB,8BAA8B,QAAwE;AAE1G,SAAO;AAAA,IACJ,MAAM;AAAA,IACN,OAAO,MAAM,SAAS;AACnB,YAAM,QAAQ,OAAO,KAAK,OAAO;AAAA,QAC9B,QAAQ,QAAQ;AAAA,QAChB,QAAQ,QAAQ;AAAA,QAChB,UAAU,QAAQ;AAAA;AAGrB,UAAI,OAAO,SAAS,QAAQ;AACzB,eAAO,EAAC,OAAO,IAAI,SAAS,QAAW,MAAM,SAAS;AAAA;AAGzD,aAAO;AAAA,QACJ;AAAA;AAAA;AAAA;AAAA;;;ACxCZ;AAEO,wBAAkB;AAAA,EAAlB,cAHP;AAKW,mBAAqD,oBAAI;AAAA;AAAA,EAE1D,IAAmC,QAA0D;AACjG,UAAM,UAAgC;AAEtC,YAAQ,QAAQ,QAAQ,aAAU,WAAU,KAAK,QAAQ,IAAI,OAAO,SAAS;AAE7E,WAAO,MAAM;AACV,cAAQ,QAAQ,aAAU,KAAK,QAAQ,OAAO;AAAA;AAAA;AAAA,EAI7C,KAAoC,MAAS,MAAuC,SAA0D;AAClJ,QAAI,SAAS;AACb,UAAM,aAAa,OAAO,OAAO,OAAO,OAAO;AAE/C,eAAW,UAAU,KAAK,SAAS;AAChC,UAAI,OAAO,SAAS,MAAM;AACvB,iBAAS,OAAO,OAAO,QAAQ;AAAA;AAAA;AAIrC,WAAO;AAAA;AAAA;;;AC1Bb;AAIO,+BAA+B,UAAuD;AAC1F,QAAM,kBAAkB;AACxB,QAAM,kBAAkB,CAAC,YAAY,SAAS,SAAS,QAAQ;AAE/D,QAAM,aAA6C;AAAA,IAChD,MAAM;AAAA,IACN,OAAO,OAAO,SAAS;AAX7B;AAYS,UAAI,CAAC,QAAQ,SAAS,SAAS,kBAAkB;AAC9C;AAAA;AAGH,qBAAQ,QAAQ,WAAhB,oBAAwB,GAAG,QAAQ,CAAC,UAAkB;AACnD,cAAM,UAAU,yCAAyC,KAAK,MAAM,SAAS;AAC7E,YAAI,CAAC,SAAS;AACX;AAAA;AAGH,iBAAS;AAAA,UACN,QAAQ,QAAQ;AAAA,UAChB,OAAO,mBAAmB,QAAQ;AAAA,UAClC,UAAU,SAAS,QAAQ;AAAA,UAC3B,WAAW,SAAS,QAAQ;AAAA,UAC5B,OAAO,SAAS,QAAQ;AAAA;AAAA;AAAA;AAAA;AAMpC,QAAM,SAAwC;AAAA,IAC3C,MAAM;AAAA,IACN,OAAO,MAAM,SAAS;AACnB,UAAI,CAAC,gBAAgB,SAAS,QAAQ,SAAS;AAC5C,eAAO;AAAA;AAGV,aAAO,UAAU,MAAM;AAAA;AAAA;AAI7B,SAAO,CAAC,QAAQ;AAAA;AAGnB,4BAA6B,OAAe;AACzC,SAAO,OAAO,MAAM,cAAc,MAAM,KAAK,OAAO;AAAA;;;AC/CvD;AAGO,4BAA4B,cAAuE;AACvG,QAAM,UAAU,KAAK,cAAc,CAAC,OAAO;AAE3C,SAAO;AAAA,IACJ,MAAM;AAAA,IACN,OAAO,MAAM;AACV,aAAO,kCAAI,UAAY;AAAA;AAAA;AAAA;;;ACLzB,uBAAuB,EAAC,SAAgG;AAE5H,MAAI,QAAQ,GAAG;AACZ,WAAO;AAAA,MACJ,MAAM;AAAA,MACN,OAAO,OAAO,SAAS;AAVhC;AAWY,YAAI;AAEJ,wBAAgB;AACb,qBAAW,aAAa;AACxB,oBAAU,WAAW,MAAM;AAAA;AAG9B,wBAAgB;AAlB5B;AAmBe,yBAAQ,QAAQ,WAAhB,oBAAwB,IAAI,QAAQ;AACpC,yBAAQ,QAAQ,WAAhB,oBAAwB,IAAI,QAAQ;AACpC,kBAAQ,QAAQ,IAAI,QAAQ;AAC5B,kBAAQ,QAAQ,IAAI,SAAS;AAC7B,qBAAW,aAAa;AAAA;AAG3B,wBAAgB;AACb;AACA,kBAAQ,KACL,IAAI,eAAe,QAAW,WAAW;AAAA;AAI/C,uBAAQ,QAAQ,WAAhB,oBAAwB,GAAG,QAAQ;AACnC,sBAAQ,QAAQ,WAAhB,mBAAwB,GAAG,QAAQ;AACnC,gBAAQ,QAAQ,GAAG,QAAQ;AAC3B,gBAAQ,QAAQ,GAAG,SAAS;AAE5B;AAAA;AAAA;AAAA;AAAA;;;ACzBZ;AAGA,IAAM,MAAM;AAmBL,4BAA4B,SAA8C,SAAqC;AACnH,QAAM,UAAU,IAAI;AACpB,QAAM,SAAS,qBACZ,WAAY,QAAO,YAAY,WAAW,EAAC,YAAW,YAAY,IAClE;AAGH,MAAI,CAAC,aAAa,OAAO,UAAU;AAChC,UAAM,IAAQ,kBAAkB,QAAQ;AAAA;AAG3C,MAAI,MAAM,QAAQ,OAAO,SAAS;AAC/B,YAAQ,IAAI,6BAA6B,OAAO;AAAA;AAGnD,UAAQ,IAAI,0BAA0B,OAAO;AAC7C,SAAO,YAAY,QAAQ,IAAI,sBAAsB,OAAO;AAC5D,SAAO,WAAW,QAAQ,IAAI,cAAc,OAAO;AACnD,SAAO,gBAAgB,QAAQ,IAAI,mBAAmB,OAAO;AAE7D,UAAQ,IAAI,qBAAqB,sBAAsB;AACvD,SAAO,UAAU,QAAQ,IAAI,qBAAqB,OAAO;AAEzD,SAAO,IAAI,IAAI,QAAQ;AAAA;;;ACxD1B;AAIA,IAAM,0BAA0B;AAAA,EAC7B;AAAA,EAAgB;AAAA,EAAO;AAAA,EAAiB;AAAA;AAG3C,IAAM,0BAA0B;AAAA,EAC7B;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA;AAGI,iBAAiB,MAAoG;AAEzH,MAAI;AAEJ,MAAI,QAAQ,QAAQ;AAEpB,MAAI;AACD,UAAM,mBAAmB,GAAG;AAAA,WACtB,GAAP;AACC,YAAQ,QAAQ,OAAO;AAAA;AAG1B,2BAAyB;AACtB,WAAO;AAAA;AAGV,yBAAuB;AACpB,WAAO;AAAA;AAGV,QAAM,aAAa,CAAC,GAAG,yBAAyB,GAAG,yBAAyB,OAAO,CAAC,KAAU,SAAiB;AAC5G,UAAM,UAAU,wBAAwB,SAAS;AAEjD,UAAM,QAAQ,UAAU,aAAa,MAAM,OAAO,YAAY,MAAM,KAAK;AACzE,UAAM,cAAc,UAAU,cAAc;AAE5C,WAAO,eAAe,KAAK,MAAM;AAAA,MAC9B,YAAY;AAAA,MACZ,cAAc;AAAA,MACd,OAAO,MAAM,QAAQ;AAAA;AAGxB,WAAO;AAAA,KACP;AAEH,SAAO;AAEP,wBAAsB,IAAY,MAA4C;AAC3E,WAAO,YAAa,OAAa;AAC9B,UAAI,OAAO,MAAK,MAAK,YAAY,YAAY;AAC1C,cAAM,IAAI,UACP,gHAC8C;AAAA;AAGpD,aAAO,MAAM,KAAK,WAAY;AAC3B,eAAO,IAAI,QAAQ,SAAU,SAAS,QAAQ;AAC3C,gBAAM,WAAkC,CAAC,KAAmB,WAAiB;AAC1E,gBAAI,KAAK;AACN,qBAAO,OAAO,QAAQ;AAAA;AAGzB,oBAAQ;AAAA;AAEX,gBAAK,KAAK;AAEV,eAAI,IAAI,MAAM,MAAK;AAAA;AAAA;AAAA;AAAA;AAM/B,uBAAqB,IAAY,MAAU,KAAgB;AACxD,WAAO,IAAI,UAAgB;AACxB,WAAI,IAAI,GAAG;AAEX,aAAO;AAAA;AAAA;AAAA;AAKhB,iBAAiB,OAAoC;AAElD,MAAI,iBAAiB,OAAO;AACzB,WAAO;AAAA;AAGV,MAAI,OAAO,UAAU,UAAU;AAC5B,WAAO,IAAI,MAAM;AAAA;AAGpB,SAAO,IAAI,iBAAiB;AAAA;;;ACnJxB,IAAM,YAAY;AAEzB,IAAO,cAAQ;",
+  "sources": ["../../src/lib/errors/git-error.ts", "../../src/lib/errors/git-response-error.ts", "../../src/lib/errors/task-configuration-error.ts", "../../src/lib/utils/util.ts", "../../src/lib/utils/argument-filters.ts", "../../src/lib/utils/exit-codes.ts", "../../src/lib/utils/git-output-streams.ts", "../../src/lib/utils/line-parser.ts", "../../src/lib/utils/simple-git-options.ts", "../../src/lib/utils/task-options.ts", "../../src/lib/utils/task-parser.ts", "../../src/lib/utils/index.ts", "../../src/lib/tasks/check-is-repo.ts", "../../src/lib/responses/CleanSummary.ts", "../../src/lib/tasks/task.ts", "../../src/lib/tasks/clean.ts", "../../src/lib/responses/ConfigList.ts", "../../src/lib/tasks/config.ts", "../../src/lib/tasks/grep.ts", "../../src/lib/tasks/reset.ts", "../../src/lib/git-logger.ts", "../../src/lib/runners/tasks-pending-queue.ts", "../../src/lib/runners/git-executor-chain.ts", "../../src/lib/runners/git-executor.ts", "../../src/lib/task-callback.ts", "../../src/lib/tasks/change-working-directory.ts", "../../src/lib/parsers/parse-commit.ts", "../../src/lib/tasks/commit.ts", "../../src/lib/tasks/hash-object.ts", "../../src/lib/responses/InitSummary.ts", "../../src/lib/tasks/init.ts", "../../src/lib/responses/DiffSummary.ts", "../../src/lib/parsers/parse-diff-summary.ts", "../../src/lib/parsers/parse-list-log-summary.ts", "../../src/lib/tasks/log.ts", "../../src/lib/responses/MergeSummary.ts", "../../src/lib/responses/PullSummary.ts", "../../src/lib/parsers/parse-remote-objects.ts", "../../src/lib/parsers/parse-remote-messages.ts", "../../src/lib/parsers/parse-pull.ts", "../../src/lib/parsers/parse-merge.ts", "../../src/lib/tasks/merge.ts", "../../src/lib/parsers/parse-push.ts", "../../src/lib/tasks/push.ts", "../../src/lib/responses/FileStatusSummary.ts", "../../src/lib/responses/StatusSummary.ts", "../../src/lib/tasks/status.ts", "../../src/lib/simple-git-api.ts", "../../src/lib/runners/scheduler.ts", "../../src/lib/tasks/apply-patch.ts", "../../src/lib/responses/BranchDeleteSummary.ts", "../../src/lib/parsers/parse-branch-delete.ts", "../../src/lib/responses/BranchSummary.ts", "../../src/lib/parsers/parse-branch.ts", "../../src/lib/tasks/branch.ts", "../../src/lib/responses/CheckIgnore.ts", "../../src/lib/tasks/check-ignore.ts", "../../src/lib/tasks/clone.ts", "../../src/lib/tasks/diff.ts", "../../src/lib/parsers/parse-fetch.ts", "../../src/lib/tasks/fetch.ts", "../../src/lib/parsers/parse-move.ts", "../../src/lib/tasks/move.ts", "../../src/lib/tasks/pull.ts", "../../src/lib/responses/GetRemoteSummary.ts", "../../src/lib/tasks/remote.ts", "../../src/lib/tasks/stash-list.ts", "../../src/lib/tasks/sub-module.ts", "../../src/lib/responses/TagList.ts", "../../src/lib/tasks/tag.ts", "../../src/git.js", "../../src/lib/errors/git-construct-error.ts", "../../src/lib/api.ts", "../../src/lib/errors/git-plugin-error.ts", "../../src/lib/plugins/command-config-prefixing-plugin.ts", "../../src/lib/plugins/completion-detection.plugin.ts", "../../src/lib/plugins/error-detection.plugin.ts", "../../src/lib/plugins/plugin-store.ts", "../../src/lib/plugins/progress-monitor-plugin.ts", "../../src/lib/plugins/spawn-options-plugin.ts", "../../src/lib/plugins/timout-plugin.ts", "../../src/lib/git-factory.ts", "../../src/lib/runners/promise-wrapped.ts", "../../src/esm.mjs"],
+  "sourcesContent": ["import { SimpleGitTask } from '../types';\n\n/**\n * The `GitError` is thrown when the underlying `git` process throws a\n * fatal exception (eg an `ENOENT` exception when attempting to use a\n * non-writable directory as the root for your repo), and acts as the\n * base class for more specific errors thrown by the parsing of the\n * git response or errors in the configuration of the task about to\n * be run.\n *\n * When an exception is thrown, pending tasks in the same instance will\n * not be executed. The recommended way to run a series of tasks that\n * can independently fail without needing to prevent future tasks from\n * running is to catch them individually:\n *\n * ```typescript\n import { gitP, SimpleGit, GitError, PullResult } from 'simple-git';\n\n function catchTask (e: GitError) {\n   return e.\n }\n\n const git = gitP(repoWorkingDir);\n const pulled: PullResult | GitError = await git.pull().catch(catchTask);\n const pushed: string | GitError = await git.pushTags().catch(catchTask);\n ```\n */\nexport class GitError extends Error {\n\n   constructor (\n      public task?: SimpleGitTask<any>,\n      message?: string,\n   ) {\n      super(message);\n      Object.setPrototypeOf(this, new.target.prototype);\n   }\n\n}\n", "import { GitError } from './git-error';\n\n/**\n * The `GitResponseError` is the wrapper for a parsed response that is treated as\n * a fatal error, for example attempting a `merge` can leave the repo in a corrupted\n * state when there are conflicts so the task will reject rather than resolve.\n *\n * For example, catching the merge conflict exception:\n *\n * ```typescript\n import { gitP, SimpleGit, GitResponseError, MergeSummary } from 'simple-git';\n\n const git = gitP(repoRoot);\n const mergeOptions: string[] = ['--no-ff', 'other-branch'];\n const mergeSummary: MergeSummary = await git.merge(mergeOptions)\n      .catch((e: GitResponseError<MergeSummary>) => e.git);\n\n if (mergeSummary.failed) {\n   // deal with the error\n }\n ```\n */\nexport class GitResponseError<T = any> extends GitError {\n\n   constructor(\n      /**\n       * `.git` access the parsed response that is treated as being an error\n       */\n      public readonly git: T,\n      message?: string,\n   ) {\n      super(undefined, message || String(git));\n   }\n\n}\n", "import { GitError } from './git-error';\n\n/**\n * The `TaskConfigurationError` is thrown when a command was incorrectly\n * configured. An error of this kind means that no attempt was made to\n * run your command through the underlying `git` binary.\n *\n * Check the `.message` property for more detail on why your configuration\n * resulted in an error.\n */\nexport class TaskConfigurationError extends GitError {\n\n   constructor (\n      message?: string,\n   ) {\n      super(undefined, message);\n   }\n\n}\n", "import { exists, FOLDER } from '@kwsites/file-exists';\nimport { Maybe } from '../types';\n\nexport const NULL = '\\0';\n\nexport const NOOP: (...args: any[]) => void = () => {\n};\n\n/**\n * Returns either the source argument when it is a `Function`, or the default\n * `NOOP` function constant\n */\nexport function asFunction<T extends () => any>(source: T | any): T {\n   return typeof source === 'function' ? source : NOOP;\n}\n\n/**\n * Determines whether the supplied argument is both a function, and is not\n * the `NOOP` function.\n */\nexport function isUserFunction<T extends Function>(source: T | any): source is T {\n   return (typeof source === 'function' && source !== NOOP);\n}\n\nexport function splitOn(input: string, char: string): [string, string] {\n   const index = input.indexOf(char);\n   if (index <= 0) {\n      return [input, ''];\n   }\n\n   return [\n      input.substr(0, index),\n      input.substr(index + 1),\n   ];\n}\n\nexport function first<T extends any[]>(input: T, offset?: number): Maybe<T[number]>;\nexport function first<T extends IArguments>(input: T, offset?: number): Maybe<unknown>;\nexport function first(input: any[] | IArguments, offset = 0): Maybe<unknown> {\n   return isArrayLike(input) && input.length > offset ? input[offset] : undefined;\n}\n\nexport function last<T extends any[]>(input: T, offset?: number): Maybe<T[number]>;\nexport function last<T extends IArguments>(input: T, offset?: number): Maybe<unknown>;\nexport function last<T>(input: T, offset?: number): Maybe<unknown>;\nexport function last(input: unknown, offset = 0) {\n   if (isArrayLike(input) && input.length > offset) {\n      return input[input.length - 1 - offset];\n   }\n}\n\ntype ArrayLike<T = any> = T[] | IArguments | { [index: number]: T; length: number };\n\nfunction isArrayLike(input: any): input is ArrayLike {\n   return !!(input && typeof input.length === 'number');\n}\n\nexport function toLinesWithContent(input = '', trimmed = true, separator = '\\n'): string[] {\n   return input.split(separator)\n      .reduce((output, line) => {\n         const lineContent = trimmed ? line.trim() : line;\n         if (lineContent) {\n            output.push(lineContent);\n         }\n         return output;\n      }, [] as string[]);\n}\n\ntype LineWithContentCallback<T = void> = (line: string) => T;\n\nexport function forEachLineWithContent<T>(input: string, callback: LineWithContentCallback<T>): T[] {\n   return toLinesWithContent(input, true).map(line => callback(line));\n}\n\nexport function folderExists(path: string): boolean {\n   return exists(path, FOLDER);\n}\n\n/**\n * Adds `item` into the `target` `Array` or `Set` when it is not already present and returns the `item`.\n */\nexport function append<T>(target: T[] | Set<T>, item: T): typeof item {\n   if (Array.isArray(target)) {\n      if (!target.includes(item)) {\n         target.push(item);\n      }\n   } else {\n      target.add(item);\n   }\n   return item;\n}\n\n/**\n * Adds `item` into the `target` `Array` when it is not already present and returns the `target`.\n */\nexport function including<T>(target: T[], item: T): typeof target {\n   if (Array.isArray(target) && !target.includes(item)) {\n      target.push(item);\n   }\n\n   return target;\n}\n\nexport function remove<T>(target: Set<T> | T[], item: T): T {\n   if (Array.isArray(target)) {\n      const index = target.indexOf(item);\n      if (index >= 0) {\n         target.splice(index, 1);\n      }\n   } else {\n      target.delete(item);\n   }\n   return item;\n}\n\nexport const objectToString = Object.prototype.toString.call.bind(Object.prototype.toString) as (input: any) => string;\n\nexport function asArray<T>(source: T | T[]): T[] {\n   return Array.isArray(source) ? source : [source];\n}\n\nexport function asStringArray<T>(source: T | T[]): string[] {\n   return asArray(source).map(String);\n}\n\nexport function asNumber(source: string | null | undefined, onNaN = 0) {\n   if (source == null) {\n      return onNaN;\n   }\n\n   const num = parseInt(source, 10);\n   return isNaN(num) ? onNaN : num;\n}\n\nexport function prefixedArray<T>(input: T[], prefix: T): T[] {\n   const output: T[] = [];\n   for (let i = 0, max = input.length; i < max; i++) {\n      output.push(prefix, input[i]);\n   }\n   return output;\n}\n\nexport function bufferToString(input: Buffer | Buffer[]): string {\n   return (Array.isArray(input) ? Buffer.concat(input) : input).toString('utf-8');\n}\n\n/**\n * Get a new object from a source object with only the listed properties.\n */\nexport function pick(source: Record<string, any>, properties: string[]) {\n   return Object.assign({}, ...properties.map((property) => property in source ? {[property]: source[property]} : {}));\n}\n\nexport function delay(duration = 0): Promise<void> {\n   return new Promise(done => setTimeout(done, duration));\n}\n", "import { Maybe, Options, Primitives } from '../types';\nimport { objectToString } from './util';\n\nexport interface ArgumentFilterPredicate<T> {\n   (input: any): input is T;\n}\n\nexport function filterType<T, K>(input: K, filter: ArgumentFilterPredicate<T>): K extends T ? T : undefined;\nexport function filterType<T, K>(input: K, filter: ArgumentFilterPredicate<T>, def: T): T;\nexport function filterType<T, K>(input: K, filter: ArgumentFilterPredicate<T>, def?: T): Maybe<T> {\n   if (filter(input)) {\n      return input;\n   }\n   return (arguments.length > 2) ? def : undefined\n}\n\nexport const filterArray: ArgumentFilterPredicate<Array<any>> = (input): input is Array<any> => {\n   return Array.isArray(input);\n}\n\nexport function filterPrimitives(input: unknown, omit?: Array<'boolean' | 'string' | 'number'>): input is Primitives {\n   return /number|string|boolean/.test(typeof input) && (!omit || !omit.includes((typeof input) as 'boolean' | 'string' | 'number'));\n}\n\nexport const filterString: ArgumentFilterPredicate<string> = (input): input is string => {\n   return typeof input === 'string';\n};\n\nexport const filterStringArray: ArgumentFilterPredicate<string[]> = (input): input is string[] => {\n   return Array.isArray(input) && input.every(filterString);\n};\n\nexport const filterStringOrStringArray: ArgumentFilterPredicate<string | string[]> = (input): input is string | string[] => {\n   return filterString(input) || (Array.isArray(input) && input.every(filterString));\n};\n\nexport function filterPlainObject<T extends Options>(input: T | unknown): input is T;\nexport function filterPlainObject<T extends Object>(input: T | unknown): input is T {\n   return !!input && objectToString(input) === '[object Object]';\n}\n\nexport function filterFunction(input: unknown): input is Function {\n   return typeof input === 'function';\n}\n\nexport const filterHasLength: ArgumentFilterPredicate<{ length: number }> = (input): input is { length: number } => {\n   if (input == null || 'number|boolean|function'.includes(typeof input)) {\n      return false;\n   }\n   return Array.isArray(input) || typeof input === 'string' || typeof input.length === 'number';\n}\n", "/**\n * Known process exit codes used by the task parsers to determine whether an error\n * was one they can automatically handle\n */\nexport enum ExitCodes {\n   SUCCESS,\n   ERROR,\n   UNCLEAN = 128,\n}\n", "import { TaskResponseFormat } from '../types';\n\nexport class GitOutputStreams<T extends TaskResponseFormat = Buffer> {\n\n   constructor(public readonly stdOut: T, public readonly stdErr: T) {\n   }\n\n   asStrings(): GitOutputStreams<string> {\n      return new GitOutputStreams(this.stdOut.toString('utf8'), this.stdErr.toString('utf8'));\n   }\n}\n", "export class LineParser<T> {\n\n   protected matches: string[] = [];\n\n   private _regExp: RegExp[];\n\n   constructor(\n      regExp: RegExp | RegExp[],\n      useMatches?: (target: T, match: string[]) => boolean | void,\n   ) {\n      this._regExp = Array.isArray(regExp) ? regExp : [regExp];\n      if (useMatches) {\n         this.useMatches = useMatches;\n      }\n   }\n\n   parse = (line: (offset: number) => (string | undefined), target: T): boolean => {\n      this.resetMatches();\n\n      if (!this._regExp.every((reg, index) => this.addMatch(reg, index, line(index)))) {\n         return false;\n      }\n\n      return this.useMatches(target, this.prepareMatches()) !== false;\n   }\n\n   // @ts-ignore\n   protected useMatches(target: T, match: string[]): boolean | void {\n      throw new Error(`LineParser:useMatches not implemented`);\n   }\n\n   protected resetMatches() {\n      this.matches.length = 0;\n   }\n\n   protected prepareMatches() {\n      return this.matches;\n   }\n\n   protected addMatch(reg: RegExp, index: number, line?: string) {\n      const matched = line && reg.exec(line);\n      if (matched) {\n         this.pushMatch(index, matched);\n      }\n\n      return !!matched;\n   }\n\n   protected pushMatch(_index: number, matched: string[]) {\n      this.matches.push(...matched.slice(1));\n   }\n\n}\n\nexport class RemoteLineParser<T> extends LineParser<T> {\n\n   protected addMatch(reg: RegExp, index: number, line?: string): boolean {\n      return /^remote:\\s/.test(String(line)) && super.addMatch(reg, index, line);\n   }\n\n   protected pushMatch(index: number, matched: string[]) {\n      if (index > 0 || matched.length > 1) {\n         super.pushMatch(index, matched);\n      }\n   }\n\n}\n", "import { SimpleGitOptions } from '../types';\n\nconst defaultOptions: Omit<SimpleGitOptions, 'baseDir'> = {\n   binary: 'git',\n   maxConcurrentProcesses: 5,\n   config: [],\n};\n\nexport function createInstanceConfig(...options: Array<Partial<SimpleGitOptions> | undefined>): SimpleGitOptions {\n   const baseDir = process.cwd();\n   const config: SimpleGitOptions = Object.assign({baseDir, ...defaultOptions},\n      ...(options.filter(o => typeof o === 'object' && o))\n   );\n\n   config.baseDir = config.baseDir || baseDir;\n\n   return config;\n}\n", "import { filterArray, filterFunction, filterPlainObject, filterPrimitives, filterType } from './argument-filters';\nimport { asFunction, isUserFunction, last } from './util';\nimport { Maybe, Options, OptionsValues } from '../types';\n\nexport function appendTaskOptions<T extends Options = Options>(options: Maybe<T>, commands: string[] = []): string[] {\n   if (!filterPlainObject<Options>(options)) {\n      return commands;\n   }\n\n   return Object.keys(options).reduce((commands: string[], key: string) => {\n      const value: OptionsValues = options[key];\n\n      if (filterPrimitives(value, ['boolean'])) {\n         commands.push(key + '=' + value);\n      } else {\n         commands.push(key);\n      }\n\n      return commands;\n   }, commands);\n}\n\nexport function getTrailingOptions(args: IArguments, initialPrimitive = 0, objectOnly = false): string[] {\n   const command: string[] = [];\n\n   for (let i = 0, max = initialPrimitive < 0 ? args.length : initialPrimitive; i < max; i++) {\n      if ('string|number'.includes(typeof args[i])) {\n         command.push(String(args[i]));\n      }\n   }\n\n   appendTaskOptions(trailingOptionsArgument(args), command);\n   if (!objectOnly) {\n      command.push(...trailingArrayArgument(args));\n   }\n\n   return command;\n}\n\nfunction trailingArrayArgument(args: IArguments) {\n   const hasTrailingCallback = typeof last(args) === 'function';\n   return filterType(\n      last(args, hasTrailingCallback ? 1 : 0), filterArray, []\n   );\n}\n\n/**\n * Given any number of arguments, returns the trailing options argument, ignoring a trailing function argument\n * if there is one. When not found, the return value is null.\n */\nexport function trailingOptionsArgument(args: IArguments): Maybe<Options> {\n   const hasTrailingCallback = filterFunction(last(args));\n   return filterType(last(args, hasTrailingCallback ? 1 : 0), filterPlainObject);\n}\n\n/**\n * Returns either the source argument when it is a `Function`, or the default\n * `NOOP` function constant\n */\nexport function trailingFunctionArgument(args: unknown[] | IArguments | unknown, includeNoop = true): Maybe<(...args: any[]) => unknown> {\n   const callback = asFunction(last(args));\n   return includeNoop || isUserFunction(callback) ? callback : undefined;\n}\n", "import { TaskParser, TaskResponseFormat } from '../types';\nimport { GitOutputStreams } from './git-output-streams';\nimport { LineParser } from './line-parser';\nimport { toLinesWithContent } from './util';\n\nexport function callTaskParser<INPUT extends TaskResponseFormat, RESPONSE>(parser: TaskParser<INPUT, RESPONSE>, streams: GitOutputStreams<INPUT>) {\n   return parser(streams.stdOut, streams.stdErr);\n}\n\nexport function parseStringResponse<T>(result: T, parsers: LineParser<T>[], ...texts: string[]): T {\n   texts.forEach(text => {\n      for (let lines = toLinesWithContent(text), i = 0, max = lines.length; i < max; i++) {\n         const line = (offset = 0) => {\n            if ((i + offset) >= max) {\n               return;\n            }\n            return lines[i + offset];\n         }\n\n         parsers.some(({parse}) => parse(line, result));\n      }\n   });\n\n   return result;\n}\n", "\nexport * from './argument-filters';\nexport * from './exit-codes';\nexport * from './git-output-streams';\nexport * from './line-parser';\nexport * from './simple-git-options';\nexport * from './task-options';\nexport * from './task-parser';\nexport * from './util';\n", "import { ExitCodes } from '../utils';\nimport { Maybe, StringTask } from '../types';\n\nexport enum CheckRepoActions {\n   BARE = 'bare',\n   IN_TREE = 'tree',\n   IS_REPO_ROOT = 'root',\n}\n\nconst onError: StringTask<boolean>['onError'] = ({exitCode}, error, done, fail) => {\n   if (exitCode === ExitCodes.UNCLEAN && isNotRepoMessage(error)) {\n      return done(Buffer.from('false'));\n   }\n\n   fail(error);\n}\n\nconst parser: StringTask<boolean>['parser'] = (text) => {\n   return text.trim() === 'true';\n}\n\nexport function checkIsRepoTask(action: Maybe<CheckRepoActions>): StringTask<boolean> {\n   switch (action) {\n      case CheckRepoActions.BARE:\n         return checkIsBareRepoTask();\n      case CheckRepoActions.IS_REPO_ROOT:\n         return checkIsRepoRootTask();\n   }\n\n   const commands = ['rev-parse', '--is-inside-work-tree'];\n\n   return {\n      commands,\n      format: 'utf-8',\n      onError,\n      parser,\n   }\n}\n\n\nexport function checkIsRepoRootTask(): StringTask<boolean> {\n   const commands = ['rev-parse', '--git-dir'];\n\n   return {\n      commands,\n      format: 'utf-8',\n      onError,\n      parser(path) {\n         return /^\\.(git)?$/.test(path.trim());\n      },\n   }\n}\n\n\nexport function checkIsBareRepoTask(): StringTask<boolean> {\n   const commands = ['rev-parse', '--is-bare-repository'];\n\n   return {\n      commands,\n      format: 'utf-8',\n      onError,\n      parser,\n   }\n}\n\n\nfunction isNotRepoMessage(error: Error): boolean {\n   return /(Not a git repository|Kein Git-Repository)/i.test(String(error));\n}\n", "import { CleanSummary } from '../../../typings';\nimport { toLinesWithContent } from '../utils';\n\nexport class CleanResponse implements CleanSummary {\n\n   public paths: string[] = [];\n   public files: string[] = [];\n   public folders: string[] = [];\n\n   constructor(\n      public readonly dryRun: boolean,\n   ) {}\n\n}\n\nconst removalRegexp = /^[a-z]+\\s*/i;\nconst dryRunRemovalRegexp = /^[a-z]+\\s+[a-z]+\\s*/i;\nconst isFolderRegexp = /\\/$/;\n\nexport function cleanSummaryParser (dryRun: boolean, text: string): CleanSummary {\n   const summary = new CleanResponse(dryRun);\n   const regexp = dryRun ? dryRunRemovalRegexp : removalRegexp;\n\n   toLinesWithContent(text).forEach(line => {\n      const removed = line.replace(regexp, '');\n\n      summary.paths.push(removed);\n      (isFolderRegexp.test(removed) ? summary.folders : summary.files).push(removed);\n   });\n\n   return summary;\n}\n", "import { TaskConfigurationError } from '../errors/task-configuration-error';\nimport { BufferTask, EmptyTaskParser, SimpleGitTask, StringTask } from '../types';\n\nexport const EMPTY_COMMANDS: [] = [];\n\nexport type EmptyTask = {\n   commands: typeof EMPTY_COMMANDS;\n   format: 'empty',\n   parser: EmptyTaskParser;\n   onError?: undefined;\n};\n\n\nexport function adhocExecTask(parser: EmptyTaskParser): EmptyTask {\n   return {\n      commands: EMPTY_COMMANDS,\n      format: 'empty',\n      parser,\n   };\n}\n\nexport function configurationErrorTask(error: Error | string): EmptyTask {\n   return {\n      commands: EMPTY_COMMANDS,\n      format: 'empty',\n      parser() {\n         throw typeof error === 'string' ? new TaskConfigurationError(error) : error;\n      }\n   }\n}\n\nexport function straightThroughStringTask(commands: string[], trimmed = false): StringTask<string> {\n   return {\n      commands,\n      format: 'utf-8',\n      parser(text) {\n         return trimmed ? String(text).trim() : text;\n      },\n   }\n}\n\nexport function straightThroughBufferTask(commands: string[]): BufferTask<any> {\n   return {\n      commands,\n      format: 'buffer',\n      parser(buffer) {\n         return buffer;\n      },\n   }\n}\n\nexport function isBufferTask<R>(task: SimpleGitTask<R>): task is BufferTask<R> {\n   return task.format === 'buffer';\n}\n\nexport function isEmptyTask<R>(task: SimpleGitTask<R>): task is EmptyTask {\n   return task.format === 'empty' || !task.commands.length;\n}\n", "import { CleanSummary } from '../../../typings';\nimport { cleanSummaryParser } from '../responses/CleanSummary';\nimport { Maybe, StringTask } from '../types';\nimport { asStringArray } from '../utils';\nimport { configurationErrorTask } from './task';\n\nexport const CONFIG_ERROR_INTERACTIVE_MODE = 'Git clean interactive mode is not supported';\nexport const CONFIG_ERROR_MODE_REQUIRED = 'Git clean mode parameter (\"n\" or \"f\") is required';\nexport const CONFIG_ERROR_UNKNOWN_OPTION = 'Git clean unknown option found in: ';\n\n/**\n * All supported option switches available for use in a `git.clean` operation\n */\nexport enum CleanOptions {\n   DRY_RUN = 'n',\n   FORCE = 'f',\n   IGNORED_INCLUDED = 'x',\n   IGNORED_ONLY = 'X',\n   EXCLUDING = 'e',\n   QUIET = 'q',\n   RECURSIVE = 'd',\n}\n\n/**\n * The two modes `git.clean` can run in - one of these must be supplied in order\n * for the command to not throw a `TaskConfigurationError`\n */\nexport type CleanMode = CleanOptions.FORCE | CleanOptions.DRY_RUN;\n\nconst CleanOptionValues: Set<string> = new Set(['i', ...asStringArray(Object.values(CleanOptions as any))]);\n\nexport function cleanWithOptionsTask(mode: CleanMode | string, customArgs: string[]) {\n   const {cleanMode, options, valid} = getCleanOptions(mode);\n\n   if (!cleanMode) {\n      return configurationErrorTask(CONFIG_ERROR_MODE_REQUIRED);\n   }\n\n   if (!valid.options) {\n      return configurationErrorTask(CONFIG_ERROR_UNKNOWN_OPTION + JSON.stringify(mode));\n   }\n\n   options.push(...customArgs);\n\n   if (options.some(isInteractiveMode)) {\n      return configurationErrorTask(CONFIG_ERROR_INTERACTIVE_MODE);\n   }\n\n   return cleanTask(cleanMode, options);\n}\n\nexport function cleanTask(mode: CleanMode, customArgs: string[]): StringTask<CleanSummary> {\n   const commands: string[] = ['clean', `-${mode}`, ...customArgs];\n\n   return {\n      commands,\n      format: 'utf-8',\n      parser(text: string): CleanSummary {\n         return cleanSummaryParser(mode === CleanOptions.DRY_RUN, text);\n      }\n   }\n}\n\nexport function isCleanOptionsArray (input: string[]): input is CleanOptions[] {\n   return Array.isArray(input) && input.every(test => CleanOptionValues.has(test));\n}\n\nfunction getCleanOptions(input: string) {\n   let cleanMode: Maybe<CleanMode>;\n   let options: string[] = [];\n   let valid = {cleanMode: false, options: true};\n\n   input.replace(/[^a-z]i/g, '').split('').forEach(char => {\n      if (isCleanMode(char)) {\n         cleanMode = char;\n         valid.cleanMode = true;\n      }\n      else {\n         valid.options = valid.options && isKnownOption(options[options.length] = (`-${char}`));\n      }\n   });\n\n   return {\n      cleanMode,\n      options,\n      valid,\n   }\n}\n\nfunction isCleanMode(cleanMode?: string): cleanMode is CleanMode {\n   return cleanMode === CleanOptions.FORCE || cleanMode === CleanOptions.DRY_RUN;\n}\n\nfunction isKnownOption(option: string): boolean {\n   return /^-[a-z]$/i.test(option) && CleanOptionValues.has(option.charAt(1));\n}\n\nfunction isInteractiveMode(option: string): boolean {\n   if (/^-[^\\-]/.test(option)) {\n      return option.indexOf('i') > 0;\n   }\n\n   return option === '--interactive';\n}\n", "import { ConfigGetResult, ConfigListSummary, ConfigValues } from '../../../typings';\nimport { last, splitOn } from '../utils';\n\nexport class ConfigList implements ConfigListSummary {\n\n   public files: string[] = [];\n   public values: { [fileName: string]: ConfigValues } = Object.create(null);\n\n   private _all: ConfigValues | undefined;\n\n   public get all(): ConfigValues {\n      if (!this._all) {\n         this._all = this.files.reduce((all: ConfigValues, file: string) => {\n            return Object.assign(all, this.values[file]);\n         }, {});\n      }\n\n      return this._all;\n   }\n\n   public addFile(file: string): ConfigValues {\n      if (!(file in this.values)) {\n         const latest = last(this.files);\n         this.values[file] = latest ? Object.create(this.values[latest]) : {}\n\n         this.files.push(file);\n      }\n\n      return this.values[file];\n   }\n\n   public addValue(file: string, key: string, value: string) {\n      const values = this.addFile(file);\n\n      if (!values.hasOwnProperty(key)) {\n         values[key] = value;\n      } else if (Array.isArray(values[key])) {\n         (values[key] as string[]).push(value);\n      } else {\n         values[key] = [values[key] as string, value];\n      }\n\n      this._all = undefined;\n   }\n\n}\n\nexport function configListParser(text: string): ConfigList {\n   const config = new ConfigList();\n\n   for (const item of configParser(text)) {\n      config.addValue(item.file, String(item.key), item.value);\n   }\n\n   return config;\n}\n\nexport function configGetParser(text: string, key: string): ConfigGetResult {\n   let value: string | null = null;\n   const values: string[] = [];\n   const scopes: Map<string, string[]> = new Map();\n\n   for (const item of configParser(text, key)) {\n      if (item.key !== key) {\n         continue;\n      }\n\n      values.push(value = item.value);\n\n      if (!scopes.has(item.file)) {\n         scopes.set(item.file, []);\n      }\n\n      scopes.get(item.file)!.push(value);\n   }\n\n   return {\n      key,\n      paths: Array.from(scopes.keys()),\n      scopes,\n      value,\n      values\n   };\n}\n\nfunction configFilePath(filePath: string): string {\n   return filePath.replace(/^(file):/, '');\n}\n\nfunction* configParser(text: string, requestedKey: string | null = null) {\n   const lines = text.split('\\0');\n\n   for (let i = 0, max = lines.length - 1; i < max;) {\n      const file = configFilePath(lines[i++]);\n\n      let value = lines[i++];\n      let key = requestedKey;\n\n      if (value.includes('\\n')) {\n         const line = splitOn(value, '\\n');\n         key = line[0];\n         value = line[1];\n      }\n\n      yield {file, key, value};\n   }\n}\n", "import { ConfigGetResult, ConfigListSummary, SimpleGit } from '../../../typings';\nimport { configGetParser, configListParser } from '../responses/ConfigList';\nimport { SimpleGitApi } from '../simple-git-api';\nimport { StringTask } from '../types';\nimport { trailingFunctionArgument } from '../utils';\n\nexport enum GitConfigScope {\n   system = 'system',\n   global = 'global',\n   local = 'local',\n   worktree = 'worktree',\n}\n\nfunction asConfigScope<T extends GitConfigScope | undefined>(scope: GitConfigScope | unknown, fallback: T): GitConfigScope | T {\n   if (typeof scope === 'string' && GitConfigScope.hasOwnProperty(scope)) {\n      return scope as GitConfigScope;\n   }\n   return fallback;\n}\n\nfunction addConfigTask(key: string, value: string, append: boolean, scope: GitConfigScope): StringTask<string> {\n   const commands: string[] = ['config', `--${scope}`];\n\n   if (append) {\n      commands.push('--add');\n   }\n\n   commands.push(key, value);\n\n   return {\n      commands,\n      format: 'utf-8',\n      parser(text: string): string {\n         return text;\n      }\n   }\n}\n\nfunction getConfigTask(key: string, scope?: GitConfigScope): StringTask<ConfigGetResult> {\n   const commands: string[] = ['config', '--null', '--show-origin', '--get-all', key];\n\n   if (scope) {\n      commands.splice(1, 0, `--${scope}`);\n   }\n\n   return {\n      commands,\n      format: 'utf-8',\n      parser(text) {\n         return configGetParser(text, key);\n      }\n   };\n}\n\nfunction listConfigTask(scope?: GitConfigScope): StringTask<ConfigListSummary> {\n   const commands = ['config', '--list', '--show-origin', '--null'];\n\n   if (scope) {\n      commands.push(`--${scope}`);\n   }\n\n   return {\n      commands,\n      format: 'utf-8',\n      parser(text: string) {\n         return configListParser(text);\n      },\n   }\n}\n\nexport default function (): Pick<SimpleGit, 'addConfig' | 'getConfig' | 'listConfig'> {\n   return {\n      addConfig(this: SimpleGitApi, key: string, value: string, ...rest: unknown[]) {\n         return this._runTask(\n            addConfigTask(key, value, rest[0] === true, asConfigScope(rest[1], GitConfigScope.local)),\n            trailingFunctionArgument(arguments),\n         );\n      },\n\n      getConfig(this: SimpleGitApi, key: string, scope?: GitConfigScope) {\n         return this._runTask(\n            getConfigTask(key, asConfigScope(scope, undefined)),\n            trailingFunctionArgument(arguments),\n         )\n      },\n\n      listConfig(this: SimpleGitApi, ...rest: unknown[]) {\n         return this._runTask(\n            listConfigTask(asConfigScope(rest[0], undefined)),\n            trailingFunctionArgument(arguments),\n         );\n      },\n   };\n}\n", "import { GrepResult, SimpleGit } from '../../../typings';\nimport { SimpleGitApi } from '../simple-git-api';\nimport {\n   asNumber,\n   forEachLineWithContent,\n   getTrailingOptions,\n   NULL,\n   prefixedArray,\n   trailingFunctionArgument\n} from '../utils';\n\nimport { configurationErrorTask } from './task';\n\nconst disallowedOptions = ['-h'];\n\nconst Query = Symbol('grepQuery');\n\nexport interface GitGrepQuery extends Iterable<string> {\n   /** Adds one or more terms to be grouped as an \"and\" to any other terms */\n   and(...and: string[]): this;\n\n   /** Adds one or more search terms - git.grep will \"or\" this to other terms */\n   param(...param: string[]): this;\n}\n\nclass GrepQuery implements GitGrepQuery {\n   private [Query]: string[] = [];\n\n   * [Symbol.iterator]() {\n      for (const query of this[Query]) {\n         yield query;\n      }\n   }\n\n   and(...and: string[]) {\n      and.length && this[Query].push('--and', '(', ...prefixedArray(and, '-e'), ')');\n      return this;\n   }\n\n   param(...param: string[]) {\n      this[Query].push(...prefixedArray(param, '-e'));\n      return this;\n   }\n}\n\n/**\n * Creates a new builder for a `git.grep` query with optional params\n */\nexport function grepQueryBuilder(...params: string[]): GitGrepQuery {\n   return new GrepQuery().param(...params);\n}\n\nfunction parseGrep(grep: string): GrepResult {\n   const paths: GrepResult['paths'] = new Set<string>();\n   const results: GrepResult['results'] = {};\n\n   forEachLineWithContent(grep, (input) => {\n      const [path, line, preview] = input.split(NULL);\n      paths.add(path);\n      (results[path] = results[path] || []).push({\n         line: asNumber(line),\n         path,\n         preview,\n      });\n   });\n\n   return {\n      paths,\n      results,\n   };\n}\n\nexport default function (): Pick<SimpleGit, 'grep'> {\n   return {\n      grep(this: SimpleGitApi, searchTerm: string | GitGrepQuery) {\n         const then = trailingFunctionArgument(arguments);\n         const options = getTrailingOptions(arguments);\n\n         for (const option of disallowedOptions) {\n            if (options.includes(option)) {\n               return this._runTask(\n                  configurationErrorTask(`git.grep: use of \"${option}\" is not supported.`),\n                  then,\n               );\n            }\n         }\n\n         if (typeof searchTerm === 'string') {\n            searchTerm = grepQueryBuilder().param(searchTerm);\n         }\n\n         const commands = ['grep', '--null', '-n', '--full-name', ...options, ...searchTerm];\n\n         return this._runTask({\n            commands,\n            format: 'utf-8',\n            parser(stdOut) {\n               return parseGrep(stdOut);\n            },\n         }, then);\n      }\n   }\n}\n", "import { straightThroughStringTask } from './task';\nimport { Maybe, OptionFlags, Options } from '../types';\n\nexport enum ResetMode {\n   MIXED = 'mixed',\n   SOFT = 'soft',\n   HARD = 'hard',\n   MERGE = 'merge',\n   KEEP = 'keep',\n}\n\nconst ResetModes = Array.from(Object.values(ResetMode));\n\nexport type ResetOptions = Options &\n   OptionFlags<'-q' | '--quiet' | '--no-quiet' | '--pathspec-from-nul'> &\n   OptionFlags<'--pathspec-from-file', string>;\n\nexport function resetTask(mode: Maybe<ResetMode>, customArgs: string[]) {\n   const commands: string[] = ['reset'];\n   if (isValidResetMode(mode)) {\n      commands.push(`--${mode}`);\n   }\n   commands.push(...customArgs);\n\n   return straightThroughStringTask(commands);\n}\n\nexport function getResetMode(mode: ResetMode | any): Maybe<ResetMode> {\n   if (isValidResetMode(mode)) {\n      return mode;\n   }\n\n   switch (typeof mode) {\n      case 'string':\n      case 'undefined':\n         return ResetMode.SOFT;\n   }\n\n   return;\n}\n\nfunction isValidResetMode(mode: ResetMode | any): mode is ResetMode {\n   return ResetModes.includes(mode);\n}\n", "import debug, { Debugger } from 'debug';\nimport { append, filterHasLength, filterString, filterType, NOOP, objectToString, remove } from './utils';\nimport { Maybe } from './types';\n\ndebug.formatters.L = (value: any) => String(filterHasLength(value) ? value.length : '-');\ndebug.formatters.B = (value: Buffer) => {\n   if (Buffer.isBuffer(value)) {\n      return value.toString('utf8');\n   }\n   return objectToString(value);\n}\n\ntype OutputLoggingHandler = (message: string, ...args: any[]) => void;\n\nfunction createLog () {\n   return debug('simple-git');\n}\n\nexport interface OutputLogger extends OutputLoggingHandler {\n   readonly label: string;\n\n   info: OutputLoggingHandler;\n   step (nextStep?: string): OutputLogger;\n   sibling (name: string): OutputLogger;\n}\n\nfunction prefixedLogger (to: Debugger, prefix: string, forward?: OutputLoggingHandler): OutputLoggingHandler {\n   if (!prefix || !String(prefix).replace(/\\s*/, '')) {\n      return !forward ? to : (message, ...args) => {\n         to(message, ...args);\n         forward(message, ...args);\n      };\n   }\n\n   return (message, ...args) => {\n      to(`%s ${message}`, prefix, ...args);\n      if (forward) {\n         forward(message, ...args);\n      }\n   };\n}\n\nfunction childLoggerName (name: Maybe<string>, childDebugger: Maybe<Debugger>, {namespace: parentNamespace}: Debugger): string {\n   if (typeof name === 'string') {\n      return name;\n   }\n   const childNamespace = childDebugger && childDebugger.namespace || '';\n\n   if (childNamespace.startsWith(parentNamespace)) {\n      return childNamespace.substr(parentNamespace.length + 1);\n   }\n\n   return childNamespace || parentNamespace;\n}\n\nexport function createLogger (label: string, verbose?: string | Debugger, initialStep?: string, infoDebugger = createLog()): OutputLogger {\n   const labelPrefix = label && `[${label}]` || '';\n\n   const spawned: OutputLogger[] = [];\n   const debugDebugger: Maybe<Debugger> = (typeof verbose === 'string') ? infoDebugger.extend(verbose) : verbose;\n   const key = childLoggerName(filterType(verbose, filterString), debugDebugger, infoDebugger);\n\n   return step(initialStep);\n\n   function sibling(name: string, initial?: string) {\n      return append(spawned, createLogger(label, key.replace(/^[^:]+/, name), initial, infoDebugger));\n   }\n\n   function step(phase?: string) {\n      const stepPrefix = phase && `[${phase}]` || '';\n      const debug = debugDebugger && prefixedLogger(debugDebugger, stepPrefix) || NOOP;\n      const info = prefixedLogger(infoDebugger, `${labelPrefix} ${ stepPrefix}`, debug);\n\n      return Object.assign(debugDebugger ? debug : info, {\n         label,\n         sibling,\n         info,\n         step,\n      });\n   }\n}\n\n/**\n * The `GitLogger` is used by the main `SimpleGit` runner to handle logging\n * any warnings or errors.\n */\nexport class GitLogger {\n\n   public error: OutputLoggingHandler;\n\n   public warn: OutputLoggingHandler\n\n   constructor(private _out: Debugger = createLog()) {\n      this.error = prefixedLogger(_out, '[ERROR]');\n      this.warn = prefixedLogger(_out, '[WARN]');\n   }\n\n   silent (silence = false) {\n      if (silence !== this._out.enabled) {\n         return;\n      }\n\n      const {namespace} = this._out;\n      const env = (process.env.DEBUG || '').split(',').filter(s => !!s);\n      const hasOn = env.includes(namespace);\n      const hasOff = env.includes(`-${namespace}`);\n\n      // enabling the log\n      if (!silence) {\n         if (hasOff) {\n            remove(env, `-${namespace}`);\n         }\n         else {\n            env.push(namespace);\n         }\n      }\n      else {\n         if (hasOn) {\n            remove(env, namespace);\n         }\n         else {\n            env.push(`-${namespace}`);\n         }\n      }\n\n      debug.enable(env.join(','));\n   }\n\n}\n", "import { SimpleGitTask } from '../types';\nimport { GitError } from '../errors/git-error';\nimport { createLogger, OutputLogger } from '../git-logger';\n\ntype AnySimpleGitTask = SimpleGitTask<any>;\n\ntype TaskInProgress = {\n   name: string;\n   logger: OutputLogger;\n   task: AnySimpleGitTask;\n}\n\nexport class TasksPendingQueue {\n\n   private _queue: Map<AnySimpleGitTask, TaskInProgress> = new Map();\n\n   constructor(private logLabel = 'GitExecutor') {\n   }\n\n   private withProgress(task: AnySimpleGitTask) {\n      return this._queue.get(task);\n   }\n\n   private createProgress (task: AnySimpleGitTask): TaskInProgress {\n      const name = TasksPendingQueue.getName(task.commands[0]);\n      const logger = createLogger(this.logLabel, name);\n\n      return {\n         task,\n         logger,\n         name,\n      };\n   }\n\n   push(task: AnySimpleGitTask): TaskInProgress {\n      const progress = this.createProgress(task);\n      progress.logger('Adding task to the queue, commands = %o', task.commands);\n\n      this._queue.set(task, progress);\n\n      return progress;\n   }\n\n   fatal(err: GitError) {\n      for (const [task, {logger}] of Array.from(this._queue.entries())) {\n         if (task === err.task) {\n            logger.info(`Failed %o`, err);\n            logger(`Fatal exception, any as-yet un-started tasks run through this executor will not be attempted`);\n         } else {\n            logger.info(`A fatal exception occurred in a previous task, the queue has been purged: %o`, err.message);\n         }\n\n         this.complete(task);\n      }\n\n      if (this._queue.size !== 0) {\n         throw new Error(`Queue size should be zero after fatal: ${this._queue.size}`);\n      }\n   }\n\n   complete(task: AnySimpleGitTask) {\n      const progress = this.withProgress(task);\n      if (progress) {\n         this._queue.delete(task);\n      }\n   }\n\n   attempt(task: AnySimpleGitTask): TaskInProgress {\n      const progress = this.withProgress(task);\n      if (!progress) {\n         throw new GitError(undefined, 'TasksPendingQueue: attempt called for an unknown task');\n      }\n      progress.logger('Starting task');\n\n      return progress;\n   }\n\n   static getName (name = 'empty') {\n      return `task:${name}:${++TasksPendingQueue.counter}`;\n   }\n\n   private static counter = 0;\n}\n", "import { spawn, SpawnOptions } from 'child_process';\nimport { GitError } from '../errors/git-error';\nimport { OutputLogger } from '../git-logger';\nimport { PluginStore } from '../plugins';\nimport { EmptyTask, isBufferTask, isEmptyTask, } from '../tasks/task';\nimport { GitExecutorResult, Maybe, outputHandler, RunnableTask, SimpleGitExecutor, SimpleGitTask } from '../types';\nimport { callTaskParser, first, GitOutputStreams, objectToString } from '../utils';\nimport { Scheduler } from './scheduler';\nimport { TasksPendingQueue } from './tasks-pending-queue';\n\nexport class GitExecutorChain implements SimpleGitExecutor {\n\n   private _chain: Promise<any> = Promise.resolve();\n   private _queue = new TasksPendingQueue();\n   private _cwd: string | undefined;\n\n   public get binary() {\n      return this._executor.binary;\n   }\n\n   public get cwd() {\n      return this._cwd || this._executor.cwd;\n   }\n\n   public set cwd(cwd: string) {\n      this._cwd = cwd;\n   }\n\n   public get env() {\n      return this._executor.env;\n   }\n\n   public get outputHandler() {\n      return this._executor.outputHandler;\n   }\n\n   constructor(\n      private _executor: SimpleGitExecutor,\n      private _scheduler: Scheduler,\n      private _plugins: PluginStore\n   ) {\n   }\n\n   public chain() {\n      return this;\n   }\n\n   public push<R>(task: SimpleGitTask<R>): Promise<R> {\n      this._queue.push(task);\n\n      return this._chain = this._chain.then(() => this.attemptTask(task));\n   }\n\n   private async attemptTask<R>(task: SimpleGitTask<R>): Promise<void | R> {\n      const onScheduleComplete = await this._scheduler.next();\n      const onQueueComplete = () => this._queue.complete(task);\n\n      try {\n         const {logger} = this._queue.attempt(task);\n         return await (isEmptyTask(task)\n               ? this.attemptEmptyTask(task, logger)\n               : this.attemptRemoteTask(task, logger)\n         ) as R;\n      } catch (e) {\n         throw this.onFatalException(task, e);\n      } finally {\n         onQueueComplete();\n         onScheduleComplete();\n      }\n   }\n\n   private onFatalException<R>(task: SimpleGitTask<R>, e: Error) {\n      const gitError = (e instanceof GitError) ? Object.assign(e, {task}) : new GitError(task, e && String(e));\n\n      this._chain = Promise.resolve();\n      this._queue.fatal(gitError);\n\n      return gitError;\n   }\n\n   private async attemptRemoteTask<R>(task: RunnableTask<R>, logger: OutputLogger) {\n      const args = this._plugins.exec('spawn.args', [...task.commands], pluginContext(task, task.commands));\n\n      const raw = await this.gitResponse(\n         task,\n         this.binary, args, this.outputHandler, logger.step('SPAWN'),\n      );\n      const outputStreams = await this.handleTaskData(task, args, raw, logger.step('HANDLE'));\n\n      logger(`passing response to task's parser as a %s`, task.format);\n\n      if (isBufferTask(task)) {\n         return callTaskParser(task.parser, outputStreams);\n      }\n\n      return callTaskParser(task.parser, outputStreams.asStrings());\n   }\n\n   private async attemptEmptyTask(task: EmptyTask, logger: OutputLogger) {\n      logger(`empty task bypassing child process to call to task's parser`);\n      return task.parser(this);\n   }\n\n   private handleTaskData<R>(\n      task: SimpleGitTask<R>,\n      args: string[],\n      result: GitExecutorResult, logger: OutputLogger): Promise<GitOutputStreams> {\n\n      const {exitCode, rejection, stdOut, stdErr} = result;\n\n      return new Promise((done, fail) => {\n         logger(`Preparing to handle process response exitCode=%d stdOut=`, exitCode);\n\n         const {error} = this._plugins.exec('task.error', {error: rejection}, {\n            ...pluginContext(task, args),\n            ...result,\n         });\n\n         if (error && task.onError) {\n            logger.info(`exitCode=%s handling with custom error handler`);\n\n            return task.onError(\n               result,\n               error,\n               (newStdOut) => {\n                  logger.info(`custom error handler treated as success`);\n                  logger(`custom error returned a %s`, objectToString(newStdOut));\n\n                  done(new GitOutputStreams(\n                     Array.isArray(newStdOut) ? Buffer.concat(newStdOut) : newStdOut,\n                     Buffer.concat(stdErr),\n                  ));\n               },\n               fail\n            );\n         }\n\n         if (error) {\n            logger.info(`handling as error: exitCode=%s stdErr=%s rejection=%o`, exitCode, stdErr.length, rejection);\n            return fail(error);\n         }\n\n         logger.info(`retrieving task output complete`);\n         done(new GitOutputStreams(\n            Buffer.concat(stdOut),\n            Buffer.concat(stdErr),\n         ));\n      });\n   }\n\n   private async gitResponse<R>(task: SimpleGitTask<R>, command: string, args: string[], outputHandler: Maybe<outputHandler>, logger: OutputLogger): Promise<GitExecutorResult> {\n      const outputLogger = logger.sibling('output');\n      const spawnOptions: SpawnOptions = this._plugins.exec('spawn.options', {\n         cwd: this.cwd,\n         env: this.env,\n         windowsHide: true,\n      }, pluginContext(task, task.commands));\n\n      return new Promise((done) => {\n         const stdOut: Buffer[] = [];\n         const stdErr: Buffer[] = [];\n\n         let rejection: Maybe<Error>;\n\n         logger.info(`%s %o`, command, args);\n         logger('%O', spawnOptions)\n         const spawned = spawn(command, args, spawnOptions);\n\n         spawned.stdout!.on('data', onDataReceived(stdOut, 'stdOut', logger, outputLogger.step('stdOut')));\n         spawned.stderr!.on('data', onDataReceived(stdErr, 'stdErr', logger, outputLogger.step('stdErr')));\n\n         spawned.on('error', onErrorReceived(stdErr, logger));\n\n         if (outputHandler) {\n            logger(`Passing child process stdOut/stdErr to custom outputHandler`);\n            outputHandler(command, spawned.stdout!, spawned.stderr!, [...args]);\n         }\n\n         this._plugins.exec('spawn.after', undefined, {\n            ...pluginContext(task, args),\n            spawned,\n            close(exitCode: number, reason?: Error) {\n               done({\n                  stdOut,\n                  stdErr,\n                  exitCode,\n                  rejection: rejection || reason,\n               });\n            },\n            kill(reason: Error) {\n               if (spawned.killed) {\n                  return;\n               }\n\n               rejection = reason;\n               spawned.kill('SIGINT');\n            },\n         });\n      });\n   }\n\n}\n\nfunction pluginContext<R>(task: SimpleGitTask<R>, commands: string[]) {\n   return {\n      method: first(task.commands) || '',\n      commands,\n   }\n}\n\nfunction onErrorReceived(target: Buffer[], logger: OutputLogger) {\n   return (err: Error) => {\n      logger(`[ERROR] child process exception %o`, err);\n      target.push(Buffer.from(String(err.stack), 'ascii'));\n   }\n}\n\nfunction onDataReceived(target: Buffer[], name: string, logger: OutputLogger, output: OutputLogger) {\n   return (buffer: Buffer) => {\n      logger(`%s received %L bytes`, name, buffer);\n      output(`%B`, buffer);\n      target.push(buffer)\n   }\n}\n", "import type { PluginStore } from '../plugins';\nimport type { GitExecutorEnv, outputHandler, SimpleGitExecutor, SimpleGitTask } from '../types';\n\nimport { GitExecutorChain } from './git-executor-chain';\nimport { Scheduler } from './scheduler';\n\nexport class GitExecutor implements SimpleGitExecutor {\n\n   private _chain = new GitExecutorChain(this, this._scheduler, this._plugins);\n\n   public env: GitExecutorEnv;\n   public outputHandler?: outputHandler;\n\n   constructor(\n      public binary: string = 'git',\n      public cwd: string,\n      private _scheduler: Scheduler,\n      private _plugins: PluginStore,\n   ) {\n   }\n\n   chain(): SimpleGitExecutor {\n      return new GitExecutorChain(this, this._scheduler, this._plugins);\n   }\n\n   push<R>(task: SimpleGitTask<R>): Promise<R> {\n      return this._chain.push(task);\n   }\n\n}\n\n\n", "import { GitError } from './errors/git-error';\nimport { GitResponseError } from './errors/git-response-error';\nimport { SimpleGitTask, SimpleGitTaskCallback } from './types';\nimport { NOOP } from './utils';\n\nexport function taskCallback<R>(task: SimpleGitTask<R>, response: Promise<R>, callback: SimpleGitTaskCallback<R> = NOOP) {\n\n   const onSuccess = (data: R) => {\n      callback(null, data);\n   };\n\n   const onError = (err: GitError | GitResponseError) => {\n      if (err?.task === task) {\n         callback((err instanceof GitResponseError) ? addDeprecationNoticeToError(err) : err, undefined as any);\n      }\n   };\n\n   response.then(onSuccess, onError);\n\n}\n\nfunction addDeprecationNoticeToError (err: GitResponseError) {\n   let log = (name: string) => {\n      console.warn(`simple-git deprecation notice: accessing GitResponseError.${name} should be GitResponseError.git.${name}, this will no longer be available in version 3`);\n      log = NOOP;\n   };\n\n   return Object.create(err, Object.getOwnPropertyNames(err.git).reduce(descriptorReducer, {}));\n\n   function descriptorReducer(all: PropertyDescriptorMap, name: string): typeof all {\n      if (name in err) {\n         return all;\n      }\n\n      all[name] = {\n         enumerable: false,\n         configurable: false,\n         get () {\n            log(name);\n            return err.git[name];\n         },\n      };\n\n      return all;\n   }\n}\n", "import { folderExists } from '../utils';\nimport { SimpleGitExecutor } from '../types';\nimport { adhocExecTask } from './task';\n\nexport function changeWorkingDirectoryTask (directory: string, root?: SimpleGitExecutor) {\n   return adhocExecTask((instance: SimpleGitExecutor) => {\n      if (!folderExists(directory)) {\n         throw new Error(`Git.cwd: cannot change to non-directory \"${ directory }\"`);\n      }\n\n      return ((root || instance).cwd = directory);\n   });\n}\n", "import { CommitResult } from '../../../typings';\nimport { LineParser, parseStringResponse } from '../utils';\n\nconst parsers: LineParser<CommitResult>[] = [\n   new LineParser(/^\\[([^\\s]+)( \\([^)]+\\))? ([^\\]]+)/, (result, [branch, root, commit]) => {\n      result.branch = branch;\n      result.commit = commit;\n      result.root = !!root;\n   }),\n   new LineParser(/\\s*Author:\\s(.+)/i, (result, [author]) => {\n      const parts = author.split('<');\n      const email = parts.pop();\n\n      if (!email || !email.includes('@')) {\n         return;\n      }\n\n      result.author = {\n         email: email.substr(0, email.length - 1),\n         name: parts.join('<').trim()\n      };\n   }),\n   new LineParser(/(\\d+)[^,]*(?:,\\s*(\\d+)[^,]*)(?:,\\s*(\\d+))/g, (result, [changes, insertions, deletions]) => {\n      result.summary.changes = parseInt(changes, 10) || 0;\n      result.summary.insertions = parseInt(insertions, 10) || 0;\n      result.summary.deletions = parseInt(deletions, 10) || 0;\n   }),\n   new LineParser(/^(\\d+)[^,]*(?:,\\s*(\\d+)[^(]+\\(([+-]))?/, (result, [changes, lines, direction]) => {\n      result.summary.changes = parseInt(changes, 10) || 0;\n      const count = parseInt(lines, 10) || 0;\n      if (direction === '-') {\n         result.summary.deletions = count;\n      } else if (direction === '+') {\n         result.summary.insertions = count;\n      }\n   }),\n];\n\nexport function parseCommitResult(stdOut: string): CommitResult {\n   const result: CommitResult = {\n      author: null,\n      branch: '',\n      commit: '',\n      root: false,\n      summary: {\n         changes: 0,\n         insertions: 0,\n         deletions: 0,\n      },\n   };\n   return parseStringResponse(result, parsers, stdOut);\n}\n", "import type { CommitResult, SimpleGit } from '../../../typings';\nimport type { SimpleGitApi } from '../simple-git-api';\nimport type { StringTask } from '../types';\nimport { parseCommitResult } from '../parsers/parse-commit';\nimport {\n   asArray,\n   filterArray,\n   filterStringOrStringArray,\n   filterType,\n   getTrailingOptions, prefixedArray,\n   trailingFunctionArgument\n} from '../utils';\nimport { configurationErrorTask } from './task';\n\nexport function commitTask(message: string[], files: string[], customArgs: string[]): StringTask<CommitResult> {\n   const commands: string[] = [\n      '-c',\n      'core.abbrev=40',\n      'commit',\n      ...prefixedArray(message, '-m'),\n      ...files,\n      ...customArgs,\n   ];\n\n   return {\n      commands,\n      format: 'utf-8',\n      parser: parseCommitResult,\n   };\n}\n\nexport default function (): Pick<SimpleGit, 'commit'> {\n   return {\n      commit(this: SimpleGitApi, message: string | string[], ...rest: unknown[]) {\n         const next = trailingFunctionArgument(arguments);\n         const task = rejectDeprecatedSignatures(message) ||\n            commitTask(\n               asArray(message),\n               asArray(filterType(rest[0], filterStringOrStringArray, [])),\n               [...filterType(rest[1], filterArray, []), ...getTrailingOptions(arguments, 0, true)]\n            );\n\n         return this._runTask(task, next);\n      },\n   };\n\n   function rejectDeprecatedSignatures(message?: unknown) {\n      return (\n         !filterStringOrStringArray(message) &&\n         configurationErrorTask(`git.commit: requires the commit message to be supplied as a string/string[]`)\n      );\n   }\n}\n", "import { straightThroughStringTask } from './task';\nimport { StringTask } from '../types';\n\n/**\n * Task used by `git.hashObject`\n */\nexport function hashObjectTask(filePath: string, write: boolean): StringTask<string> {\n   const commands = ['hash-object', filePath];\n   if (write) {\n      commands.push('-w');\n   }\n\n   return straightThroughStringTask(commands, true);\n}\n", "import { InitResult } from '../../../typings';\n\nexport class InitSummary implements InitResult {\n   constructor(\n      public readonly bare: boolean,\n      public readonly path: string,\n      public readonly existing: boolean,\n      public readonly gitDir: string,\n   ) {}\n}\n\nconst initResponseRegex = /^Init.+ repository in (.+)$/;\nconst reInitResponseRegex = /^Rein.+ in (.+)$/;\n\nexport function parseInit(bare: boolean, path: string, text: string) {\n   const response = String(text).trim();\n   let result;\n\n   if ((result = initResponseRegex.exec(response))) {\n      return new InitSummary(bare, path, false, result[1]);\n   }\n\n   if ((result = reInitResponseRegex.exec(response))) {\n      return new InitSummary(bare, path, true, result[1]);\n   }\n\n   let gitDir = '';\n   const tokens = response.split(' ');\n   while (tokens.length) {\n      const token = tokens.shift();\n      if (token === 'in') {\n         gitDir = tokens.join(' ');\n         break;\n      }\n   }\n\n   return new InitSummary(bare, path, /^re/i.test(response), gitDir);\n}\n", "import { InitResult } from '../../../typings';\nimport { parseInit } from '../responses/InitSummary';\nimport { StringTask } from '../types';\n\nconst bareCommand = '--bare';\n\nfunction hasBareCommand(command: string[]) {\n   return command.includes(bareCommand);\n}\n\nexport function initTask(bare = false, path: string, customArgs: string[]): StringTask<InitResult> {\n   const commands = ['init', ...customArgs];\n   if (bare && !hasBareCommand(commands)) {\n      commands.splice(1, 0, bareCommand);\n   }\n\n   return {\n      commands,\n      format: 'utf-8',\n      parser(text: string): InitResult {\n         return parseInit(commands.includes('--bare'), path, text);\n      }\n   }\n}\n", "import { DiffResult, DiffResultBinaryFile, DiffResultTextFile } from '../../../typings';\n\n/***\n * The DiffSummary is returned as a response to getting `git().status()`\n */\nexport class DiffSummary implements DiffResult {\n   changed = 0\n   deletions = 0;\n   insertions = 0;\n\n   files: Array<DiffResultTextFile | DiffResultBinaryFile> = [];\n}\n", "import { DiffResult } from '../../../typings';\nimport { DiffSummary } from '../responses/DiffSummary';\n\nexport function parseDiffResult(stdOut: string): DiffResult {\n   const lines = stdOut.trim().split('\\n');\n   const status = new DiffSummary();\n   readSummaryLine(status, lines.pop());\n\n   for (let i = 0, max = lines.length; i < max; i++) {\n      const line = lines[i];\n      textFileChange(line, status) || binaryFileChange(line, status);\n   }\n\n   return status;\n}\n\nfunction readSummaryLine(status: DiffResult, summary?: string) {\n   (summary || '')\n      .trim()\n      .split(', ')\n      .forEach(function (text: string) {\n         const summary = /(\\d+)\\s([a-z]+)/.exec(text);\n         if (!summary) {\n            return;\n         }\n\n         summaryType(status, summary[2], parseInt(summary[1], 10));\n      });\n}\n\nfunction summaryType (status: DiffResult, key: string, value: number) {\n   const match = (/([a-z]+?)s?\\b/.exec(key));\n   if (!match || !statusUpdate[match[1]]) {\n      return;\n   }\n\n   statusUpdate[match[1]](status, value);\n}\n\nconst statusUpdate: {[key: string]: (status: DiffResult, value: number) => void} = {\n   file (status, value) {\n      status.changed = value;\n   },\n   deletion (status, value) {\n      status.deletions = value;\n   },\n   insertion (status, value) {\n      status.insertions = value;\n   }\n}\n\nfunction textFileChange(input: string, {files}: DiffResult) {\n   const line = input.trim().match(/^(.+)\\s+\\|\\s+(\\d+)(\\s+[+\\-]+)?$/);\n\n   if (line) {\n      var alterations = (line[3] || '').trim();\n      files.push({\n         file: line[1].trim(),\n         changes: parseInt(line[2], 10),\n         insertions: alterations.replace(/-/g, '').length,\n         deletions: alterations.replace(/\\+/g, '').length,\n         binary: false\n      });\n\n      return true;\n   }\n\n   return false\n}\n\nfunction binaryFileChange(input: string, {files}: DiffResult) {\n   const line = input.match(/^(.+) \\|\\s+Bin ([0-9.]+) -> ([0-9.]+) ([a-z]+)$/);\n   if (line) {\n      files.push({\n         file: line[1].trim(),\n         before: +line[2],\n         after: +line[3],\n         binary: true\n      });\n      return true;\n   }\n   return false;\n}\n", "import { ListLogLine, LogResult } from '../../../typings';\nimport { toLinesWithContent } from '../utils';\nimport { parseDiffResult } from './parse-diff-summary';\n\nexport const START_BOUNDARY = '\u00F2\u00F2\u00F2\u00F2\u00F2\u00F2 ';\n\nexport const COMMIT_BOUNDARY = ' \u00F2\u00F2';\n\nexport const SPLITTER = ' \u00F2 ';\n\nconst defaultFieldNames = ['hash', 'date', 'message', 'refs', 'author_name', 'author_email'];\n\nfunction lineBuilder(tokens: string[], fields: string[]): any {\n   return fields.reduce((line, field, index) => {\n      line[field] = tokens[index] || '';\n      return line;\n   }, Object.create({diff: null}) as any);\n}\n\nexport function createListLogSummaryParser<T = any> (splitter = SPLITTER, fields = defaultFieldNames) {\n   return function (stdOut: string): LogResult<T> {\n      const all: ReadonlyArray<T & ListLogLine> = toLinesWithContent(stdOut, true, START_BOUNDARY)\n         .map(function (item) {\n            const lineDetail = item.trim().split(COMMIT_BOUNDARY);\n            const listLogLine: T & ListLogLine = lineBuilder(lineDetail[0].trim().split(splitter), fields);\n\n            if (lineDetail.length > 1 && !!lineDetail[1].trim()) {\n               listLogLine.diff = parseDiffResult(lineDetail[1]);\n            }\n\n            return listLogLine;\n         });\n\n      return {\n         all,\n         latest: all.length && all[0] || null,\n         total: all.length,\n      };\n   }\n}\n", "import { Options, StringTask } from '../types';\nimport { LogResult, SimpleGit } from '../../../typings';\nimport {\n   COMMIT_BOUNDARY,\n   createListLogSummaryParser,\n   SPLITTER,\n   START_BOUNDARY\n} from '../parsers/parse-list-log-summary';\nimport {\n   appendTaskOptions,\n   filterArray,\n   filterPrimitives,\n   filterString,\n   filterType,\n   trailingFunctionArgument,\n   trailingOptionsArgument\n} from '../utils';\nimport { SimpleGitApi } from '../simple-git-api';\nimport { configurationErrorTask } from './task';\n\nenum excludeOptions {\n   '--pretty',\n   'max-count',\n   'maxCount',\n   'n',\n   'file',\n   'format',\n   'from',\n   'to',\n   'splitter',\n   'symmetric',\n   'mailMap',\n   'multiLine',\n   'strictDate',\n}\n\nexport interface DefaultLogFields {\n   hash: string;\n   date: string;\n   message: string;\n   refs: string;\n   body: string;\n   author_name: string;\n   author_email: string;\n}\n\nexport type LogOptions<T = DefaultLogFields> = {\n   file?: string;\n   format?: T;\n   from?: string;\n   mailMap?: boolean;\n   maxCount?: number;\n   multiLine?: boolean;\n   splitter?: string;\n   strictDate?: boolean;\n   symmetric?: boolean;\n   to?: string;\n};\n\ninterface ParsedLogOptions {\n   fields: string[];\n   splitter: string;\n   commands: string[]\n}\n\nfunction prettyFormat(format: Record<string, string | unknown>, splitter: string): [string[], string] {\n   const fields: string[] = [];\n   const formatStr: string[] = [];\n\n   Object.keys(format).forEach((field) => {\n      fields.push(field);\n      formatStr.push(String(format[field]));\n   });\n\n   return [\n      fields, formatStr.join(splitter)\n   ];\n}\n\nfunction userOptions<T extends Options>(input: T): Options {\n   return Object.keys(input).reduce((out, key) => {\n      if (!(key in excludeOptions)) {\n         out[key] = input[key];\n      }\n      return out;\n   }, {} as Options);\n}\n\nexport function parseLogOptions<T extends Options>(opt: Options | LogOptions<T> = {}, customArgs: string[] = []): ParsedLogOptions {\n   const splitter = filterType(opt.splitter, filterString, SPLITTER);\n   const format = !filterPrimitives(opt.format) && opt.format ? opt.format : {\n      hash: '%H',\n      date: opt.strictDate === false ? '%ai' : '%aI',\n      message: '%s',\n      refs: '%D',\n      body: opt.multiLine ? '%B' : '%b',\n      author_name: opt.mailMap !== false ? '%aN' : '%an',\n      author_email: opt.mailMap !== false ? '%aE' : '%ae'\n   };\n\n   const [fields, formatStr] = prettyFormat(format, splitter);\n\n   const suffix: string[] = [];\n   const command: string[] = [\n      `--pretty=format:${START_BOUNDARY}${formatStr}${COMMIT_BOUNDARY}`,\n      ...customArgs,\n   ];\n\n   const maxCount: number | undefined = (opt as any).n || (opt as any)['max-count'] || opt.maxCount;\n   if (maxCount) {\n      command.push(`--max-count=${maxCount}`);\n   }\n\n   if (opt.from && opt.to) {\n      const rangeOperator = (opt.symmetric !== false) ? '...' : '..';\n      suffix.push(`${opt.from}${rangeOperator}${opt.to}`);\n   }\n\n   if (filterString(opt.file)) {\n      suffix.push('--follow', opt.file);\n   }\n\n   appendTaskOptions(userOptions(opt as Options), command);\n\n   return {\n      fields,\n      splitter,\n      commands: [\n         ...command,\n         ...suffix,\n      ],\n   };\n}\n\nexport function logTask<T>(splitter: string, fields: string[], customArgs: string[]): StringTask<LogResult<T>> {\n   return {\n      commands: ['log', ...customArgs],\n      format: 'utf-8',\n      parser: createListLogSummaryParser(splitter, fields),\n   };\n}\n\nexport default function (): Pick<SimpleGit, 'log'> {\n   return {\n      log<T extends Options>(this: SimpleGitApi, ...rest: unknown[]) {\n         const next = trailingFunctionArgument(arguments);\n         const task = rejectDeprecatedSignatures(...rest) ||\n            createLogTask(parseLogOptions<T>(trailingOptionsArgument(arguments), filterType(arguments[0], filterArray)))\n\n         return this._runTask(task, next);\n      }\n   }\n\n   function createLogTask(options: ParsedLogOptions) {\n      return logTask(options.splitter, options.fields, options.commands);\n   }\n\n   function rejectDeprecatedSignatures(from?: unknown, to?: unknown) {\n      return (\n         filterString(from) &&\n         filterString(to) &&\n         configurationErrorTask(`git.log(string, string) should be replaced with git.log({ from: string, to: string })`)\n      );\n   }\n}\n", "import { MergeConflict, MergeConflictDeletion, MergeDetail, MergeResultStatus } from '../../../typings';\n\nexport class MergeSummaryConflict implements MergeConflict {\n   constructor(\n      public readonly reason: string,\n      public readonly file: string | null = null,\n      public readonly meta?: MergeConflictDeletion,\n   ) {\n   }\n\n   toString() {\n      return `${this.file}:${this.reason}`;\n   }\n}\n\nexport class MergeSummaryDetail implements MergeDetail {\n   public conflicts: MergeConflict[] = [];\n   public merges: string[] = [];\n   public result: MergeResultStatus = 'success';\n\n   get failed() {\n      return this.conflicts.length > 0;\n   }\n\n   get reason() {\n      return this.result;\n   }\n\n   toString() {\n      if (this.conflicts.length) {\n         return `CONFLICTS: ${this.conflicts.join(', ')}`;\n      }\n\n      return 'OK';\n   }\n}\n\n", "import { PullDetailFileChanges, PullDetailSummary, PullFailedResult, PullResult } from '../../../typings';\n\nexport class PullSummary implements PullResult {\n   public remoteMessages = {\n      all: [],\n   };\n   public created = [];\n   public deleted: string[] = [];\n   public files: string[] = [];\n   public deletions: PullDetailFileChanges = {};\n   public insertions: PullDetailFileChanges = {};\n   public summary: PullDetailSummary = {\n      changes: 0,\n      deletions: 0,\n      insertions: 0,\n   };\n}\n\nexport class PullFailedSummary implements PullFailedResult {\n   remote = '';\n   hash = {\n      local: '',\n      remote: '',\n   };\n   branch = {\n      local: '',\n      remote: '',\n   };\n   message = '';\n\n   toString() {\n      return this.message;\n   }\n}\n\n", "import { RemoteMessageResult, RemoteMessages, RemoteMessagesObjectEnumeration } from '../../../typings';\nimport { asNumber, RemoteLineParser } from '../utils';\n\nfunction objectEnumerationResult<T extends RemoteMessages = RemoteMessages>(remoteMessages: T): RemoteMessagesObjectEnumeration {\n   return (remoteMessages.objects = remoteMessages.objects || {\n      compressing: 0,\n      counting: 0,\n      enumerating: 0,\n      packReused: 0,\n      reused: {count: 0, delta: 0},\n      total: {count: 0, delta: 0}\n   });\n}\n\nfunction asObjectCount(source: string) {\n   const count = /^\\s*(\\d+)/.exec(source);\n   const delta = /delta (\\d+)/i.exec(source);\n\n   return {\n      count: asNumber(count && count[1] || '0'),\n      delta: asNumber(delta && delta[1] || '0'),\n   };\n}\n\nexport const remoteMessagesObjectParsers: RemoteLineParser<RemoteMessageResult<RemoteMessages>>[] = [\n   new RemoteLineParser(/^remote:\\s*(enumerating|counting|compressing) objects: (\\d+),/i, (result, [action, count]) => {\n      const key = action.toLowerCase();\n      const enumeration = objectEnumerationResult(result.remoteMessages);\n\n      Object.assign(enumeration, {[key]: asNumber(count)});\n   }),\n   new RemoteLineParser(/^remote:\\s*(enumerating|counting|compressing) objects: \\d+% \\(\\d+\\/(\\d+)\\),/i, (result, [action, count]) => {\n      const key = action.toLowerCase();\n      const enumeration = objectEnumerationResult(result.remoteMessages);\n\n      Object.assign(enumeration, {[key]: asNumber(count)});\n   }),\n   new RemoteLineParser(/total ([^,]+), reused ([^,]+), pack-reused (\\d+)/i, (result, [total, reused, packReused]) => {\n      const objects = objectEnumerationResult(result.remoteMessages);\n      objects.total = asObjectCount(total);\n      objects.reused = asObjectCount(reused);\n      objects.packReused = asNumber(packReused);\n   }),\n];\n", "import { PushResultRemoteMessages, RemoteMessageResult, RemoteMessages } from '../../../typings';\nimport { asNumber, parseStringResponse, RemoteLineParser } from '../utils';\nimport { remoteMessagesObjectParsers } from './parse-remote-objects';\n\nconst parsers: RemoteLineParser<RemoteMessageResult<PushResultRemoteMessages | RemoteMessages>>[] = [\n   new RemoteLineParser(/^remote:\\s*(.+)$/, (result, [text]) => {\n      result.remoteMessages.all.push(text.trim());\n      return false;\n   }),\n   ...remoteMessagesObjectParsers,\n   new RemoteLineParser([/create a (?:pull|merge) request/i, /\\s(https?:\\/\\/\\S+)$/], (result, [pullRequestUrl]) => {\n      (result.remoteMessages as PushResultRemoteMessages).pullRequestUrl = pullRequestUrl;\n   }),\n   new RemoteLineParser([/found (\\d+) vulnerabilities.+\\(([^)]+)\\)/i, /\\s(https?:\\/\\/\\S+)$/], (result, [count, summary, url]) => {\n      (result.remoteMessages as PushResultRemoteMessages).vulnerabilities = {\n         count: asNumber(count),\n         summary,\n         url,\n      };\n   }),\n];\n\nexport function parseRemoteMessages<T extends RemoteMessages = RemoteMessages>(\n   _stdOut: string, stdErr: string,\n): RemoteMessageResult {\n   return parseStringResponse({remoteMessages: new RemoteMessageSummary() as T}, parsers, stdErr);\n}\n\nexport class RemoteMessageSummary implements RemoteMessages {\n   public readonly all: string[] = [];\n}\n", "import { PullDetail, PullFailedResult, PullResult, RemoteMessages } from '../../../typings';\nimport { PullFailedSummary, PullSummary } from '../responses/PullSummary';\nimport { TaskParser } from '../types';\nimport { append, LineParser, parseStringResponse } from '../utils';\nimport { parseRemoteMessages } from './parse-remote-messages';\n\nconst FILE_UPDATE_REGEX = /^\\s*(.+?)\\s+\\|\\s+\\d+\\s*(\\+*)(-*)/;\nconst SUMMARY_REGEX = /(\\d+)\\D+((\\d+)\\D+\\(\\+\\))?(\\D+(\\d+)\\D+\\(-\\))?/;\nconst ACTION_REGEX = /^(create|delete) mode \\d+ (.+)/;\n\nconst parsers: LineParser<PullResult>[] = [\n   new LineParser(FILE_UPDATE_REGEX, (result, [file, insertions, deletions]) => {\n      result.files.push(file);\n\n      if (insertions) {\n         result.insertions[file] = insertions.length;\n      }\n\n      if (deletions) {\n         result.deletions[file] = deletions.length;\n      }\n   }),\n   new LineParser(SUMMARY_REGEX, (result, [changes, , insertions, , deletions]) => {\n      if (insertions !== undefined || deletions !== undefined) {\n         result.summary.changes = +changes || 0;\n         result.summary.insertions = +insertions || 0;\n         result.summary.deletions = +deletions || 0;\n         return true;\n      }\n      return false;\n   }),\n   new LineParser(ACTION_REGEX, (result, [action, file]) => {\n      append(result.files, file);\n      append((action === 'create') ? result.created : result.deleted, file);\n   }),\n];\n\nconst errorParsers: LineParser<PullFailedResult>[] = [\n   new LineParser(/^from\\s(.+)$/i, (result, [remote]) => void (result.remote = remote)),\n   new LineParser(/^fatal:\\s(.+)$/, (result, [message]) => void (result.message = message)),\n   new LineParser(/([a-z0-9]+)\\.\\.([a-z0-9]+)\\s+(\\S+)\\s+->\\s+(\\S+)$/, (result, [hashLocal, hashRemote, branchLocal, branchRemote]) => {\n      result.branch.local = branchLocal;\n      result.hash.local = hashLocal;\n      result.branch.remote = branchRemote;\n      result.hash.remote = hashRemote;\n   }),\n];\n\nexport const parsePullDetail: TaskParser<string, PullDetail> = (stdOut, stdErr) => {\n   return parseStringResponse(new PullSummary(), parsers, stdOut, stdErr);\n}\n\nexport const parsePullResult: TaskParser<string, PullResult> = (stdOut, stdErr) => {\n   return Object.assign(\n      new PullSummary(),\n      parsePullDetail(stdOut, stdErr),\n      parseRemoteMessages<RemoteMessages>(stdOut, stdErr),\n   );\n}\n\nexport function parsePullErrorResult(stdOut: string, stdErr: string) {\n   const pullError = parseStringResponse(new PullFailedSummary(), errorParsers, stdOut, stdErr);\n\n   return pullError.message && pullError;\n}\n", "import { MergeDetail, MergeResult } from '../../../typings';\nimport { MergeSummaryConflict, MergeSummaryDetail } from '../responses/MergeSummary';\nimport { TaskParser } from '../types';\nimport { LineParser, parseStringResponse } from '../utils';\nimport { parsePullResult } from './parse-pull';\n\nconst parsers: LineParser<MergeDetail>[] = [\n   new LineParser(/^Auto-merging\\s+(.+)$/, (summary, [autoMerge]) => {\n      summary.merges.push(autoMerge);\n   }),\n   new LineParser(/^CONFLICT\\s+\\((.+)\\): Merge conflict in (.+)$/, (summary, [reason, file]) => {\n      summary.conflicts.push(new MergeSummaryConflict(reason, file));\n   }),\n   new LineParser(/^CONFLICT\\s+\\((.+\\/delete)\\): (.+) deleted in (.+) and/, (summary, [reason, file, deleteRef]) => {\n      summary.conflicts.push(new MergeSummaryConflict(reason, file, {deleteRef}));\n   }),\n   new LineParser(/^CONFLICT\\s+\\((.+)\\):/, (summary, [reason]) => {\n      summary.conflicts.push(new MergeSummaryConflict(reason, null));\n   }),\n   new LineParser(/^Automatic merge failed;\\s+(.+)$/, (summary, [result]) => {\n      summary.result = result;\n   }),\n];\n\n/**\n * Parse the complete response from `git.merge`\n */\nexport const parseMergeResult: TaskParser<string, MergeResult> = (stdOut, stdErr) => {\n   return Object.assign(\n      parseMergeDetail(stdOut, stdErr),\n      parsePullResult(stdOut, stdErr),\n   );\n};\n\n/**\n * Parse the merge specific detail (ie: not the content also available in the pull detail) from `git.mnerge`\n * @param stdOut\n */\nexport const parseMergeDetail: TaskParser<string, MergeDetail> = (stdOut) => {\n   return parseStringResponse(new MergeSummaryDetail(), parsers, stdOut);\n}\n", "import { MergeResult } from '../../../typings';\nimport { GitResponseError } from '../errors/git-response-error';\nimport { parseMergeResult } from '../parsers/parse-merge';\nimport { StringTask } from '../types';\nimport { configurationErrorTask, EmptyTask } from './task';\n\nexport function mergeTask(customArgs: string[]): EmptyTask | StringTask<MergeResult> {\n   if (!customArgs.length) {\n      return configurationErrorTask('Git.merge requires at least one option');\n   }\n\n   return {\n      commands: ['merge', ...customArgs],\n      format: 'utf-8',\n      parser(stdOut, stdErr): MergeResult {\n         const merge = parseMergeResult(stdOut, stdErr);\n         if (merge.failed) {\n            throw new GitResponseError(merge);\n         }\n\n         return merge;\n      }\n   }\n}\n", "import { PushDetail, PushResult, PushResultPushedItem, PushResultRemoteMessages } from '../../../typings';\nimport { TaskParser } from '../types';\nimport { LineParser, parseStringResponse } from '../utils';\nimport { parseRemoteMessages } from './parse-remote-messages';\n\nfunction pushResultPushedItem(local: string, remote: string, status: string): PushResultPushedItem {\n   const deleted = status.includes('deleted');\n   const tag = status.includes('tag') || /^refs\\/tags/.test(local);\n   const alreadyUpdated = !status.includes('new');\n\n   return {\n      deleted,\n      tag,\n      branch: !tag,\n      new: !alreadyUpdated,\n      alreadyUpdated,\n      local,\n      remote,\n   };\n}\n\nconst parsers: LineParser<PushDetail>[] = [\n   new LineParser(/^Pushing to (.+)$/, (result, [repo]) => {\n      result.repo = repo;\n   }),\n   new LineParser(/^updating local tracking ref '(.+)'/, (result, [local]) => {\n      result.ref = {\n         ...(result.ref || {}),\n         local,\n      }\n   }),\n   new LineParser(/^[*-=]\\s+([^:]+):(\\S+)\\s+\\[(.+)]$/, (result, [local, remote, type]) => {\n      result.pushed.push(pushResultPushedItem(local, remote, type));\n   }),\n   new LineParser(/^Branch '([^']+)' set up to track remote branch '([^']+)' from '([^']+)'/, (result, [local, remote, remoteName]) => {\n      result.branch = {\n         ...(result.branch || {}),\n         local,\n         remote,\n         remoteName,\n      };\n   }),\n   new LineParser(/^([^:]+):(\\S+)\\s+([a-z0-9]+)\\.\\.([a-z0-9]+)$/, (result, [local, remote, from, to]) => {\n      result.update = {\n         head: {\n            local,\n            remote,\n         },\n         hash: {\n            from,\n            to,\n         },\n      };\n   }),\n];\n\nexport const parsePushResult: TaskParser<string, PushResult> = (stdOut, stdErr) => {\n   const pushDetail = parsePushDetail(stdOut, stdErr);\n   const responseDetail = parseRemoteMessages<PushResultRemoteMessages>(stdOut, stdErr);\n\n   return {\n      ...pushDetail,\n      ...responseDetail,\n   };\n}\n\nexport const parsePushDetail: TaskParser<string, PushDetail> = (stdOut, stdErr) => {\n   return parseStringResponse({pushed: []}, parsers, stdOut, stdErr);\n}\n", "import { PushResult } from '../../../typings';\nimport { parsePushResult as parser } from '../parsers/parse-push';\nimport { StringTask } from '../types';\nimport { append, remove } from '../utils';\n\ntype PushRef = { remote?: string, branch?: string };\n\nexport function pushTagsTask(ref: PushRef = {}, customArgs: string[]): StringTask<PushResult> {\n   append(customArgs, '--tags');\n   return pushTask(ref, customArgs);\n}\n\nexport function pushTask(ref: PushRef = {}, customArgs: string[]): StringTask<PushResult> {\n   const commands = ['push', ...customArgs];\n   if (ref.branch) {\n      commands.splice(1, 0, ref.branch);\n   }\n   if (ref.remote) {\n      commands.splice(1, 0, ref.remote);\n   }\n\n   remove(commands, '-v');\n   append(commands, '--verbose');\n   append(commands, '--porcelain');\n\n   return {\n      commands,\n      format: 'utf-8',\n      parser,\n   };\n}\n", "import { FileStatusResult } from '../../../typings';\n\nexport const fromPathRegex = /^(.+) -> (.+)$/;\n\nexport class FileStatusSummary implements FileStatusResult {\n\n   public readonly from: string | undefined;\n\n   constructor (\n      public path: string,\n      public index: string,\n      public working_dir: string) {\n\n      if ('R' === (index + working_dir)) {\n         const detail = fromPathRegex.exec(path) || [null, path, path];\n         this.from = detail[1] || '';\n         this.path = detail[2] || '';\n      }\n   }\n}\n", "import { StatusResult } from '../../../typings';\nimport { append, NULL } from '../utils';\nimport { FileStatusSummary } from './FileStatusSummary';\n\ntype StatusLineParser = (result: StatusResult, file: string) => void;\n\nexport class StatusSummary implements StatusResult {\n   public not_added = [];\n   public conflicted = [];\n   public created = [];\n   public deleted = [];\n   public ignored = undefined;\n   public modified = [];\n   public renamed = [];\n   public files = [];\n   public staged = [];\n   public ahead = 0;\n   public behind = 0;\n   public current = null;\n   public tracking = null;\n   public detached = false;\n\n   public isClean = () => {\n      return !this.files.length;\n   }\n}\n\nenum PorcelainFileStatus {\n   ADDED = 'A',\n   DELETED = 'D',\n   MODIFIED = 'M',\n   RENAMED = 'R',\n   COPIED = 'C',\n   UNMERGED = 'U',\n   UNTRACKED = '?',\n   IGNORED = '!',\n   NONE = ' ',\n}\n\nfunction renamedFile(line: string) {\n   const [to, from] = line.split(NULL);\n\n   return {\n      from: from || to,\n      to,\n   };\n}\n\nfunction parser(indexX: PorcelainFileStatus, indexY: PorcelainFileStatus, handler: StatusLineParser): [string, StatusLineParser] {\n   return [`${indexX}${indexY}`, handler];\n}\n\nfunction conflicts(indexX: PorcelainFileStatus, ...indexY: PorcelainFileStatus[]) {\n   return indexY.map(y => parser(indexX, y, (result, file) => append(result.conflicted, file)));\n}\n\nconst parsers: Map<string, StatusLineParser> = new Map([\n   parser(PorcelainFileStatus.NONE, PorcelainFileStatus.ADDED, (result, file) => append(result.created, file)),\n   parser(PorcelainFileStatus.NONE, PorcelainFileStatus.DELETED, (result, file) => append(result.deleted, file)),\n   parser(PorcelainFileStatus.NONE, PorcelainFileStatus.MODIFIED, (result, file) => append(result.modified, file)),\n\n   parser(PorcelainFileStatus.ADDED, PorcelainFileStatus.NONE, (result, file) => append(result.created, file) && append(result.staged, file)),\n   parser(PorcelainFileStatus.ADDED, PorcelainFileStatus.MODIFIED, (result, file) =>\n      append(result.created, file) && append(result.staged, file) && append(result.modified, file)),\n\n   parser(PorcelainFileStatus.DELETED, PorcelainFileStatus.NONE, (result, file) => append(result.deleted, file) && append(result.staged, file)),\n\n   parser(PorcelainFileStatus.MODIFIED, PorcelainFileStatus.NONE, (result, file) => append(result.modified, file) && append(result.staged, file)),\n   parser(PorcelainFileStatus.MODIFIED, PorcelainFileStatus.MODIFIED, (result, file) => append(result.modified, file) && append(result.staged, file)),\n\n   parser(PorcelainFileStatus.RENAMED, PorcelainFileStatus.NONE, (result, file) => {\n      append(result.renamed, renamedFile(file));\n   }),\n   parser(PorcelainFileStatus.RENAMED, PorcelainFileStatus.MODIFIED, (result, file) => {\n      const renamed = renamedFile(file);\n      append(result.renamed, renamed);\n      append(result.modified, renamed.to);\n   }),\n   parser(PorcelainFileStatus.IGNORED, PorcelainFileStatus.IGNORED, (_result, _file) => {\n      append((_result.ignored = _result.ignored || []), _file);\n   }),\n\n   parser(PorcelainFileStatus.UNTRACKED, PorcelainFileStatus.UNTRACKED, (result, file) => append(result.not_added, file)),\n\n   ...conflicts(PorcelainFileStatus.ADDED, PorcelainFileStatus.ADDED, PorcelainFileStatus.UNMERGED),\n   ...conflicts(PorcelainFileStatus.DELETED, PorcelainFileStatus.DELETED, PorcelainFileStatus.UNMERGED),\n   ...conflicts(PorcelainFileStatus.UNMERGED, PorcelainFileStatus.ADDED, PorcelainFileStatus.DELETED, PorcelainFileStatus.UNMERGED),\n\n   ['##', (result, line) => {\n      const aheadReg = /ahead (\\d+)/;\n      const behindReg = /behind (\\d+)/;\n      const currentReg = /^(.+?(?=(?:\\.{3}|\\s|$)))/;\n      const trackingReg = /\\.{3}(\\S*)/;\n      const onEmptyBranchReg = /\\son\\s([\\S]+)$/;\n      let regexResult;\n\n      regexResult = aheadReg.exec(line);\n      result.ahead = regexResult && +regexResult[1] || 0;\n\n      regexResult = behindReg.exec(line);\n      result.behind = regexResult && +regexResult[1] || 0;\n\n      regexResult = currentReg.exec(line);\n      result.current = regexResult && regexResult[1];\n\n      regexResult = trackingReg.exec(line);\n      result.tracking = regexResult && regexResult[1];\n\n      regexResult = onEmptyBranchReg.exec(line);\n      result.current = regexResult && regexResult[1] || result.current;\n\n      result.detached = /\\(no branch\\)/.test(line);\n   }]\n]);\n\nexport const parseStatusSummary = function (text: string): StatusResult {\n   const lines = text.split(NULL);\n   const status = new StatusSummary();\n\n   for (let i = 0, l = lines.length; i < l;) {\n      let line = lines[i++].trim();\n\n      if (!line) {\n         continue;\n      }\n\n      if (line.charAt(0) === PorcelainFileStatus.RENAMED) {\n         line += NULL + (lines[i++] || '');\n      }\n\n      splitLine(status, line);\n   }\n\n   return status;\n};\n\nfunction splitLine(result: StatusResult, lineStr: string) {\n   const trimmed = lineStr.trim();\n   switch (' ') {\n      case trimmed.charAt(2):\n         return data(trimmed.charAt(0), trimmed.charAt(1), trimmed.substr(3));\n      case trimmed.charAt(1):\n         return data(PorcelainFileStatus.NONE, trimmed.charAt(0), trimmed.substr(2));\n      default:\n         return;\n   }\n\n   function data(index: string, workingDir: string, path: string) {\n      const raw = `${index}${workingDir}`;\n      const handler = parsers.get(raw);\n\n      if (handler) {\n         handler(result, path);\n      }\n\n      if (raw !== '##' && raw !== '!!') {\n         result.files.push(new FileStatusSummary(path.replace(/\\0.+$/, ''), index, workingDir));\n      }\n   }\n}\n", "import { StatusResult } from '../../../typings';\nimport { parseStatusSummary } from '../responses/StatusSummary';\nimport { StringTask } from '../types';\n\nconst ignoredOptions = ['--null', '-z'];\n\nexport function statusTask(customArgs: string[]): StringTask<StatusResult> {\n   const commands = [\n      'status',\n      '--porcelain',\n      '-b',\n      '-u',\n      '--null',\n      ...customArgs.filter(arg => !ignoredOptions.includes(arg))\n   ];\n\n   return {\n      format: 'utf-8',\n      commands,\n      parser(text: string) {\n         return parseStatusSummary(text);\n      }\n   }\n}\n", "import { SimpleGitBase } from '../../typings';\nimport { taskCallback } from './task-callback';\nimport { changeWorkingDirectoryTask } from './tasks/change-working-directory';\nimport commit from './tasks/commit';\nimport config from './tasks/config';\nimport grep from './tasks/grep';\nimport { hashObjectTask } from './tasks/hash-object';\nimport { initTask } from './tasks/init';\nimport log from './tasks/log';\nimport { mergeTask } from './tasks/merge';\nimport { pushTask } from './tasks/push';\nimport { statusTask } from './tasks/status';\nimport { configurationErrorTask, straightThroughStringTask } from './tasks/task';\nimport { outputHandler, SimpleGitExecutor, SimpleGitTask, SimpleGitTaskCallback } from './types';\nimport { asArray, filterString, filterType, getTrailingOptions, trailingFunctionArgument } from './utils';\n\nexport class SimpleGitApi implements SimpleGitBase {\n\n   constructor(private _executor: SimpleGitExecutor) {\n   }\n\n   protected _runTask<T>(task: SimpleGitTask<T>, then?: SimpleGitTaskCallback<T>) {\n      const chain = this._executor.chain();\n      const promise = chain.push(task);\n\n      if (then) {\n         taskCallback(task, promise, then);\n      }\n\n      return Object.create(this, {\n         then: {value: promise.then.bind(promise)},\n         catch: {value: promise.catch.bind(promise)},\n         _executor: {value: chain},\n      });\n   }\n\n   add(files: string | string[]) {\n      return this._runTask(\n         straightThroughStringTask(['add', ...asArray(files)]),\n         trailingFunctionArgument(arguments),\n      );\n   }\n\n   cwd(directory: string | { path: string, root?: boolean }) {\n      const next = trailingFunctionArgument(arguments);\n\n      if (typeof directory === 'string') {\n         return this._runTask(changeWorkingDirectoryTask(directory, this._executor), next);\n      }\n\n      if (typeof directory?.path === 'string') {\n         return this._runTask(changeWorkingDirectoryTask(directory.path, directory.root && this._executor || undefined), next);\n      }\n\n      return this._runTask(\n         configurationErrorTask('Git.cwd: workingDirectory must be supplied as a string'),\n         next\n      );\n   }\n\n   hashObject(path: string, write: boolean | unknown) {\n      return this._runTask(\n         hashObjectTask(path, write === true),\n         trailingFunctionArgument(arguments),\n      );\n   }\n\n   init(bare?: boolean | unknown) {\n      return this._runTask(\n         initTask(bare === true, this._executor.cwd, getTrailingOptions(arguments)),\n         trailingFunctionArgument(arguments),\n      );\n   }\n\n   merge() {\n      return this._runTask(\n         mergeTask(getTrailingOptions(arguments)),\n         trailingFunctionArgument(arguments),\n      );\n   }\n\n   mergeFromTo(remote: string, branch: string) {\n      if (!(filterString(remote) && filterString(branch))) {\n         return this._runTask(configurationErrorTask(\n            `Git.mergeFromTo requires that the 'remote' and 'branch' arguments are supplied as strings`\n         ));\n      }\n\n      return this._runTask(\n         mergeTask([remote, branch, ...getTrailingOptions(arguments)]),\n         trailingFunctionArgument(arguments, false),\n      );\n   }\n\n   outputHandler(handler: outputHandler) {\n      this._executor.outputHandler = handler;\n      return this;\n   }\n\n   push() {\n      const task = pushTask(\n         {\n            remote: filterType(arguments[0], filterString),\n            branch: filterType(arguments[1], filterString),\n         },\n         getTrailingOptions(arguments),\n      );\n\n      return this._runTask(\n         task,\n         trailingFunctionArgument(arguments),\n      );\n   }\n\n   stash() {\n      return this._runTask(\n         straightThroughStringTask(['stash', ...getTrailingOptions(arguments)]),\n         trailingFunctionArgument(arguments),\n      );\n   }\n\n   status() {\n      return this._runTask(statusTask(getTrailingOptions(arguments)), trailingFunctionArgument(arguments));\n   }\n}\n\nObject.assign(SimpleGitApi.prototype, commit(), config(), grep(), log());\n", "import { append, remove } from '../utils';\nimport { createDeferred, DeferredPromise } from '@kwsites/promise-deferred';\nimport { createLogger } from '../git-logger';\n\ntype ScheduleCompleteCallback = () => void;\ntype ScheduledTask = Pick<DeferredPromise<ScheduleCompleteCallback>, 'promise' | 'done'> & {id: number};\n\nconst createScheduledTask: () => ScheduledTask = (() => {\n   let id = 0;\n   return () => {\n      id++;\n      const {promise, done} = createDeferred<ScheduleCompleteCallback>();\n\n      return {\n         promise,\n         done,\n         id,\n      };\n   }\n})();\n\nexport class Scheduler {\n   private logger = createLogger('', 'scheduler');\n   private pending: ScheduledTask[] = [];\n   private running: ScheduledTask[] = [];\n\n   constructor(private concurrency = 2) {\n      this.logger(`Constructed, concurrency=%s`, concurrency);\n   }\n\n   private schedule() {\n      if (!this.pending.length || this.running.length >= this.concurrency) {\n         this.logger(`Schedule attempt ignored, pending=%s running=%s concurrency=%s`, this.pending.length, this.running.length, this.concurrency);\n         return;\n      }\n\n      const task = append(this.running, this.pending.shift()!);\n      this.logger(`Attempting id=%s`, task.id);\n      task.done(() => {\n         this.logger(`Completing id=`, task.id);\n         remove(this.running, task);\n         this.schedule();\n      });\n   }\n\n   next(): Promise<ScheduleCompleteCallback> {\n      const {promise, id} = append(this.pending, createScheduledTask());\n      this.logger(`Scheduling id=%s`, id);\n\n      this.schedule();\n\n      return promise;\n   }\n}\n", "import { straightThroughStringTask } from './task';\nimport { OptionFlags, Options, StringTask } from '../types';\n\nexport type ApplyOptions = Options &\n   OptionFlags<\n      | '--stat'\n      | '--numstat'\n      | '--summary'\n      | '--check'\n      | '--index'\n      | '--intent-to-add'\n      | '--3way'\n      | '--apply'\n      | '--no-add'\n      | '-R'\n      | '--reverse'\n      | '--allow-binary-replacement'\n      | '--binary'\n      | '--reject'\n      | '-z'\n      | '--inaccurate-eof'\n      | '--recount'\n      | '--cached'\n      | '--ignore-space-change'\n      | '--ignore-whitespace'\n      | '--verbose'\n      | '--unsafe-paths'> &\n   OptionFlags<\n      '--whitespace',\n      'nowarn' | 'warn' | 'fix' | 'error' | 'error-all'> &\n   OptionFlags<'--build-fake-ancestor' | '--exclude' | '--include' | '--directory',\n      string> &\n   OptionFlags<'-p' | '-C', number>;\n\nexport function applyPatchTask(patches: string[], customArgs: string[]): StringTask<string> {\n   return straightThroughStringTask(['apply', ...customArgs, ...patches]);\n}\n", "import {\n   BranchMultiDeleteResult,\n   BranchSingleDeleteFailure,\n   BranchSingleDeleteResult,\n   BranchSingleDeleteSuccess\n} from '../../../typings';\n\nexport class BranchDeletionBatch implements BranchMultiDeleteResult {\n   all: BranchSingleDeleteResult[] = [];\n   branches: { [branchName: string]: BranchSingleDeleteResult } = {};\n   errors: BranchSingleDeleteResult[] = [];\n\n   get success(): boolean {\n      return !this.errors.length;\n   }\n}\n\nexport function branchDeletionSuccess (branch: string, hash: string): BranchSingleDeleteSuccess {\n   return {\n      branch, hash, success: true,\n   };\n}\n\nexport function branchDeletionFailure (branch: string): BranchSingleDeleteFailure {\n   return {\n      branch, hash: null, success: false,\n   };\n}\n\nexport function isSingleBranchDeleteFailure (test: BranchSingleDeleteResult): test is BranchSingleDeleteSuccess {\n   return test.success;\n}\n", "import { BranchMultiDeleteResult } from '../../../typings';\nimport { BranchDeletionBatch, branchDeletionFailure, branchDeletionSuccess } from '../responses/BranchDeleteSummary';\nimport { TaskParser } from '../types';\nimport { ExitCodes, LineParser, parseStringResponse } from '../utils';\n\nconst deleteSuccessRegex = /(\\S+)\\s+\\(\\S+\\s([^)]+)\\)/;\nconst deleteErrorRegex = /^error[^']+'([^']+)'/m;\n\nconst parsers: LineParser<BranchMultiDeleteResult>[] = [\n   new LineParser(deleteSuccessRegex, (result, [branch, hash]) => {\n      const deletion = branchDeletionSuccess(branch, hash);\n\n      result.all.push(deletion);\n      result.branches[branch] = deletion;\n   }),\n   new LineParser(deleteErrorRegex, (result, [branch]) => {\n      const deletion = branchDeletionFailure(branch);\n\n      result.errors.push(deletion);\n      result.all.push(deletion);\n      result.branches[branch] = deletion;\n   }),\n];\n\nexport const parseBranchDeletions: TaskParser<string, BranchMultiDeleteResult> = (stdOut, stdErr) => {\n   return parseStringResponse(new BranchDeletionBatch(), parsers, stdOut, stdErr);\n}\n\nexport function hasBranchDeletionError(data: string, processExitCode: ExitCodes): boolean {\n   return processExitCode === ExitCodes.ERROR && deleteErrorRegex.test(data);\n}\n", "import { BranchSummary, BranchSummaryBranch } from '../../../typings';\n\nexport class BranchSummaryResult implements BranchSummary {\n   public all: string[] = [];\n   public branches: { [p: string]: BranchSummaryBranch } = {};\n   public current: string = '';\n   public detached: boolean = false;\n\n   push(current: boolean, detached: boolean, name: string, commit: string, label: string) {\n      if (current) {\n         this.detached = detached;\n         this.current = name;\n      }\n\n      this.all.push(name);\n      this.branches[name] = {\n         current: current,\n         name: name,\n         commit: commit,\n         label: label\n      };\n   }\n}\n\n", "import { BranchSummary } from '../../../typings';\nimport { BranchSummaryResult } from '../responses/BranchSummary';\nimport { LineParser, parseStringResponse } from '../utils';\n\nconst parsers: LineParser<BranchSummaryResult>[] = [\n   new LineParser(/^(\\*\\s)?\\((?:HEAD )?detached (?:from|at) (\\S+)\\)\\s+([a-z0-9]+)\\s(.*)$/, (result, [current, name, commit, label]) => {\n      result.push(\n         !!current,\n         true,\n         name, commit, label\n      );\n   }),\n   new LineParser(/^(\\*\\s)?(\\S+)\\s+([a-z0-9]+)\\s?(.*)$/s, (result, [current, name, commit, label]) => {\n      result.push(\n         !!current,\n         false,\n         name, commit, label\n      );\n   })\n];\n\nexport function parseBranchSummary (stdOut: string): BranchSummary {\n   return parseStringResponse(new BranchSummaryResult(), parsers, stdOut);\n}\n", "import { BranchMultiDeleteResult, BranchSingleDeleteResult, BranchSummary } from '../../../typings';\nimport { StringTask } from '../types';\nimport { GitResponseError } from '../errors/git-response-error';\nimport { hasBranchDeletionError, parseBranchDeletions } from '../parsers/parse-branch-delete';\nimport { parseBranchSummary } from '../parsers/parse-branch';\nimport { bufferToString } from '../utils';\n\nexport function containsDeleteBranchCommand(commands: string[]) {\n   const deleteCommands = ['-d', '-D', '--delete'];\n   return commands.some(command => deleteCommands.includes(command));\n}\n\nexport function branchTask(customArgs: string[]): StringTask<BranchSummary | BranchSingleDeleteResult> {\n   const isDelete = containsDeleteBranchCommand(customArgs);\n   const commands = ['branch', ...customArgs];\n\n   if (commands.length === 1) {\n      commands.push('-a');\n   }\n\n   if (!commands.includes('-v')) {\n      commands.splice(1, 0, '-v');\n   }\n\n   return {\n      format: 'utf-8',\n      commands,\n      parser(stdOut, stdErr) {\n         if (isDelete) {\n            return parseBranchDeletions(stdOut, stdErr).all[0];\n         }\n\n         return parseBranchSummary(stdOut);\n      },\n   }\n}\n\nexport function branchLocalTask(): StringTask<BranchSummary> {\n   const parser = parseBranchSummary;\n\n   return {\n      format: 'utf-8',\n      commands: ['branch', '-v'],\n      parser,\n   }\n}\n\nexport function deleteBranchesTask(branches: string[], forceDelete = false): StringTask<BranchMultiDeleteResult> {\n   return {\n      format: 'utf-8',\n      commands: ['branch', '-v', forceDelete ? '-D' : '-d', ...branches],\n      parser(stdOut, stdErr) {\n         return parseBranchDeletions(stdOut, stdErr);\n      },\n      onError({exitCode, stdOut}, error, done, fail) {\n         if (!hasBranchDeletionError(String(error), exitCode)) {\n            return fail(error);\n         }\n\n         done(stdOut);\n      },\n   }\n}\n\nexport function deleteBranchTask(branch: string, forceDelete = false): StringTask<BranchSingleDeleteResult> {\n   const task: StringTask<BranchSingleDeleteResult> = {\n      format: 'utf-8',\n      commands: ['branch', '-v', forceDelete ? '-D' : '-d', branch],\n      parser(stdOut, stdErr) {\n         return parseBranchDeletions(stdOut, stdErr).branches[branch]!;\n      },\n      onError({exitCode, stdErr, stdOut}, error, _, fail) {\n         if (!hasBranchDeletionError(String(error), exitCode)) {\n            return fail(error);\n         }\n\n         throw new GitResponseError(\n            task.parser(bufferToString(stdOut), bufferToString(stdErr)),\n            String(error)\n         );\n      },\n   };\n\n   return task;\n}\n", "\n/**\n * Parser for the `check-ignore` command - returns each file as a string array\n */\nexport const parseCheckIgnore = (text: string): string[] => {\n   return text.split(/\\n/g)\n      .map(line => line.trim())\n      .filter(file => !!file);\n};\n", "import { StringTask } from '../types';\nimport { parseCheckIgnore } from '../responses/CheckIgnore';\n\nexport function checkIgnoreTask(paths: string[]): StringTask<string[]> {\n   return {\n      commands: ['check-ignore', ...paths],\n      format: 'utf-8',\n      parser: parseCheckIgnore,\n   };\n}\n", "import { configurationErrorTask, EmptyTask, straightThroughStringTask } from './task';\nimport { OptionFlags, Options, StringTask } from '../types';\nimport { append, filterString } from '../utils';\n\nexport type CloneOptions = Options &\n   OptionFlags<'--bare' |\n      '--dissociate' |\n      '--mirror' |\n      '--no-checkout' |\n      '--no-remote-submodules' |\n      '--no-shallow-submodules' |\n      '--no-single-branch' |\n      '--no-tags' |\n      '--remote-submodules' |\n      '--single-branch' |\n      '--shallow-submodules' |\n      '--verbose'> &\n   OptionFlags<'--depth' | '-j' | '--jobs', number> &\n   OptionFlags<'--branch' | '--origin' | '--recurse-submodules' | '--separate-git-dir' | '--shallow-exclude' | '--shallow-since' | '--template', string>\n\nfunction disallowedCommand(command: string) {\n   return /^--upload-pack(=|$)/.test(command);\n}\n\nexport function cloneTask(repo: string | undefined, directory: string | undefined, customArgs: string[]): StringTask<string> | EmptyTask {\n   const commands = ['clone', ...customArgs];\n\n   filterString(repo) && commands.push(repo);\n   filterString(directory) && commands.push(directory);\n\n   const banned = commands.find(disallowedCommand);\n   if (banned) {\n      return configurationErrorTask(`git.fetch: potential exploit argument blocked.`);\n   }\n\n   return straightThroughStringTask(commands);\n}\n\nexport function cloneMirrorTask(repo: string | undefined, directory: string | undefined, customArgs: string[]) {\n   append(customArgs, '--mirror');\n\n   return cloneTask(repo, directory, customArgs);\n}\n", "import { StringTask } from '../types';\nimport { DiffResult } from '../../../typings';\nimport { parseDiffResult } from '../parsers/parse-diff-summary';\n\nexport function diffSummaryTask(customArgs: string[]): StringTask<DiffResult> {\n   return {\n      commands: ['diff', '--stat=4096', ...customArgs],\n      format: 'utf-8',\n      parser (stdOut) {\n         return parseDiffResult(stdOut);\n      }\n   }\n}\n", "import { FetchResult } from '../../../typings';\nimport { LineParser, parseStringResponse } from '../utils';\n\nconst parsers: LineParser<FetchResult>[] = [\n   new LineParser(/From (.+)$/, (result, [remote]) => {\n      result.remote = remote;\n   }),\n   new LineParser(/\\* \\[new branch]\\s+(\\S+)\\s*-> (.+)$/, (result, [name, tracking]) =>{\n      result.branches.push({\n         name,\n         tracking,\n      });\n   }),\n   new LineParser(/\\* \\[new tag]\\s+(\\S+)\\s*-> (.+)$/, (result, [name, tracking]) => {\n      result.tags.push({\n         name,\n         tracking,\n      });\n   })\n];\n\nexport function parseFetchResult (stdOut: string, stdErr: string): FetchResult {\n   const result: FetchResult = {\n      raw: stdOut,\n      remote: null,\n      branches: [],\n      tags: [],\n   };\n   return parseStringResponse(result, parsers, stdOut, stdErr);\n}\n", "import { FetchResult } from '../../../typings';\nimport { parseFetchResult } from '../parsers/parse-fetch';\nimport { StringTask } from '../types';\n\nimport { configurationErrorTask, EmptyTask } from './task';\n\nfunction disallowedCommand(command: string) {\n   return /^--upload-pack(=|$)/.test(command);\n}\n\nexport function fetchTask(remote: string, branch: string, customArgs: string[]): StringTask<FetchResult> | EmptyTask {\n   const commands = ['fetch', ...customArgs];\n   if (remote && branch) {\n      commands.push(remote, branch);\n   }\n\n   const banned = commands.find(disallowedCommand);\n   if (banned) {\n      return configurationErrorTask(`git.fetch: potential exploit argument blocked.`);\n   }\n\n   return {\n      commands,\n      format: 'utf-8',\n      parser: parseFetchResult,\n   }\n}\n", "import { MoveResult } from '../../../typings';\nimport { LineParser, parseStringResponse } from '../utils';\n\nconst parsers: LineParser<MoveResult>[] = [\n   new LineParser(/^Renaming (.+) to (.+)$/, (result, [from, to]) => {\n      result.moves.push({from, to});\n   }),\n];\n\nexport function parseMoveResult (stdOut: string): MoveResult {\n   return parseStringResponse({moves: []}, parsers, stdOut);\n}\n", "import { MoveResult } from '../../../typings';\nimport { parseMoveResult } from '../parsers/parse-move';\nimport { StringTask } from '../types';\nimport { asArray } from '../utils';\n\nexport function moveTask(from: string | string[], to: string): StringTask<MoveResult> {\n   return {\n      commands: ['mv', '-v', ...asArray(from), to],\n      format: 'utf-8',\n      parser: parseMoveResult,\n   };\n}\n", "import { PullResult } from '../../../typings';\nimport { GitResponseError } from '../errors/git-response-error';\nimport { parsePullErrorResult, parsePullResult } from '../parsers/parse-pull';\nimport { Maybe, StringTask } from '../types';\nimport { bufferToString } from '../utils';\n\nexport function pullTask(remote: Maybe<string>, branch: Maybe<string>, customArgs: string[]): StringTask<PullResult> {\n   const commands: string[] = ['pull', ...customArgs];\n   if (remote && branch) {\n      commands.splice(1, 0, remote, branch);\n   }\n\n   return {\n      commands,\n      format: 'utf-8',\n      parser(stdOut, stdErr): PullResult {\n         return parsePullResult(stdOut, stdErr);\n      },\n      onError(result, _error, _done, fail) {\n         const pullError = parsePullErrorResult(bufferToString(result.stdOut), bufferToString(result.stdErr));\n         if (pullError) {\n            return fail(new GitResponseError(pullError));\n         }\n\n         fail(_error);\n      }\n   }\n}\n", "import { forEachLineWithContent } from '../utils';\n\nexport interface RemoteWithoutRefs {\n   name: string;\n}\n\nexport interface RemoteWithRefs extends RemoteWithoutRefs {\n   refs: {\n      fetch: string;\n      push: string;\n   };\n}\n\nexport function parseGetRemotes (text: string): RemoteWithoutRefs[] {\n   const remotes: {[name: string]: RemoteWithoutRefs} = {};\n\n   forEach(text, ([name]) => remotes[name] = { name });\n\n   return Object.values(remotes);\n}\n\nexport function parseGetRemotesVerbose (text: string): RemoteWithRefs[] {\n   const remotes: {[name: string]: RemoteWithRefs} = {};\n\n   forEach(text, ([name, url, purpose]) => {\n      if (!remotes.hasOwnProperty(name)) {\n         remotes[name] = {\n            name: name,\n            refs: { fetch: '', push: '' },\n         };\n      }\n\n      if (purpose && url) {\n         remotes[name].refs[purpose.replace(/[^a-z]/g, '') as keyof RemoteWithRefs['refs']] = url;\n      }\n   });\n\n   return Object.values(remotes);\n}\n\nfunction forEach(text: string, handler: (line: string[]) => void) {\n   forEachLineWithContent(text, (line) => handler(line.split(/\\s+/)));\n}\n", "import { parseGetRemotes, parseGetRemotesVerbose } from '../responses/GetRemoteSummary';\nimport { StringTask } from '../types';\nimport { straightThroughStringTask } from './task';\n\nexport function addRemoteTask(remoteName: string, remoteRepo: string, customArgs: string[] = []): StringTask<string> {\n   return straightThroughStringTask(['remote', 'add', ...customArgs, remoteName, remoteRepo]);\n}\n\nexport function getRemotesTask(verbose: boolean): StringTask<any> {\n   const commands = ['remote'];\n   if (verbose) {\n      commands.push('-v');\n   }\n\n   return {\n      commands,\n      format: 'utf-8',\n      parser: verbose ? parseGetRemotesVerbose : parseGetRemotes,\n   };\n}\n\nexport function listRemotesTask(customArgs: string[] = []): StringTask<string> {\n   const commands = [...customArgs];\n   if (commands[0] !== 'ls-remote') {\n      commands.unshift('ls-remote');\n   }\n\n   return straightThroughStringTask(commands);\n}\n\nexport function remoteTask(customArgs: string[] = []): StringTask<string> {\n   const commands = [...customArgs];\n   if (commands[0] !== 'remote') {\n      commands.unshift('remote');\n   }\n\n   return straightThroughStringTask(commands);\n}\n\nexport function removeRemoteTask(remoteName: string) {\n   return straightThroughStringTask(['remote', 'remove', remoteName]);\n}\n", "import { LogOptions, LogResult } from '../../../typings';\nimport { createListLogSummaryParser } from '../parsers/parse-list-log-summary';\nimport { StringTask } from '../types';\nimport { parseLogOptions } from './log';\n\nexport function stashListTask(opt: LogOptions = {}, customArgs: string[]): StringTask<LogResult> {\n   const options = parseLogOptions<any>(opt);\n   const parser = createListLogSummaryParser(options.splitter, options.fields);\n\n   return {\n      commands: ['stash', 'list', ...options.commands, ...customArgs],\n      format: 'utf-8',\n      parser,\n   };\n}\n", "import { StringTask } from '../types';\nimport { straightThroughStringTask } from './task';\n\nexport function addSubModuleTask(repo: string, path: string): StringTask<string> {\n   return subModuleTask(['add', repo, path]);\n}\n\nexport function initSubModuleTask(customArgs: string[]): StringTask<string> {\n   return subModuleTask(['init', ...customArgs]);\n}\n\nexport function subModuleTask(customArgs: string[]): StringTask<string> {\n   const commands = [...customArgs];\n   if (commands[0] !== 'submodule') {\n      commands.unshift('submodule');\n   }\n\n   return straightThroughStringTask(commands);\n}\n\nexport function updateSubModuleTask(customArgs: string[]): StringTask<string> {\n   return subModuleTask(['update', ...customArgs]);\n}\n", "import { TagResult } from '../../../typings';\n\nexport class TagList implements TagResult {\n   constructor(\n      public readonly all: string[],\n      public readonly latest: string | undefined,\n   ) {\n   }\n}\n\nexport const parseTagList = function (data: string, customSort = false) {\n   const tags = data\n      .split('\\n')\n      .map(trimmed)\n      .filter(Boolean);\n\n   if (!customSort) {\n      tags.sort(function (tagA, tagB) {\n         const partsA = tagA.split('.');\n         const partsB = tagB.split('.');\n\n         if (partsA.length === 1 || partsB.length === 1) {\n            return singleSorted(toNumber(partsA[0]), toNumber(partsB[0]));\n         }\n\n         for (let i = 0, l = Math.max(partsA.length, partsB.length); i < l; i++) {\n            const diff = sorted(toNumber(partsA[i]), toNumber(partsB[i]));\n\n            if (diff) {\n               return diff;\n            }\n         }\n\n         return 0;\n      });\n   }\n\n   const latest = customSort ? tags[0] : [...tags].reverse().find((tag) => tag.indexOf('.') >= 0);\n\n   return new TagList(tags, latest);\n};\n\nfunction singleSorted(a: number, b:  number): number {\n   const aIsNum = isNaN(a);\n   const bIsNum = isNaN(b);\n\n   if (aIsNum !== bIsNum) {\n      return aIsNum ? 1 : -1;\n   }\n\n   return aIsNum ? sorted(a, b) : 0;\n}\n\nfunction sorted(a: number, b: number) {\n   return a === b ? 0 : a > b ? 1 : -1;\n}\n\nfunction trimmed(input: string) {\n   return input.trim();\n}\n\nfunction toNumber(input: string | undefined) {\n   if (typeof input === 'string') {\n      return parseInt(input.replace(/^\\D+/g, ''), 10) || 0;\n   }\n\n   return 0;\n}\n", "import { TagResult } from '../../../typings';\nimport { parseTagList } from '../responses/TagList';\nimport { StringTask } from '../types';\n\n/**\n * Task used by `git.tags`\n */\nexport function tagListTask (customArgs: string[] = []): StringTask<TagResult> {\n   const hasCustomSort = customArgs.some((option) => /^--sort=/.test(option));\n\n   return {\n      format: 'utf-8',\n      commands: ['tag', '-l', ...customArgs],\n      parser (text: string) {\n         return parseTagList(text, hasCustomSort);\n      },\n   }\n}\n\n/**\n * Task used by `git.addTag`\n */\nexport function addTagTask (name: string): StringTask<{name: string}> {\n   return {\n      format: 'utf-8',\n      commands: ['tag', name],\n      parser () {\n         return {name};\n      }\n   }\n}\n\n/**\n * Task used by `git.addTag`\n */\nexport function addAnnotatedTagTask (name: string, tagMessage: string): StringTask<{name: string}> {\n   return {\n      format: 'utf-8',\n      commands: ['tag', '-a', '-m', tagMessage, name],\n      parser () {\n         return {name};\n      }\n   }\n}\n", "const {GitExecutor} = require('./lib/runners/git-executor');\nconst {SimpleGitApi} = require('./lib/simple-git-api');\n\nconst {Scheduler} = require('./lib/runners/scheduler');\nconst {configurationErrorTask} = require('./lib/tasks/task');\nconst {\n   asArray,\n   filterArray,\n   filterPrimitives,\n   filterString,\n   filterStringOrStringArray,\n   filterType,\n   getTrailingOptions,\n   trailingFunctionArgument,\n   trailingOptionsArgument\n} = require('./lib/utils');\nconst {applyPatchTask} = require('./lib/tasks/apply-patch')\nconst {branchTask, branchLocalTask, deleteBranchesTask, deleteBranchTask} = require('./lib/tasks/branch');\nconst {checkIgnoreTask} = require('./lib/tasks/check-ignore');\nconst {checkIsRepoTask} = require('./lib/tasks/check-is-repo');\nconst {cloneTask, cloneMirrorTask} = require('./lib/tasks/clone');\nconst {cleanWithOptionsTask, isCleanOptionsArray} = require('./lib/tasks/clean');\nconst {commitTask} = require('./lib/tasks/commit');\nconst {diffSummaryTask} = require('./lib/tasks/diff');\nconst {fetchTask} = require('./lib/tasks/fetch');\nconst {moveTask} = require(\"./lib/tasks/move\");\nconst {pullTask} = require('./lib/tasks/pull');\nconst {pushTagsTask} = require('./lib/tasks/push');\nconst {addRemoteTask, getRemotesTask, listRemotesTask, remoteTask, removeRemoteTask} = require('./lib/tasks/remote');\nconst {getResetMode, resetTask} = require('./lib/tasks/reset');\nconst {stashListTask} = require('./lib/tasks/stash-list');\nconst {addSubModuleTask, initSubModuleTask, subModuleTask, updateSubModuleTask} = require('./lib/tasks/sub-module');\nconst {addAnnotatedTagTask, addTagTask, tagListTask} = require('./lib/tasks/tag');\nconst {straightThroughBufferTask, straightThroughStringTask} = require('./lib/tasks/task');\n\nfunction Git (options, plugins) {\n   this._executor = new GitExecutor(\n      options.binary, options.baseDir,\n      new Scheduler(options.maxConcurrentProcesses), plugins,\n   );\n}\n\n(Git.prototype = Object.create(SimpleGitApi.prototype)).constructor = Git;\n\n/**\n * Sets the path to a custom git binary, should either be `git` when there is an installation of git available on\n * the system path, or a fully qualified path to the executable.\n *\n * @param {string} command\n * @returns {Git}\n */\nGit.prototype.customBinary = function (command) {\n   this._executor.binary = command;\n   return this;\n};\n\n/**\n * Sets an environment variable for the spawned child process, either supply both a name and value as strings or\n * a single object to entirely replace the current environment variables.\n *\n * @param {string|Object} name\n * @param {string} [value]\n * @returns {Git}\n */\nGit.prototype.env = function (name, value) {\n   if (arguments.length === 1 && typeof name === 'object') {\n      this._executor.env = name;\n   } else {\n      (this._executor.env = this._executor.env || {})[name] = value;\n   }\n\n   return this;\n};\n\n/**\n * List the stash(s) of the local repo\n */\nGit.prototype.stashList = function (options) {\n   return this._runTask(\n      stashListTask(\n         trailingOptionsArgument(arguments) || {},\n         filterArray(options) && options || []\n      ),\n      trailingFunctionArgument(arguments),\n   );\n};\n\nfunction createCloneTask (api, task, repoPath, localPath) {\n   if (typeof repoPath !== 'string') {\n      return configurationErrorTask(`git.${ api }() requires a string 'repoPath'`);\n   }\n\n   return task(repoPath, filterType(localPath, filterString), getTrailingOptions(arguments));\n}\n\n\n/**\n * Clone a git repo\n */\nGit.prototype.clone = function () {\n   return this._runTask(\n      createCloneTask('clone', cloneTask, ...arguments),\n      trailingFunctionArgument(arguments),\n   );\n};\n\n/**\n * Mirror a git repo\n */\nGit.prototype.mirror = function () {\n   return this._runTask(\n      createCloneTask('mirror', cloneMirrorTask, ...arguments),\n      trailingFunctionArgument(arguments),\n   );\n};\n\n/**\n * Moves one or more files to a new destination.\n *\n * @see https://git-scm.com/docs/git-mv\n *\n * @param {string|string[]} from\n * @param {string} to\n */\nGit.prototype.mv = function (from, to) {\n   return this._runTask(moveTask(from, to), trailingFunctionArgument(arguments));\n};\n\n/**\n * Internally uses pull and tags to get the list of tags then checks out the latest tag.\n *\n * @param {Function} [then]\n */\nGit.prototype.checkoutLatestTag = function (then) {\n   var git = this;\n   return this.pull(function () {\n      git.tags(function (err, tags) {\n         git.checkout(tags.latest, then);\n      });\n   });\n};\n\n/**\n * Pull the updated contents of the current repo\n */\nGit.prototype.pull = function (remote, branch, options, then) {\n   return this._runTask(\n      pullTask(filterType(remote, filterString), filterType(branch, filterString), getTrailingOptions(arguments)),\n      trailingFunctionArgument(arguments),\n   );\n};\n\n/**\n * Fetch the updated contents of the current repo.\n *\n * @example\n *   .fetch('upstream', 'master') // fetches from master on remote named upstream\n *   .fetch(function () {}) // runs fetch against default remote and branch and calls function\n *\n * @param {string} [remote]\n * @param {string} [branch]\n */\nGit.prototype.fetch = function (remote, branch) {\n   return this._runTask(\n      fetchTask(filterType(remote, filterString), filterType(branch, filterString), getTrailingOptions(arguments)),\n      trailingFunctionArgument(arguments),\n   );\n};\n\n/**\n * Disables/enables the use of the console for printing warnings and errors, by default messages are not shown in\n * a production environment.\n *\n * @param {boolean} silence\n * @returns {Git}\n */\nGit.prototype.silent = function (silence) {\n   console.warn('simple-git deprecation notice: git.silent: logging should be configured using the `debug` library / `DEBUG` environment variable, this will be an error in version 3');\n   return this;\n};\n\n/**\n * List all tags. When using git 2.7.0 or above, include an options object with `\"--sort\": \"property-name\"` to\n * sort the tags by that property instead of using the default semantic versioning sort.\n *\n * Note, supplying this option when it is not supported by your Git version will cause the operation to fail.\n *\n * @param {Object} [options]\n * @param {Function} [then]\n */\nGit.prototype.tags = function (options, then) {\n   return this._runTask(\n      tagListTask(getTrailingOptions(arguments)),\n      trailingFunctionArgument(arguments),\n   );\n};\n\n/**\n * Rebases the current working copy. Options can be supplied either as an array of string parameters\n * to be sent to the `git rebase` command, or a standard options object.\n */\nGit.prototype.rebase = function () {\n   return this._runTask(\n      straightThroughStringTask(['rebase', ...getTrailingOptions(arguments)]),\n      trailingFunctionArgument(arguments)\n   );\n};\n\n/**\n * Reset a repo\n */\nGit.prototype.reset = function (mode) {\n   return this._runTask(\n      resetTask(getResetMode(mode), getTrailingOptions(arguments)),\n      trailingFunctionArgument(arguments),\n   );\n};\n\n/**\n * Revert one or more commits in the local working copy\n */\nGit.prototype.revert = function (commit) {\n   const next = trailingFunctionArgument(arguments);\n\n   if (typeof commit !== 'string') {\n      return this._runTask(\n         configurationErrorTask('Commit must be a string'),\n         next,\n      );\n   }\n\n   return this._runTask(\n      straightThroughStringTask(['revert', ...getTrailingOptions(arguments, 0, true), commit]),\n      next\n   );\n};\n\n/**\n * Add a lightweight tag to the head of the current branch\n */\nGit.prototype.addTag = function (name) {\n   const task = (typeof name === 'string')\n      ? addTagTask(name)\n      : configurationErrorTask('Git.addTag requires a tag name');\n\n   return this._runTask(task, trailingFunctionArgument(arguments));\n};\n\n/**\n * Add an annotated tag to the head of the current branch\n */\nGit.prototype.addAnnotatedTag = function (tagName, tagMessage) {\n   return this._runTask(\n      addAnnotatedTagTask(tagName, tagMessage),\n      trailingFunctionArgument(arguments),\n   );\n};\n\n/**\n * Check out a tag or revision, any number of additional arguments can be passed to the `git checkout` command\n * by supplying either a string or array of strings as the first argument.\n */\nGit.prototype.checkout = function () {\n   const commands = ['checkout', ...getTrailingOptions(arguments, true)];\n   return this._runTask(\n      straightThroughStringTask(commands),\n      trailingFunctionArgument(arguments),\n   );\n};\n\n/**\n * Check out a remote branch\n *\n * @param {string} branchName name of branch\n * @param {string} startPoint (e.g origin/development)\n * @param {Function} [then]\n */\nGit.prototype.checkoutBranch = function (branchName, startPoint, then) {\n   return this.checkout(['-b', branchName, startPoint], trailingFunctionArgument(arguments));\n};\n\n/**\n * Check out a local branch\n */\nGit.prototype.checkoutLocalBranch = function (branchName, then) {\n   return this.checkout(['-b', branchName], trailingFunctionArgument(arguments));\n};\n\n/**\n * Delete a local branch\n */\nGit.prototype.deleteLocalBranch = function (branchName, forceDelete, then) {\n   return this._runTask(\n      deleteBranchTask(branchName, typeof forceDelete === \"boolean\" ? forceDelete : false),\n      trailingFunctionArgument(arguments),\n   );\n};\n\n/**\n * Delete one or more local branches\n */\nGit.prototype.deleteLocalBranches = function (branchNames, forceDelete, then) {\n   return this._runTask(\n      deleteBranchesTask(branchNames, typeof forceDelete === \"boolean\" ? forceDelete : false),\n      trailingFunctionArgument(arguments),\n   );\n};\n\n/**\n * List all branches\n *\n * @param {Object | string[]} [options]\n * @param {Function} [then]\n */\nGit.prototype.branch = function (options, then) {\n   return this._runTask(\n      branchTask(getTrailingOptions(arguments)),\n      trailingFunctionArgument(arguments),\n   );\n};\n\n/**\n * Return list of local branches\n *\n * @param {Function} [then]\n */\nGit.prototype.branchLocal = function (then) {\n   return this._runTask(\n      branchLocalTask(),\n      trailingFunctionArgument(arguments),\n   );\n};\n\n/**\n * Executes any command against the git binary.\n */\nGit.prototype.raw = function (commands) {\n   const createRestCommands = !Array.isArray(commands);\n   const command = [].slice.call(createRestCommands ? arguments : commands, 0);\n\n   for (let i = 0; i < command.length && createRestCommands; i++) {\n      if (!filterPrimitives(command[i])) {\n         command.splice(i, command.length - i);\n         break;\n      }\n   }\n\n   command.push(\n      ...getTrailingOptions(arguments, 0, true),\n   );\n\n   var next = trailingFunctionArgument(arguments);\n\n   if (!command.length) {\n      return this._runTask(\n         configurationErrorTask('Raw: must supply one or more command to execute'),\n         next,\n      );\n   }\n\n   return this._runTask(straightThroughStringTask(command), next);\n};\n\nGit.prototype.submoduleAdd = function (repo, path, then) {\n   return this._runTask(\n      addSubModuleTask(repo, path),\n      trailingFunctionArgument(arguments),\n   );\n};\n\nGit.prototype.submoduleUpdate = function (args, then) {\n   return this._runTask(\n      updateSubModuleTask(getTrailingOptions(arguments, true)),\n      trailingFunctionArgument(arguments),\n   );\n};\n\nGit.prototype.submoduleInit = function (args, then) {\n   return this._runTask(\n      initSubModuleTask(getTrailingOptions(arguments, true)),\n      trailingFunctionArgument(arguments),\n   );\n};\n\nGit.prototype.subModule = function (options, then) {\n   return this._runTask(\n      subModuleTask(getTrailingOptions(arguments)),\n      trailingFunctionArgument(arguments),\n   );\n};\n\nGit.prototype.listRemote = function () {\n   return this._runTask(\n      listRemotesTask(getTrailingOptions(arguments)),\n      trailingFunctionArgument(arguments),\n   );\n};\n\n/**\n * Adds a remote to the list of remotes.\n */\nGit.prototype.addRemote = function (remoteName, remoteRepo, then) {\n   return this._runTask(\n      addRemoteTask(remoteName, remoteRepo, getTrailingOptions(arguments)),\n      trailingFunctionArgument(arguments),\n   );\n};\n\n/**\n * Removes an entry by name from the list of remotes.\n */\nGit.prototype.removeRemote = function (remoteName, then) {\n   return this._runTask(\n      removeRemoteTask(remoteName),\n      trailingFunctionArgument(arguments),\n   );\n};\n\n/**\n * Gets the currently available remotes, setting the optional verbose argument to true includes additional\n * detail on the remotes themselves.\n */\nGit.prototype.getRemotes = function (verbose, then) {\n   return this._runTask(\n      getRemotesTask(verbose === true),\n      trailingFunctionArgument(arguments),\n   );\n};\n\n/**\n * Call any `git remote` function with arguments passed as an array of strings.\n *\n * @param {string[]} options\n * @param {Function} [then]\n */\nGit.prototype.remote = function (options, then) {\n   return this._runTask(\n      remoteTask(getTrailingOptions(arguments)),\n      trailingFunctionArgument(arguments),\n   );\n};\n\n/**\n * Call any `git tag` function with arguments passed as an array of strings.\n *\n * @param {string[]} options\n * @param {Function} [then]\n */\nGit.prototype.tag = function (options, then) {\n   const command = getTrailingOptions(arguments);\n\n   if (command[0] !== 'tag') {\n      command.unshift('tag');\n   }\n\n   return this._runTask(\n      straightThroughStringTask(command),\n      trailingFunctionArgument(arguments)\n   );\n};\n\n/**\n * Updates repository server info\n *\n * @param {Function} [then]\n */\nGit.prototype.updateServerInfo = function (then) {\n   return this._runTask(\n      straightThroughStringTask(['update-server-info']),\n      trailingFunctionArgument(arguments),\n   );\n};\n\n/**\n * Pushes the current tag changes to a remote which can be either a URL or named remote. When not specified uses the\n * default configured remote spec.\n *\n * @param {string} [remote]\n * @param {Function} [then]\n */\nGit.prototype.pushTags = function (remote, then) {\n   const task = pushTagsTask({remote: filterType(remote, filterString)}, getTrailingOptions(arguments));\n\n   return this._runTask(task, trailingFunctionArgument(arguments));\n};\n\n/**\n * Removes the named files from source control.\n */\nGit.prototype.rm = function (files) {\n   return this._runTask(\n      straightThroughStringTask(['rm', '-f', ...asArray(files)]),\n      trailingFunctionArgument(arguments)\n   );\n};\n\n/**\n * Removes the named files from source control but keeps them on disk rather than deleting them entirely. To\n * completely remove the files, use `rm`.\n *\n * @param {string|string[]} files\n */\nGit.prototype.rmKeepLocal = function (files) {\n   return this._runTask(\n      straightThroughStringTask(['rm', '--cached', ...asArray(files)]),\n      trailingFunctionArgument(arguments)\n   );\n};\n\n/**\n * Returns a list of objects in a tree based on commit hash. Passing in an object hash returns the object's content,\n * size, and type.\n *\n * Passing \"-p\" will instruct cat-file to determine the object type, and display its formatted contents.\n *\n * @param {string[]} [options]\n * @param {Function} [then]\n */\nGit.prototype.catFile = function (options, then) {\n   return this._catFile('utf-8', arguments);\n};\n\nGit.prototype.binaryCatFile = function () {\n   return this._catFile('buffer', arguments);\n};\n\nGit.prototype._catFile = function (format, args) {\n   var handler = trailingFunctionArgument(args);\n   var command = ['cat-file'];\n   var options = args[0];\n\n   if (typeof options === 'string') {\n      return this._runTask(\n         configurationErrorTask('Git.catFile: options must be supplied as an array of strings'),\n         handler,\n      );\n   }\n\n   if (Array.isArray(options)) {\n      command.push.apply(command, options);\n   }\n\n   const task = format === 'buffer'\n      ? straightThroughBufferTask(command)\n      : straightThroughStringTask(command);\n\n   return this._runTask(task, handler);\n};\n\nGit.prototype.diff = function (options, then) {\n   const task = filterString(options)\n      ? configurationErrorTask('git.diff: supplying options as a single string is no longer supported, switch to an array of strings')\n      : straightThroughStringTask(['diff', ...getTrailingOptions(arguments)]);\n\n   return this._runTask(\n      task,\n      trailingFunctionArgument(arguments),\n   );\n};\n\nGit.prototype.diffSummary = function () {\n   return this._runTask(\n      diffSummaryTask(getTrailingOptions(arguments, 1)),\n      trailingFunctionArgument(arguments),\n   );\n};\n\nGit.prototype.applyPatch = function (patches) {\n   const task = !filterStringOrStringArray(patches)\n      ? configurationErrorTask(`git.applyPatch requires one or more string patches as the first argument`)\n      : applyPatchTask(asArray(patches), getTrailingOptions([].slice.call(arguments, 1)));\n\n   return this._runTask(\n      task,\n      trailingFunctionArgument(arguments),\n   );\n}\n\nGit.prototype.revparse = function () {\n   const commands = ['rev-parse', ...getTrailingOptions(arguments, true)];\n   return this._runTask(\n      straightThroughStringTask(commands, true),\n      trailingFunctionArgument(arguments),\n   );\n};\n\n/**\n * Show various types of objects, for example the file at a certain commit\n *\n * @param {string[]} [options]\n * @param {Function} [then]\n */\nGit.prototype.show = function (options, then) {\n   return this._runTask(\n      straightThroughStringTask(['show', ...getTrailingOptions(arguments, 1)]),\n      trailingFunctionArgument(arguments)\n   );\n};\n\n/**\n */\nGit.prototype.clean = function (mode, options, then) {\n   const usingCleanOptionsArray = isCleanOptionsArray(mode);\n   const cleanMode = usingCleanOptionsArray && mode.join('') || filterType(mode, filterString) || '';\n   const customArgs = getTrailingOptions([].slice.call(arguments, usingCleanOptionsArray ? 1 : 0));\n\n   return this._runTask(\n      cleanWithOptionsTask(cleanMode, customArgs),\n      trailingFunctionArgument(arguments),\n   );\n};\n\nGit.prototype.exec = function (then) {\n   const task = {\n      commands: [],\n      format: 'utf-8',\n      parser () {\n         if (typeof then === 'function') {\n            then();\n         }\n      }\n   };\n\n   return this._runTask(task);\n};\n\n/**\n * Clears the queue of pending commands and returns the wrapper instance for chaining.\n *\n * @returns {Git}\n */\nGit.prototype.clearQueue = function () {\n   // TODO:\n   // this._executor.clear();\n   return this;\n};\n\n/**\n * Check if a pathname or pathnames are excluded by .gitignore\n *\n * @param {string|string[]} pathnames\n * @param {Function} [then]\n */\nGit.prototype.checkIgnore = function (pathnames, then) {\n   return this._runTask(\n      checkIgnoreTask(asArray((filterType(pathnames, filterStringOrStringArray, [])))),\n      trailingFunctionArgument(arguments),\n   );\n};\n\nGit.prototype.checkIsRepo = function (checkType, then) {\n   return this._runTask(\n      checkIsRepoTask(filterType(checkType, filterString)),\n      trailingFunctionArgument(arguments),\n   );\n};\n\nmodule.exports = Git;\n", "import { GitError } from './git-error';\nimport { SimpleGitOptions } from '../types';\n\n/**\n * The `GitConstructError` is thrown when an error occurs in the constructor\n * of the `simple-git` instance itself. Most commonly as a result of using\n * a `baseDir` option that points to a folder that either does not exist,\n * or cannot be read by the user the node script is running as.\n *\n * Check the `.message` property for more detail including the properties\n * passed to the constructor.\n */\nexport class GitConstructError extends GitError {\n\n   constructor (\n      public readonly config: SimpleGitOptions,\n      message: string,\n   ) {\n      super(undefined, message);\n   }\n\n}\n", "import { GitConstructError } from './errors/git-construct-error';\nimport { GitError } from './errors/git-error';\nimport { GitPluginError } from './errors/git-plugin-error';\nimport { GitResponseError } from './errors/git-response-error';\nimport { TaskConfigurationError } from './errors/task-configuration-error';\nimport { CheckRepoActions } from './tasks/check-is-repo';\nimport { CleanOptions } from './tasks/clean';\nimport { GitConfigScope } from './tasks/config';\nimport { grepQueryBuilder } from './tasks/grep';\nimport { ResetMode } from './tasks/reset';\n\nexport {\n   CheckRepoActions,\n   CleanOptions,\n   GitConfigScope,\n   GitConstructError,\n   GitError,\n   GitPluginError,\n   GitResponseError,\n   ResetMode,\n   TaskConfigurationError,\n   grepQueryBuilder,\n};\n\n// export const api = {\n//    CheckRepoActions,\n//    CleanOptions,\n//    GitConfigScope,\n//    GitConstructError,\n//    GitError,\n//    GitPluginError,\n//    GitResponseError,\n//    ResetMode,\n//    TaskConfigurationError,\n//    grepQueryBuilder,\n// };\n", "import { SimpleGitOptions, SimpleGitTask } from '../types';\nimport { GitError } from './git-error';\n\nexport class GitPluginError extends GitError {\n\n   constructor (\n      public task?: SimpleGitTask<any>,\n      public readonly plugin?: keyof SimpleGitOptions,\n      message?: string,\n   ) {\n      super(task, message);\n      Object.setPrototypeOf(this, new.target.prototype);\n   }\n\n}\n", "import { prefixedArray } from '../utils';\nimport { SimpleGitPlugin } from './simple-git-plugin';\n\nexport function commandConfigPrefixingPlugin(configuration: string[]): SimpleGitPlugin<'spawn.args'> {\n   const prefix = prefixedArray(configuration, '-c');\n\n   return {\n      type: 'spawn.args',\n      action(data) {\n         return [...prefix, ...data];\n      },\n   };\n}\n", "import { deferred, DeferredPromise } from '@kwsites/promise-deferred';\nimport { SimpleGitPluginConfig } from '../types';\nimport { delay } from '../utils';\nimport { SimpleGitPlugin } from './simple-git-plugin';\n\nconst never = deferred().promise;\n\nexport function completionDetectionPlugin({\n                                             onClose = true,\n                                             onExit = 50\n                                          }: SimpleGitPluginConfig['completion'] = {}): SimpleGitPlugin<'spawn.after'> {\n\n   function createEvents() {\n      let exitCode = -1;\n      const events = {\n         close: deferred(),\n         closeTimeout: deferred(),\n         exit: deferred(),\n         exitTimeout: deferred(),\n      };\n\n      const result = Promise.race([\n         onClose === false ? never : events.closeTimeout.promise,\n         onExit === false ? never : events.exitTimeout.promise,\n      ]);\n\n      configureTimeout(onClose, events.close, events.closeTimeout);\n      configureTimeout(onExit, events.exit, events.exitTimeout);\n\n      return {\n         close(code: number) {\n            exitCode = code;\n            events.close.done();\n         },\n         exit(code: number) {\n            exitCode = code;\n            events.exit.done();\n         },\n         get exitCode() {\n            return exitCode;\n         },\n         result,\n      };\n   }\n\n   function configureTimeout(flag: boolean | number, event: DeferredPromise<void>, timeout: DeferredPromise<void>) {\n      if (flag === false) {\n         return;\n      }\n\n      (flag === true ? event.promise : event.promise.then(() => delay(flag))).then(timeout.done);\n   }\n\n   return {\n      type: 'spawn.after',\n      async action(_data, {spawned, close}) {\n         const events = createEvents();\n\n         let deferClose = true;\n         let quickClose = () => void (deferClose = false);\n\n         spawned.stdout?.on('data', quickClose);\n         spawned.stderr?.on('data', quickClose);\n         spawned.on('error', quickClose);\n\n         spawned.on('close', (code: number) => events.close(code));\n         spawned.on('exit', (code: number) => events.exit(code));\n\n         try{\n            await events.result;\n            if (deferClose) {\n               await delay(50);\n            }\n            close(events.exitCode);\n         }\n         catch (err) {\n            close(events.exitCode, err);\n         }\n      }\n   }\n}\n", "import { GitError } from '../errors/git-error';\nimport { GitExecutorResult, SimpleGitPluginConfig } from '../types';\nimport { SimpleGitPlugin } from './simple-git-plugin';\n\ntype TaskResult = Omit<GitExecutorResult, 'rejection'>;\n\nfunction isTaskError (result: TaskResult) {\n   return !!(result.exitCode && result.stdErr.length);\n}\n\nfunction getErrorMessage (result: TaskResult) {\n   return Buffer.concat([...result.stdOut, ...result.stdErr]);\n}\n\nexport function errorDetectionHandler (overwrite = false, isError = isTaskError, errorMessage: (result: TaskResult) => Buffer | Error = getErrorMessage) {\n\n   return (error: Buffer | Error | undefined, result: TaskResult) => {\n      if ((!overwrite && error) || !isError(result)) {\n         return error;\n      }\n\n      return errorMessage(result);\n   };\n}\n\nexport function errorDetectionPlugin(config: SimpleGitPluginConfig['errors']): SimpleGitPlugin<'task.error'> {\n\n   return {\n      type: 'task.error',\n      action(data, context) {\n         const error = config(data.error, {\n            stdErr: context.stdErr,\n            stdOut: context.stdOut,\n            exitCode: context.exitCode\n         });\n\n         if (Buffer.isBuffer(error)) {\n            return {error: new GitError(undefined, error.toString('utf-8'))};\n         }\n\n         return {\n            error\n         };\n      },\n   };\n\n}\n", "import { SimpleGitPlugin, SimpleGitPluginType, SimpleGitPluginTypes } from './simple-git-plugin';\nimport { append, asArray } from '../utils';\n\nexport class PluginStore {\n\n   private plugins: Set<SimpleGitPlugin<SimpleGitPluginType>> = new Set();\n\n   public add<T extends SimpleGitPluginType>(plugin: void | SimpleGitPlugin<T> | SimpleGitPlugin<T>[]) {\n      const plugins: SimpleGitPlugin<T>[] = [];\n\n      asArray(plugin).forEach(plugin => plugin && this.plugins.add(append(plugins, plugin)));\n\n      return () => {\n         plugins.forEach(plugin => this.plugins.delete(plugin));\n      };\n   }\n\n   public exec<T extends SimpleGitPluginType>(type: T, data: SimpleGitPluginTypes[T]['data'], context: SimpleGitPluginTypes[T]['context']): typeof data {\n      let output = data;\n      const contextual = Object.freeze(Object.create(context));\n\n      for (const plugin of this.plugins) {\n         if (plugin.type === type) {\n            output = plugin.action(output, contextual);\n         }\n      }\n\n      return output;\n   }\n\n}\n", "import { SimpleGitOptions } from '../types';\nimport { asNumber, including } from '../utils';\n\nimport { SimpleGitPlugin } from './simple-git-plugin';\n\nexport function progressMonitorPlugin(progress: Exclude<SimpleGitOptions['progress'], void>) {\n   const progressCommand = '--progress';\n   const progressMethods = ['checkout', 'clone', 'fetch', 'pull', 'push'];\n\n   const onProgress: SimpleGitPlugin<'spawn.after'> = {\n      type: 'spawn.after',\n      action(_data, context) {\n         if (!context.commands.includes(progressCommand)) {\n            return;\n         }\n\n         context.spawned.stderr?.on('data', (chunk: Buffer) => {\n            const message = /^([\\s\\S]+?):\\s*(\\d+)% \\((\\d+)\\/(\\d+)\\)/.exec(chunk.toString('utf8'));\n            if (!message) {\n               return;\n            }\n\n            progress({\n               method: context.method,\n               stage: progressEventStage(message[1]),\n               progress: asNumber(message[2]),\n               processed: asNumber(message[3]),\n               total: asNumber(message[4]),\n            });\n         });\n      }\n   };\n\n   const onArgs: SimpleGitPlugin<'spawn.args'> = {\n      type: 'spawn.args',\n      action(args, context) {\n         if (!progressMethods.includes(context.method)) {\n            return args;\n         }\n\n         return including(args, progressCommand);\n      }\n   }\n\n   return [onArgs, onProgress];\n}\n\nfunction progressEventStage (input: string) {\n   return String(input.toLowerCase().split(' ', 1)) || 'unknown';\n}\n", "import { SpawnOptions } from 'child_process';\nimport { pick } from '../utils';\nimport { SimpleGitPlugin } from './simple-git-plugin';\n\nexport function spawnOptionsPlugin(spawnOptions: Partial<SpawnOptions>): SimpleGitPlugin<'spawn.options'> {\n   const options = pick(spawnOptions, ['uid', 'gid']);\n\n   return {\n      type: 'spawn.options',\n      action(data) {\n         return {...options, ...data};\n      },\n   };\n}\n", "import { SimpleGitOptions } from '../types';\n\nimport { SimpleGitPlugin } from './simple-git-plugin';\nimport { GitPluginError } from '../errors/git-plugin-error';\n\nexport function timeoutPlugin({block}: Exclude<SimpleGitOptions['timeout'], undefined>): SimpleGitPlugin<'spawn.after'> | void {\n\n   if (block > 0) {\n      return {\n         type: 'spawn.after',\n         action(_data, context) {\n            let timeout: NodeJS.Timeout;\n\n            function wait() {\n               timeout && clearTimeout(timeout);\n               timeout = setTimeout(kill, block);\n            }\n\n            function stop() {\n               context.spawned.stdout?.off('data', wait);\n               context.spawned.stderr?.off('data', wait);\n               context.spawned.off('exit', stop);\n               context.spawned.off('close', stop);\n               timeout && clearTimeout(timeout);\n            }\n\n            function kill() {\n               stop()\n               context.kill(\n                  new GitPluginError(undefined, 'timeout', `block timeout reached`)\n               );\n            }\n\n            context.spawned.stdout?.on('data', wait);\n            context.spawned.stderr?.on('data', wait);\n            context.spawned.on('exit', stop);\n            context.spawned.on('close', stop);\n\n            wait();\n         }\n      }\n   }\n\n}\n", "import { SimpleGitFactory } from '../../typings';\n\nimport * as api from './api';\nimport {\n   commandConfigPrefixingPlugin,\n   completionDetectionPlugin,\n   errorDetectionHandler,\n   errorDetectionPlugin,\n   PluginStore,\n   progressMonitorPlugin,\n   spawnOptionsPlugin,\n   timeoutPlugin\n} from './plugins';\nimport { createInstanceConfig, folderExists } from './utils';\nimport { SimpleGitOptions } from './types';\n\nconst Git = require('../git');\n\n/**\n * Adds the necessary properties to the supplied object to enable it for use as\n * the default export of a module.\n *\n * Eg: `module.exports = esModuleFactory({ something () {} })`\n */\nexport function esModuleFactory<T>(defaultExport: T): T & { __esModule: true, default: T } {\n   return Object.defineProperties(defaultExport, {\n      __esModule: {value: true},\n      default: {value: defaultExport},\n   });\n}\n\nexport function gitExportFactory<T = {}>(factory: SimpleGitFactory, extra: T) {\n   return Object.assign(function (...args: Parameters<SimpleGitFactory>) {\n         return factory.apply(null, args);\n      },\n      api,\n      extra || {},\n   );\n}\n\nexport function gitInstanceFactory(baseDir?: string | Partial<SimpleGitOptions>, options?: Partial<SimpleGitOptions>) {\n   const plugins = new PluginStore();\n   const config = createInstanceConfig(\n      baseDir && (typeof baseDir === 'string' ? {baseDir} : baseDir) || {},\n      options\n   );\n\n   if (!folderExists(config.baseDir)) {\n      throw new api.GitConstructError(config, `Cannot use simple-git on a directory that does not exist`);\n   }\n\n   if (Array.isArray(config.config)) {\n      plugins.add(commandConfigPrefixingPlugin(config.config));\n   }\n\n   plugins.add(completionDetectionPlugin(config.completion));\n   config.progress && plugins.add(progressMonitorPlugin(config.progress));\n   config.timeout && plugins.add(timeoutPlugin(config.timeout));\n   config.spawnOptions && plugins.add(spawnOptionsPlugin(config.spawnOptions));\n\n   plugins.add(errorDetectionPlugin(errorDetectionHandler(true)));\n   config.errors && plugins.add(errorDetectionPlugin(config.errors));\n\n   return new Git(config, plugins);\n}\n", "import { SimpleGit, SimpleGitOptions } from '../../../typings';\n\nimport { GitResponseError } from '../errors/git-response-error';\nimport { gitInstanceFactory } from '../git-factory';\nimport { SimpleGitTaskCallback } from '../types';\n\nconst functionNamesBuilderApi = [\n   'customBinary', 'env', 'outputHandler', 'silent',\n];\n\nconst functionNamesPromiseApi = [\n   'add',\n   'addAnnotatedTag',\n   'addConfig',\n   'addRemote',\n   'addTag',\n   'applyPatch',\n   'binaryCatFile',\n   'branch',\n   'branchLocal',\n   'catFile',\n   'checkIgnore',\n   'checkIsRepo',\n   'checkout',\n   'checkoutBranch',\n   'checkoutLatestTag',\n   'checkoutLocalBranch',\n   'clean',\n   'clone',\n   'commit',\n   'cwd',\n   'deleteLocalBranch',\n   'deleteLocalBranches',\n   'diff',\n   'diffSummary',\n   'exec',\n   'fetch',\n   'getRemotes',\n   'init',\n   'listConfig',\n   'listRemote',\n   'log',\n   'merge',\n   'mergeFromTo',\n   'mirror',\n   'mv',\n   'pull',\n   'push',\n   'pushTags',\n   'raw',\n   'rebase',\n   'remote',\n   'removeRemote',\n   'reset',\n   'revert',\n   'revparse',\n   'rm',\n   'rmKeepLocal',\n   'show',\n   'stash',\n   'stashList',\n   'status',\n   'subModule',\n   'submoduleAdd',\n   'submoduleInit',\n   'submoduleUpdate',\n   'tag',\n   'tags',\n   'updateServerInfo'\n];\n\nexport function gitP(...args: [] | [string] | [Partial<SimpleGitOptions>] | [string, Partial<SimpleGitOptions>]): SimpleGit {\n\n   let git: any;\n\n   let chain = Promise.resolve();\n\n   try {\n      git = gitInstanceFactory(...args);\n   } catch (e) {\n      chain = Promise.reject(e);\n   }\n\n   function builderReturn() {\n      return promiseApi;\n   }\n\n   function chainReturn() {\n      return chain;\n   }\n\n   const promiseApi = [...functionNamesBuilderApi, ...functionNamesPromiseApi].reduce((api: any, name: string) => {\n      const isAsync = functionNamesPromiseApi.includes(name);\n\n      const valid = isAsync ? asyncWrapper(name, git) : syncWrapper(name, git, api);\n      const alternative = isAsync ? chainReturn : builderReturn;\n\n      Object.defineProperty(api, name, {\n         enumerable: false,\n         configurable: false,\n         value: git ? valid : alternative,\n      });\n\n      return api;\n   }, {});\n\n   return promiseApi as SimpleGit;\n\n   function asyncWrapper(fn: string, git: any): (...args: any[]) => Promise<any> {\n      return function (...args: any[]) {\n         if (typeof args[args.length] === 'function') {\n            throw new TypeError(\n               'Promise interface requires that handlers are not supplied inline, ' +\n               'trailing function not allowed in call to ' + fn);\n         }\n\n         return chain.then(function () {\n            return new Promise(function (resolve, reject) {\n               const callback: SimpleGitTaskCallback = (err: Error | null, result?: any) => {\n                  if (err) {\n                     return reject(toError(err));\n                  }\n\n                  resolve(result);\n               };\n               args.push(callback);\n\n               git[fn].apply(git, args);\n            });\n         });\n      };\n   }\n\n   function syncWrapper(fn: string, git: any, api: SimpleGit) {\n      return (...args: any[]) => {\n         git[fn](...args);\n\n         return api;\n      };\n   }\n}\n\nfunction toError(error: Error | string | any): Error {\n\n   if (error instanceof Error) {\n      return error;\n   }\n\n   if (typeof error === 'string') {\n      return new Error(error);\n   }\n\n   return new GitResponseError(error);\n}\n", "import { gitInstanceFactory } from './lib/git-factory';\n\nexport {gitP} from './lib/runners/promise-wrapped';\nexport * from './lib/api';\n\nexport default gitInstanceFactory;\n"],
+  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,IA2BO;AA3BP;AAAA;AA2BO,6BAAuB,MAAM;AAAA,MAEjC,YACU,MACP,SACD;AACC,cAAM;AAHC;AAIP,eAAO,eAAe,MAAM,WAAW;AAAA;AAAA;AAAA;AAAA;;;AClC7C,IAsBO;AAtBP;AAAA;AAAA;AAsBO,qCAAwC,SAAS;AAAA,MAErD,YAImB,KAChB,SACD;AACC,cAAM,QAAW,WAAW,OAAO;AAHnB;AAAA;AAAA;AAAA;AAAA;;;AC5BtB,IAUO;AAVP;AAAA;AAAA;AAUO,2CAAqC,SAAS;AAAA,MAElD,YACG,SACD;AACC,cAAM,QAAW;AAAA;AAAA;AAAA;AAAA;;;ACfvB;AAYO,oBAAyC,QAAoB;AACjE,SAAO,OAAO,WAAW,aAAa,SAAS;AAAA;AAO3C,wBAA4C,QAA8B;AAC9E,SAAQ,OAAO,WAAW,cAAc,WAAW;AAAA;AAG/C,iBAAiB,OAAe,MAAgC;AACpE,QAAM,QAAQ,MAAM,QAAQ;AAC5B,MAAI,SAAS,GAAG;AACb,WAAO,CAAC,OAAO;AAAA;AAGlB,SAAO;AAAA,IACJ,MAAM,OAAO,GAAG;AAAA,IAChB,MAAM,OAAO,QAAQ;AAAA;AAAA;AAMpB,eAAe,OAA2B,SAAS,GAAmB;AAC1E,SAAO,YAAY,UAAU,MAAM,SAAS,SAAS,MAAM,UAAU;AAAA;AAMjE,cAAc,OAAgB,SAAS,GAAG;AAC9C,MAAI,YAAY,UAAU,MAAM,SAAS,QAAQ;AAC9C,WAAO,MAAM,MAAM,SAAS,IAAI;AAAA;AAAA;AAMtC,qBAAqB,OAAgC;AAClD,SAAO,CAAC,CAAE,UAAS,OAAO,MAAM,WAAW;AAAA;AAGvC,4BAA4B,QAAQ,IAAI,WAAU,MAAM,YAAY,MAAgB;AACxF,SAAO,MAAM,MAAM,WACf,OAAO,CAAC,QAAQ,SAAS;AACvB,UAAM,cAAc,WAAU,KAAK,SAAS;AAC5C,QAAI,aAAa;AACd,aAAO,KAAK;AAAA;AAEf,WAAO;AAAA,KACP;AAAA;AAKF,gCAAmC,OAAe,UAA2C;AACjG,SAAO,mBAAmB,OAAO,MAAM,IAAI,UAAQ,SAAS;AAAA;AAGxD,sBAAsB,MAAuB;AACjD,SAAO,OAAO,MAAM;AAAA;AAMhB,gBAAmB,QAAsB,MAAsB;AACnE,MAAI,MAAM,QAAQ,SAAS;AACxB,QAAI,CAAC,OAAO,SAAS,OAAO;AACzB,aAAO,KAAK;AAAA;AAAA,SAEX;AACJ,WAAO,IAAI;AAAA;AAEd,SAAO;AAAA;AAMH,mBAAsB,QAAa,MAAwB;AAC/D,MAAI,MAAM,QAAQ,WAAW,CAAC,OAAO,SAAS,OAAO;AAClD,WAAO,KAAK;AAAA;AAGf,SAAO;AAAA;AAGH,gBAAmB,QAAsB,MAAY;AACzD,MAAI,MAAM,QAAQ,SAAS;AACxB,UAAM,QAAQ,OAAO,QAAQ;AAC7B,QAAI,SAAS,GAAG;AACb,aAAO,OAAO,OAAO;AAAA;AAAA,SAEpB;AACJ,WAAO,OAAO;AAAA;AAEjB,SAAO;AAAA;AAKH,iBAAoB,QAAsB;AAC9C,SAAO,MAAM,QAAQ,UAAU,SAAS,CAAC;AAAA;AAGrC,uBAA0B,QAA2B;AACzD,SAAO,QAAQ,QAAQ,IAAI;AAAA;AAGvB,kBAAkB,QAAmC,QAAQ,GAAG;AACpE,MAAI,UAAU,MAAM;AACjB,WAAO;AAAA;AAGV,QAAM,MAAM,SAAS,QAAQ;AAC7B,SAAO,MAAM,OAAO,QAAQ;AAAA;AAGxB,uBAA0B,OAAY,QAAgB;AAC1D,QAAM,SAAc;AACpB,WAAS,IAAI,GAAG,MAAM,MAAM,QAAQ,IAAI,KAAK,KAAK;AAC/C,WAAO,KAAK,QAAQ,MAAM;AAAA;AAE7B,SAAO;AAAA;AAGH,wBAAwB,OAAkC;AAC9D,SAAQ,OAAM,QAAQ,SAAS,OAAO,OAAO,SAAS,OAAO,SAAS;AAAA;AAMlE,cAAc,QAA6B,YAAsB;AACrE,SAAO,OAAO,OAAO,IAAI,GAAG,WAAW,IAAI,CAAC,aAAa,YAAY,SAAS,GAAE,WAAW,OAAO,cAAa;AAAA;AAG3G,eAAe,WAAW,GAAkB;AAChD,SAAO,IAAI,QAAQ,UAAQ,WAAW,MAAM;AAAA;AA1J/C,IAGa,MAEA,MA8GA;AAnHb;AAAA;AAGO,IAAM,OAAO;AAEb,IAAM,OAAiC,MAAM;AAAA;AA8G7C,IAAM,iBAAiB,OAAO,UAAU,SAAS,KAAK,KAAK,OAAO,UAAU;AAAA;AAAA;;;AC1G5E,oBAA0B,OAAU,QAAoC,KAAmB;AAC/F,MAAI,OAAO,QAAQ;AAChB,WAAO;AAAA;AAEV,SAAQ,UAAU,SAAS,IAAK,MAAM;AAAA;AAOlC,0BAA0B,OAAgB,MAAoE;AAClH,SAAO,wBAAwB,KAAK,OAAO,UAAW,EAAC,QAAQ,CAAC,KAAK,SAAU,OAAO;AAAA;AAgBlF,2BAA6C,OAAgC;AACjF,SAAO,CAAC,CAAC,SAAS,eAAe,WAAW;AAAA;AAGxC,wBAAwB,OAAmC;AAC/D,SAAO,OAAO,UAAU;AAAA;AA1C3B,IAgBa,aAQA,cAIA,mBAIA,2BAaA;AA7Cb;AAAA;AACA;AAeO,IAAM,cAAmD,CAAC,UAA+B;AAC7F,aAAO,MAAM,QAAQ;AAAA;AAOjB,IAAM,eAAgD,CAAC,UAA2B;AACtF,aAAO,OAAO,UAAU;AAAA;AAGpB,IAAM,oBAAuD,CAAC,UAA6B;AAC/F,aAAO,MAAM,QAAQ,UAAU,MAAM,MAAM;AAAA;AAGvC,IAAM,4BAAwE,CAAC,UAAsC;AACzH,aAAO,aAAa,UAAW,MAAM,QAAQ,UAAU,MAAM,MAAM;AAAA;AAY/D,IAAM,kBAA+D,CAAC,UAAuC;AACjH,UAAI,SAAS,QAAQ,0BAA0B,SAAS,OAAO,QAAQ;AACpE,eAAO;AAAA;AAEV,aAAO,MAAM,QAAQ,UAAU,OAAO,UAAU,YAAY,OAAO,MAAM,WAAW;AAAA;AAAA;AAAA;;;ACjDvF,IAIY;AAJZ;AAAA;AAIO,IAAK,YAAL,kBAAK,eAAL;AACJ;AACA;AACA,yCAAU,OAAV;AAHS;AAAA;AAAA;AAAA;;;ACJZ,IAEO;AAFP;AAAA;AAEO,6BAA8D;AAAA,MAElE,YAA4B,QAA2B,QAAW;AAAtC;AAA2B;AAAA;AAAA,MAGvD,YAAsC;AACnC,eAAO,IAAI,iBAAiB,KAAK,OAAO,SAAS,SAAS,KAAK,OAAO,SAAS;AAAA;AAAA;AAAA;AAAA;;;ACRrF,IAAO,YAsDA;AAtDP;AAAA;AAAO,uBAAoB;AAAA,MAMxB,YACG,QACA,YACD;AAPQ,uBAAoB;AAc9B,qBAAQ,CAAC,MAAgD,WAAuB;AAC7E,eAAK;AAEL,cAAI,CAAC,KAAK,QAAQ,MAAM,CAAC,KAAK,UAAU,KAAK,SAAS,KAAK,OAAO,KAAK,UAAU;AAC9E,mBAAO;AAAA;AAGV,iBAAO,KAAK,WAAW,QAAQ,KAAK,sBAAsB;AAAA;AAb1D,aAAK,UAAU,MAAM,QAAQ,UAAU,SAAS,CAAC;AACjD,YAAI,YAAY;AACb,eAAK,aAAa;AAAA;AAAA;AAAA,MAed,WAAW,QAAW,OAAiC;AAC9D,cAAM,IAAI,MAAM;AAAA;AAAA,MAGT,eAAe;AACtB,aAAK,QAAQ,SAAS;AAAA;AAAA,MAGf,iBAAiB;AACxB,eAAO,KAAK;AAAA;AAAA,MAGL,SAAS,KAAa,OAAe,MAAe;AAC3D,cAAM,UAAU,QAAQ,IAAI,KAAK;AACjC,YAAI,SAAS;AACV,eAAK,UAAU,OAAO;AAAA;AAGzB,eAAO,CAAC,CAAC;AAAA;AAAA,MAGF,UAAU,QAAgB,SAAmB;AACpD,aAAK,QAAQ,KAAK,GAAG,QAAQ,MAAM;AAAA;AAAA;AAKlC,qCAAkC,WAAc;AAAA,MAE1C,SAAS,KAAa,OAAe,MAAwB;AACpE,eAAO,aAAa,KAAK,OAAO,UAAU,MAAM,SAAS,KAAK,OAAO;AAAA;AAAA,MAG9D,UAAU,OAAe,SAAmB;AACnD,YAAI,QAAQ,KAAK,QAAQ,SAAS,GAAG;AAClC,gBAAM,UAAU,OAAO;AAAA;AAAA;AAAA;AAAA;AAAA;;;ACtDzB,iCAAiC,SAAyE;AAC9G,QAAM,UAAU,QAAQ;AACxB,QAAM,SAA2B,OAAO,OAAO,iBAAC,WAAY,iBACzD,GAAI,QAAQ,OAAO,OAAK,OAAO,MAAM,YAAY;AAGpD,SAAO,UAAU,OAAO,WAAW;AAEnC,SAAO;AAAA;AAhBV,IAEM;AAFN;AAAA;AAEA,IAAM,iBAAoD;AAAA,MACvD,QAAQ;AAAA,MACR,wBAAwB;AAAA,MACxB,QAAQ;AAAA;AAAA;AAAA;;;ACDJ,2BAAwD,SAAmB,WAAqB,IAAc;AAClH,MAAI,CAAC,kBAA2B,UAAU;AACvC,WAAO;AAAA;AAGV,SAAO,OAAO,KAAK,SAAS,OAAO,CAAC,WAAoB,QAAgB;AACrE,UAAM,QAAuB,QAAQ;AAErC,QAAI,iBAAiB,OAAO,CAAC,aAAa;AACvC,gBAAS,KAAK,MAAM,MAAM;AAAA,WACtB;AACJ,gBAAS,KAAK;AAAA;AAGjB,WAAO;AAAA,KACP;AAAA;AAGC,4BAA4B,MAAkB,mBAAmB,GAAG,aAAa,OAAiB;AACtG,QAAM,UAAoB;AAE1B,WAAS,IAAI,GAAG,MAAM,mBAAmB,IAAI,KAAK,SAAS,kBAAkB,IAAI,KAAK,KAAK;AACxF,QAAI,gBAAgB,SAAS,OAAO,KAAK,KAAK;AAC3C,cAAQ,KAAK,OAAO,KAAK;AAAA;AAAA;AAI/B,oBAAkB,wBAAwB,OAAO;AACjD,MAAI,CAAC,YAAY;AACd,YAAQ,KAAK,GAAG,sBAAsB;AAAA;AAGzC,SAAO;AAAA;AAGV,+BAA+B,MAAkB;AAC9C,QAAM,sBAAsB,OAAO,KAAK,UAAU;AAClD,SAAO,WACJ,KAAK,MAAM,sBAAsB,IAAI,IAAI,aAAa;AAAA;AAQrD,iCAAiC,MAAkC;AACvE,QAAM,sBAAsB,eAAe,KAAK;AAChD,SAAO,WAAW,KAAK,MAAM,sBAAsB,IAAI,IAAI;AAAA;AAOvD,kCAAkC,MAAwC,cAAc,MAA0C;AACtI,QAAM,WAAW,WAAW,KAAK;AACjC,SAAO,eAAe,eAAe,YAAY,WAAW;AAAA;AA7D/D;AAAA;AAAA;AACA;AAAA;AAAA;;;ACIO,wBAAoE,SAAqC,SAAkC;AAC/I,SAAO,QAAO,QAAQ,QAAQ,QAAQ;AAAA;AAGlC,6BAAgC,QAAW,cAA6B,OAAoB;AAChG,QAAM,QAAQ,UAAQ;AACnB,aAAS,QAAQ,mBAAmB,OAAO,IAAI,GAAG,MAAM,MAAM,QAAQ,IAAI,KAAK,KAAK;AACjF,YAAM,OAAO,CAAC,SAAS,MAAM;AAC1B,YAAK,IAAI,UAAW,KAAK;AACtB;AAAA;AAEH,eAAO,MAAM,IAAI;AAAA;AAGpB,gBAAQ,KAAK,CAAC,EAAC,YAAW,MAAM,MAAM;AAAA;AAAA;AAI5C,SAAO;AAAA;AAvBV;AAAA;AAGA;AAAA;AAAA;;;ACHA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;;;ACRA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAqBO,yBAAyB,QAAsD;AACnF,UAAQ;AAAA,SACA;AACF,aAAO;AAAA,SACL;AACF,aAAO;AAAA;AAGb,QAAM,WAAW,CAAC,aAAa;AAE/B,SAAO;AAAA,IACJ;AAAA,IACA,QAAQ;AAAA,IACR;AAAA,IACA;AAAA;AAAA;AAKC,+BAAoD;AACxD,QAAM,WAAW,CAAC,aAAa;AAE/B,SAAO;AAAA,IACJ;AAAA,IACA,QAAQ;AAAA,IACR;AAAA,IACA,OAAO,MAAM;AACV,aAAO,aAAa,KAAK,KAAK;AAAA;AAAA;AAAA;AAMhC,+BAAoD;AACxD,QAAM,WAAW,CAAC,aAAa;AAE/B,SAAO;AAAA,IACJ;AAAA,IACA,QAAQ;AAAA,IACR;AAAA,IACA;AAAA;AAAA;AAKN,0BAA0B,OAAuB;AAC9C,SAAO,8CAA8C,KAAK,OAAO;AAAA;AAnEpE,IAGY,kBAMN,SAQA;AAjBN;AAAA;AAAA;AAGO,IAAK,mBAAL,kBAAK,sBAAL;AACJ,kCAAO;AACP,qCAAU;AACV,0CAAe;AAHN;AAAA;AAMZ,IAAM,UAA0C,CAAC,EAAC,YAAW,OAAO,MAAM,SAAS;AAChF,UAAI,aAAa,qBAAqB,iBAAiB,QAAQ;AAC5D,eAAO,KAAK,OAAO,KAAK;AAAA;AAG3B,WAAK;AAAA;AAGR,IAAM,SAAwC,CAAC,SAAS;AACrD,aAAO,KAAK,WAAW;AAAA;AAAA;AAAA;;;ACCnB,4BAA6B,QAAiB,MAA4B;AAC9E,QAAM,UAAU,IAAI,cAAc;AAClC,QAAM,SAAS,SAAS,sBAAsB;AAE9C,qBAAmB,MAAM,QAAQ,UAAQ;AACtC,UAAM,UAAU,KAAK,QAAQ,QAAQ;AAErC,YAAQ,MAAM,KAAK;AACnB,IAAC,gBAAe,KAAK,WAAW,QAAQ,UAAU,QAAQ,OAAO,KAAK;AAAA;AAGzE,SAAO;AAAA;AA9BV,IAGO,eAYD,eACA,qBACA;AAjBN;AAAA;AACA;AAEO,0BAA4C;AAAA,MAMhD,YACmB,QACjB;AADiB;AALZ,qBAAkB;AAClB,qBAAkB;AAClB,uBAAoB;AAAA;AAAA;AAQ9B,IAAM,gBAAgB;AACtB,IAAM,sBAAsB;AAC5B,IAAM,iBAAiB;AAAA;AAAA;;;ACjBvB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAaO,uBAAuB,SAAoC;AAC/D,SAAO;AAAA,IACJ,UAAU;AAAA,IACV,QAAQ;AAAA,IACR;AAAA;AAAA;AAIC,gCAAgC,OAAkC;AACtE,SAAO;AAAA,IACJ,UAAU;AAAA,IACV,QAAQ;AAAA,IACR,SAAS;AACN,YAAM,OAAO,UAAU,WAAW,IAAI,uBAAuB,SAAS;AAAA;AAAA;AAAA;AAKxE,mCAAmC,UAAoB,WAAU,OAA2B;AAChG,SAAO;AAAA,IACJ;AAAA,IACA,QAAQ;AAAA,IACR,OAAO,MAAM;AACV,aAAO,WAAU,OAAO,MAAM,SAAS;AAAA;AAAA;AAAA;AAKzC,mCAAmC,UAAqC;AAC5E,SAAO;AAAA,IACJ;AAAA,IACA,QAAQ;AAAA,IACR,OAAO,QAAQ;AACZ,aAAO;AAAA;AAAA;AAAA;AAKT,sBAAyB,MAA+C;AAC5E,SAAO,KAAK,WAAW;AAAA;AAGnB,qBAAwB,MAA2C;AACvE,SAAO,KAAK,WAAW,WAAW,CAAC,KAAK,SAAS;AAAA;AAxDpD,IAGa;AAHb;AAAA;AAAA;AAGO,IAAM,iBAAqB;AAAA;AAAA;;;ACHlC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AA+BO,8BAA8B,MAA0B,YAAsB;AAClF,QAAM,EAAC,WAAW,SAAS,UAAS,gBAAgB;AAEpD,MAAI,CAAC,WAAW;AACb,WAAO,uBAAuB;AAAA;AAGjC,MAAI,CAAC,MAAM,SAAS;AACjB,WAAO,uBAAuB,8BAA8B,KAAK,UAAU;AAAA;AAG9E,UAAQ,KAAK,GAAG;AAEhB,MAAI,QAAQ,KAAK,oBAAoB;AAClC,WAAO,uBAAuB;AAAA;AAGjC,SAAO,UAAU,WAAW;AAAA;AAGxB,mBAAmB,MAAiB,YAAgD;AACxF,QAAM,WAAqB,CAAC,SAAS,IAAI,QAAQ,GAAG;AAEpD,SAAO;AAAA,IACJ;AAAA,IACA,QAAQ;AAAA,IACR,OAAO,MAA4B;AAChC,aAAO,mBAAmB,SAAS,mBAAsB;AAAA;AAAA;AAAA;AAK3D,6BAA8B,OAA0C;AAC5E,SAAO,MAAM,QAAQ,UAAU,MAAM,MAAM,UAAQ,kBAAkB,IAAI;AAAA;AAG5E,yBAAyB,OAAe;AACrC,MAAI;AACJ,MAAI,UAAoB;AACxB,MAAI,QAAQ,EAAC,WAAW,OAAO,SAAS;AAExC,QAAM,QAAQ,YAAY,IAAI,MAAM,IAAI,QAAQ,UAAQ;AACrD,QAAI,YAAY,OAAO;AACpB,kBAAY;AACZ,YAAM,YAAY;AAAA,WAEhB;AACF,YAAM,UAAU,MAAM,WAAW,cAAc,QAAQ,QAAQ,UAAW,IAAI;AAAA;AAAA;AAIpF,SAAO;AAAA,IACJ;AAAA,IACA;AAAA,IACA;AAAA;AAAA;AAIN,qBAAqB,WAA4C;AAC9D,SAAO,cAAc,mBAAsB,cAAc;AAAA;AAG5D,uBAAuB,QAAyB;AAC7C,SAAO,YAAY,KAAK,WAAW,kBAAkB,IAAI,OAAO,OAAO;AAAA;AAG1E,2BAA2B,QAAyB;AACjD,MAAI,UAAU,KAAK,SAAS;AACzB,WAAO,OAAO,QAAQ,OAAO;AAAA;AAGhC,SAAO,WAAW;AAAA;AAtGrB,IAMa,+BACA,4BACA,6BAKD,cAgBN;AA7BN;AAAA;AACA;AAEA;AACA;AAEO,IAAM,gCAAgC;AACtC,IAAM,6BAA6B;AACnC,IAAM,8BAA8B;AAKpC,IAAK,eAAL,kBAAK,kBAAL;AACJ,iCAAU;AACV,+BAAQ;AACR,0CAAmB;AACnB,sCAAe;AACf,mCAAY;AACZ,+BAAQ;AACR,mCAAY;AAPH;AAAA;AAgBZ,IAAM,oBAAiC,oBAAI,IAAI,CAAC,KAAK,GAAG,cAAc,OAAO,OAAO;AAAA;AAAA;;;ACkB7E,0BAA0B,MAA0B;AACxD,QAAM,SAAS,IAAI;AAEnB,aAAW,QAAQ,aAAa,OAAO;AACpC,WAAO,SAAS,KAAK,MAAM,OAAO,KAAK,MAAM,KAAK;AAAA;AAGrD,SAAO;AAAA;AAGH,yBAAyB,MAAc,KAA8B;AACzE,MAAI,QAAuB;AAC3B,QAAM,SAAmB;AACzB,QAAM,SAAgC,oBAAI;AAE1C,aAAW,QAAQ,aAAa,MAAM,MAAM;AACzC,QAAI,KAAK,QAAQ,KAAK;AACnB;AAAA;AAGH,WAAO,KAAK,QAAQ,KAAK;AAEzB,QAAI,CAAC,OAAO,IAAI,KAAK,OAAO;AACzB,aAAO,IAAI,KAAK,MAAM;AAAA;AAGzB,WAAO,IAAI,KAAK,MAAO,KAAK;AAAA;AAG/B,SAAO;AAAA,IACJ;AAAA,IACA,OAAO,MAAM,KAAK,OAAO;AAAA,IACzB;AAAA,IACA;AAAA,IACA;AAAA;AAAA;AAIN,wBAAwB,UAA0B;AAC/C,SAAO,SAAS,QAAQ,YAAY;AAAA;AAGvC,uBAAuB,MAAc,eAA8B,MAAM;AACtE,QAAM,QAAQ,KAAK,MAAM;AAEzB,WAAS,IAAI,GAAG,MAAM,MAAM,SAAS,GAAG,IAAI,OAAM;AAC/C,UAAM,OAAO,eAAe,MAAM;AAElC,QAAI,QAAQ,MAAM;AAClB,QAAI,MAAM;AAEV,QAAI,MAAM,SAAS,OAAO;AACvB,YAAM,OAAO,QAAQ,OAAO;AAC5B,YAAM,KAAK;AACX,cAAQ,KAAK;AAAA;AAGhB,UAAM,EAAC,MAAM,KAAK;AAAA;AAAA;AAxGxB,IAGO;AAHP;AAAA;AACA;AAEO,uBAA8C;AAAA,MAA9C,cAHP;AAKU,qBAAkB;AAClB,sBAA+C,uBAAO,OAAO;AAAA;AAAA,UAIzD,MAAoB;AAC5B,YAAI,CAAC,KAAK,MAAM;AACb,eAAK,OAAO,KAAK,MAAM,OAAO,CAAC,KAAmB,SAAiB;AAChE,mBAAO,OAAO,OAAO,KAAK,KAAK,OAAO;AAAA,aACtC;AAAA;AAGN,eAAO,KAAK;AAAA;AAAA,MAGR,QAAQ,MAA4B;AACxC,YAAI,CAAE,SAAQ,KAAK,SAAS;AACzB,gBAAM,SAAS,KAAK,KAAK;AACzB,eAAK,OAAO,QAAQ,SAAS,OAAO,OAAO,KAAK,OAAO,WAAW;AAElE,eAAK,MAAM,KAAK;AAAA;AAGnB,eAAO,KAAK,OAAO;AAAA;AAAA,MAGf,SAAS,MAAc,KAAa,OAAe;AACvD,cAAM,SAAS,KAAK,QAAQ;AAE5B,YAAI,CAAC,OAAO,eAAe,MAAM;AAC9B,iBAAO,OAAO;AAAA,mBACN,MAAM,QAAQ,OAAO,OAAO;AACpC,UAAC,OAAO,KAAkB,KAAK;AAAA,eAC3B;AACJ,iBAAO,OAAO,CAAC,OAAO,MAAgB;AAAA;AAGzC,aAAK,OAAO;AAAA;AAAA;AAAA;AAAA;;;AC7BlB,uBAA6D,OAAiC,UAAiC;AAC5H,MAAI,OAAO,UAAU,YAAY,eAAe,eAAe,QAAQ;AACpE,WAAO;AAAA;AAEV,SAAO;AAAA;AAGV,uBAAuB,KAAa,OAAe,SAAiB,OAA2C;AAC5G,QAAM,WAAqB,CAAC,UAAU,KAAK;AAE3C,MAAI,SAAQ;AACT,aAAS,KAAK;AAAA;AAGjB,WAAS,KAAK,KAAK;AAEnB,SAAO;AAAA,IACJ;AAAA,IACA,QAAQ;AAAA,IACR,OAAO,MAAsB;AAC1B,aAAO;AAAA;AAAA;AAAA;AAKhB,uBAAuB,KAAa,OAAqD;AACtF,QAAM,WAAqB,CAAC,UAAU,UAAU,iBAAiB,aAAa;AAE9E,MAAI,OAAO;AACR,aAAS,OAAO,GAAG,GAAG,KAAK;AAAA;AAG9B,SAAO;AAAA,IACJ;AAAA,IACA,QAAQ;AAAA,IACR,OAAO,MAAM;AACV,aAAO,gBAAgB,MAAM;AAAA;AAAA;AAAA;AAKtC,wBAAwB,OAAuD;AAC5E,QAAM,WAAW,CAAC,UAAU,UAAU,iBAAiB;AAEvD,MAAI,OAAO;AACR,aAAS,KAAK,KAAK;AAAA;AAGtB,SAAO;AAAA,IACJ;AAAA,IACA,QAAQ;AAAA,IACR,OAAO,MAAc;AAClB,aAAO,iBAAiB;AAAA;AAAA;AAAA;AAKlB,0BAAuE;AACnF,SAAO;AAAA,IACJ,UAA8B,KAAa,UAAkB,MAAiB;AAC3E,aAAO,KAAK,SACT,cAAc,KAAK,OAAO,KAAK,OAAO,MAAM,cAAc,KAAK,IAAI,uBACnE,yBAAyB;AAAA;AAAA,IAI/B,UAA8B,KAAa,OAAwB;AAChE,aAAO,KAAK,SACT,cAAc,KAAK,cAAc,OAAO,UACxC,yBAAyB;AAAA;AAAA,IAI/B,cAAkC,MAAiB;AAChD,aAAO,KAAK,SACT,eAAe,cAAc,KAAK,IAAI,UACtC,yBAAyB;AAAA;AAAA;AAAA;AAzFrC,IAMY;AANZ;AAAA;AACA;AAGA;AAEO,IAAK,iBAAL,kBAAK,oBAAL;AACJ,kCAAS;AACT,kCAAS;AACT,iCAAQ;AACR,oCAAW;AAJF;AAAA;AAAA;AAAA;;;AC0CL,6BAA6B,QAAgC;AACjE,SAAO,IAAI,YAAY,MAAM,GAAG;AAAA;AAGnC,mBAAmB,MAA0B;AAC1C,QAAM,QAA6B,oBAAI;AACvC,QAAM,UAAiC;AAEvC,yBAAuB,MAAM,CAAC,UAAU;AACrC,UAAM,CAAC,MAAM,MAAM,WAAW,MAAM,MAAM;AAC1C,UAAM,IAAI;AACV,IAAC,SAAQ,QAAQ,QAAQ,SAAS,IAAI,KAAK;AAAA,MACxC,MAAM,SAAS;AAAA,MACf;AAAA,MACA;AAAA;AAAA;AAIN,SAAO;AAAA,IACJ;AAAA,IACA;AAAA;AAAA;AAIS,wBAAqC;AACjD,SAAO;AAAA,IACJ,KAAyB,YAAmC;AACzD,YAAM,OAAO,yBAAyB;AACtC,YAAM,UAAU,mBAAmB;AAEnC,iBAAW,UAAU,mBAAmB;AACrC,YAAI,QAAQ,SAAS,SAAS;AAC3B,iBAAO,KAAK,SACT,uBAAuB,qBAAqB,8BAC5C;AAAA;AAAA;AAKT,UAAI,OAAO,eAAe,UAAU;AACjC,qBAAa,mBAAmB,MAAM;AAAA;AAGzC,YAAM,WAAW,CAAC,QAAQ,UAAU,MAAM,eAAe,GAAG,SAAS,GAAG;AAExE,aAAO,KAAK,SAAS;AAAA,QAClB;AAAA,QACA,QAAQ;AAAA,QACR,OAAO,QAAQ;AACZ,iBAAO,UAAU;AAAA;AAAA,SAEpB;AAAA;AAAA;AAAA;AAnGZ,IAaM,mBAEA,OAfN,IAyBA;AAzBA;AAAA;AAEA;AASA;AAEA,IAAM,oBAAoB,CAAC;AAE3B,IAAM,QAAQ,OAAO;AAUrB,sBAAwC;AAAA,MAAxC,cAzBA;AA0BY,mBAAmB;AAAA;AAAA,QAAnB,aAEN,OAAO,aAAY;AACnB,mBAAW,SAAS,KAAK,QAAQ;AAC9B,gBAAM;AAAA;AAAA;AAAA,MAIZ,OAAO,KAAe;AACnB,YAAI,UAAU,KAAK,OAAO,KAAK,SAAS,KAAK,GAAG,cAAc,KAAK,OAAO;AAC1E,eAAO;AAAA;AAAA,MAGV,SAAS,OAAiB;AACvB,aAAK,OAAO,KAAK,GAAG,cAAc,OAAO;AACzC,eAAO;AAAA;AAAA;AAAA;AAAA;;;ACzCb;AAAA;AAAA;AAAA;AAAA;AAAA;AAiBO,mBAAmB,MAAwB,YAAsB;AACrE,QAAM,WAAqB,CAAC;AAC5B,MAAI,iBAAiB,OAAO;AACzB,aAAS,KAAK,KAAK;AAAA;AAEtB,WAAS,KAAK,GAAG;AAEjB,SAAO,0BAA0B;AAAA;AAG7B,sBAAsB,MAAyC;AACnE,MAAI,iBAAiB,OAAO;AACzB,WAAO;AAAA;AAGV,UAAQ,OAAO;AAAA,SACP;AAAA,SACA;AACF,aAAO;AAAA;AAGb;AAAA;AAGH,0BAA0B,MAA0C;AACjE,SAAO,WAAW,SAAS;AAAA;AA1C9B,IAGY,WAQN;AAXN;AAAA;AAAA;AAGO,IAAK,YAAL,kBAAK,eAAL;AACJ,4BAAQ;AACR,2BAAO;AACP,2BAAO;AACP,4BAAQ;AACR,2BAAO;AALE;AAAA;AAQZ,IAAM,aAAa,MAAM,KAAK,OAAO,OAAO;AAAA;AAAA;;;ACX5C;AAcA,qBAAsB;AACnB,SAAO,MAAM;AAAA;AAWhB,wBAAyB,IAAc,QAAgB,SAAsD;AAC1G,MAAI,CAAC,UAAU,CAAC,OAAO,QAAQ,QAAQ,OAAO,KAAK;AAChD,WAAO,CAAC,UAAU,KAAK,CAAC,YAAY,SAAS;AAC1C,SAAG,SAAS,GAAG;AACf,cAAQ,SAAS,GAAG;AAAA;AAAA;AAI1B,SAAO,CAAC,YAAY,SAAS;AAC1B,OAAG,MAAM,WAAW,QAAQ,GAAG;AAC/B,QAAI,SAAS;AACV,cAAQ,SAAS,GAAG;AAAA;AAAA;AAAA;AAK7B,yBAA0B,MAAqB,eAAgC,EAAC,WAAW,mBAAoC;AAC5H,MAAI,OAAO,SAAS,UAAU;AAC3B,WAAO;AAAA;AAEV,QAAM,iBAAiB,iBAAiB,cAAc,aAAa;AAEnE,MAAI,eAAe,WAAW,kBAAkB;AAC7C,WAAO,eAAe,OAAO,gBAAgB,SAAS;AAAA;AAGzD,SAAO,kBAAkB;AAAA;AAGrB,sBAAuB,OAAe,SAA6B,aAAsB,eAAe,aAA2B;AACvI,QAAM,cAAc,SAAS,IAAI,YAAY;AAE7C,QAAM,UAA0B;AAChC,QAAM,gBAAkC,OAAO,YAAY,WAAY,aAAa,OAAO,WAAW;AACtG,QAAM,MAAM,gBAAgB,WAAW,SAAS,eAAe,eAAe;AAE9E,SAAO,KAAK;AAEZ,mBAAiB,MAAc,SAAkB;AAC9C,WAAO,OAAO,SAAS,aAAa,OAAO,IAAI,QAAQ,UAAU,OAAO,SAAS;AAAA;AAGpF,gBAAc,OAAgB;AAC3B,UAAM,aAAa,SAAS,IAAI,YAAY;AAC5C,UAAM,SAAQ,iBAAiB,eAAe,eAAe,eAAe;AAC5E,UAAM,OAAO,eAAe,cAAc,GAAG,eAAgB,cAAc;AAE3E,WAAO,OAAO,OAAO,gBAAgB,SAAQ,MAAM;AAAA,MAChD;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA;AAAA;AAAA;AA7ET;AAAA;AACA;AAGA,UAAM,WAAW,IAAI,CAAC,UAAe,OAAO,gBAAgB,SAAS,MAAM,SAAS;AACpF,UAAM,WAAW,IAAI,CAAC,UAAkB;AACrC,UAAI,OAAO,SAAS,QAAQ;AACzB,eAAO,MAAM,SAAS;AAAA;AAEzB,aAAO,eAAe;AAAA;AAAA;AAAA;;;ACTzB,IAYO;AAZP;AAAA;AACA;AACA;AAUO,+BAAwB;AAAA,MAI5B,YAAoB,WAAW,eAAe;AAA1B;AAFZ,sBAAgD,oBAAI;AAAA;AAAA,MAKpD,aAAa,MAAwB;AAC1C,eAAO,KAAK,OAAO,IAAI;AAAA;AAAA,MAGlB,eAAgB,MAAwC;AAC7D,cAAM,OAAO,mBAAkB,QAAQ,KAAK,SAAS;AACrD,cAAM,SAAS,aAAa,KAAK,UAAU;AAE3C,eAAO;AAAA,UACJ;AAAA,UACA;AAAA,UACA;AAAA;AAAA;AAAA,MAIN,KAAK,MAAwC;AAC1C,cAAM,WAAW,KAAK,eAAe;AACrC,iBAAS,OAAO,2CAA2C,KAAK;AAEhE,aAAK,OAAO,IAAI,MAAM;AAEtB,eAAO;AAAA;AAAA,MAGV,MAAM,KAAe;AAClB,mBAAW,CAAC,MAAM,EAAC,aAAY,MAAM,KAAK,KAAK,OAAO,YAAY;AAC/D,cAAI,SAAS,IAAI,MAAM;AACpB,mBAAO,KAAK,aAAa;AACzB,mBAAO;AAAA,iBACH;AACJ,mBAAO,KAAK,gFAAgF,IAAI;AAAA;AAGnG,eAAK,SAAS;AAAA;AAGjB,YAAI,KAAK,OAAO,SAAS,GAAG;AACzB,gBAAM,IAAI,MAAM,0CAA0C,KAAK,OAAO;AAAA;AAAA;AAAA,MAI5E,SAAS,MAAwB;AAC9B,cAAM,WAAW,KAAK,aAAa;AACnC,YAAI,UAAU;AACX,eAAK,OAAO,OAAO;AAAA;AAAA;AAAA,MAIzB,QAAQ,MAAwC;AAC7C,cAAM,WAAW,KAAK,aAAa;AACnC,YAAI,CAAC,UAAU;AACZ,gBAAM,IAAI,SAAS,QAAW;AAAA;AAEjC,iBAAS,OAAO;AAEhB,eAAO;AAAA;AAAA,aAGH,QAAS,OAAO,SAAS;AAC7B,eAAO,QAAQ,QAAQ,EAAE,mBAAkB;AAAA;AAAA;AAlE1C;AAqEW,IArEX,kBAqEW,UAAU;AAAA;AAAA;;;ACjF5B;AA2MA,uBAA0B,MAAwB,UAAoB;AACnE,SAAO;AAAA,IACJ,QAAQ,MAAM,KAAK,aAAa;AAAA,IAChC;AAAA;AAAA;AAIN,yBAAyB,QAAkB,QAAsB;AAC9D,SAAO,CAAC,QAAe;AACpB,WAAO,sCAAsC;AAC7C,WAAO,KAAK,OAAO,KAAK,OAAO,IAAI,QAAQ;AAAA;AAAA;AAIjD,wBAAwB,QAAkB,MAAc,QAAsB,QAAsB;AACjG,SAAO,CAAC,WAAmB;AACxB,WAAO,wBAAwB,MAAM;AACrC,WAAO,MAAM;AACb,WAAO,KAAK;AAAA;AAAA;AA7NlB,IAUO;AAVP;AAAA;AACA;AAGA;AAEA;AAEA;AAEO,6BAAoD;AAAA,MA0BxD,YACW,WACA,YACA,UACT;AAHS;AACA;AACA;AA3BH,sBAAuB,QAAQ;AAC/B,sBAAS,IAAI;AAAA;AAAA,UAGV,SAAS;AACjB,eAAO,KAAK,UAAU;AAAA;AAAA,UAGd,MAAM;AACd,eAAO,KAAK,QAAQ,KAAK,UAAU;AAAA;AAAA,UAG3B,IAAI,KAAa;AACzB,aAAK,OAAO;AAAA;AAAA,UAGJ,MAAM;AACd,eAAO,KAAK,UAAU;AAAA;AAAA,UAGd,gBAAgB;AACxB,eAAO,KAAK,UAAU;AAAA;AAAA,MAUlB,QAAQ;AACZ,eAAO;AAAA;AAAA,MAGH,KAAQ,MAAoC;AAChD,aAAK,OAAO,KAAK;AAEjB,eAAO,KAAK,SAAS,KAAK,OAAO,KAAK,MAAM,KAAK,YAAY;AAAA;AAAA,MAGlD,YAAe,MAA2C;AAAA;AACrE,gBAAM,qBAAqB,MAAM,KAAK,WAAW;AACjD,gBAAM,kBAAkB,MAAM,KAAK,OAAO,SAAS;AAEnD,cAAI;AACD,kBAAM,EAAC,WAAU,KAAK,OAAO,QAAQ;AACrC,mBAAO,MAAO,YAAY,QAClB,KAAK,iBAAiB,MAAM,UAC5B,KAAK,kBAAkB,MAAM;AAAA,mBAE/B,GAAP;AACC,kBAAM,KAAK,iBAAiB,MAAM;AAAA,oBACnC;AACC;AACA;AAAA;AAAA;AAAA;AAAA,MAIE,iBAAoB,MAAwB,GAAU;AAC3D,cAAM,WAAY,aAAa,WAAY,OAAO,OAAO,GAAG,EAAC,UAAS,IAAI,SAAS,MAAM,KAAK,OAAO;AAErG,aAAK,SAAS,QAAQ;AACtB,aAAK,OAAO,MAAM;AAElB,eAAO;AAAA;AAAA,MAGI,kBAAqB,MAAuB,QAAsB;AAAA;AAC7E,gBAAM,OAAO,KAAK,SAAS,KAAK,cAAc,CAAC,GAAG,KAAK,WAAW,cAAc,MAAM,KAAK;AAE3F,gBAAM,MAAM,MAAM,KAAK,YACpB,MACA,KAAK,QAAQ,MAAM,KAAK,eAAe,OAAO,KAAK;AAEtD,gBAAM,gBAAgB,MAAM,KAAK,eAAe,MAAM,MAAM,KAAK,OAAO,KAAK;AAE7E,iBAAO,6CAA6C,KAAK;AAEzD,cAAI,aAAa,OAAO;AACrB,mBAAO,eAAe,KAAK,QAAQ;AAAA;AAGtC,iBAAO,eAAe,KAAK,QAAQ,cAAc;AAAA;AAAA;AAAA,MAGtC,iBAAiB,MAAiB,QAAsB;AAAA;AACnE,iBAAO;AACP,iBAAO,KAAK,OAAO;AAAA;AAAA;AAAA,MAGd,eACL,MACA,MACA,QAA2B,QAAiD;AAE5E,cAAM,EAAC,UAAU,WAAW,QAAQ,WAAU;AAE9C,eAAO,IAAI,QAAQ,CAAC,MAAM,SAAS;AAChC,iBAAO,4DAA4D;AAEnE,gBAAM,EAAC,UAAS,KAAK,SAAS,KAAK,cAAc,EAAC,OAAO,aAAY,kCAC/D,cAAc,MAAM,QACpB;AAGN,cAAI,SAAS,KAAK,SAAS;AACxB,mBAAO,KAAK;AAEZ,mBAAO,KAAK,QACT,QACA,OACA,CAAC,cAAc;AACZ,qBAAO,KAAK;AACZ,qBAAO,8BAA8B,eAAe;AAEpD,mBAAK,IAAI,iBACN,MAAM,QAAQ,aAAa,OAAO,OAAO,aAAa,WACtD,OAAO,OAAO;AAAA,eAGpB;AAAA;AAIN,cAAI,OAAO;AACR,mBAAO,KAAK,yDAAyD,UAAU,OAAO,QAAQ;AAC9F,mBAAO,KAAK;AAAA;AAGf,iBAAO,KAAK;AACZ,eAAK,IAAI,iBACN,OAAO,OAAO,SACd,OAAO,OAAO;AAAA;AAAA;AAAA,MAKT,YAAe,MAAwB,SAAiB,MAAgB,eAAqC,QAAkD;AAAA;AAC1K,gBAAM,eAAe,OAAO,QAAQ;AACpC,gBAAM,eAA6B,KAAK,SAAS,KAAK,iBAAiB;AAAA,YACpE,KAAK,KAAK;AAAA,YACV,KAAK,KAAK;AAAA,YACV,aAAa;AAAA,aACb,cAAc,MAAM,KAAK;AAE5B,iBAAO,IAAI,QAAQ,CAAC,SAAS;AAC1B,kBAAM,SAAmB;AACzB,kBAAM,SAAmB;AAEzB,gBAAI;AAEJ,mBAAO,KAAK,SAAS,SAAS;AAC9B,mBAAO,MAAM;AACb,kBAAM,UAAU,MAAM,SAAS,MAAM;AAErC,oBAAQ,OAAQ,GAAG,QAAQ,eAAe,QAAQ,UAAU,QAAQ,aAAa,KAAK;AACtF,oBAAQ,OAAQ,GAAG,QAAQ,eAAe,QAAQ,UAAU,QAAQ,aAAa,KAAK;AAEtF,oBAAQ,GAAG,SAAS,gBAAgB,QAAQ;AAE5C,gBAAI,eAAe;AAChB,qBAAO;AACP,4BAAc,SAAS,QAAQ,QAAS,QAAQ,QAAS,CAAC,GAAG;AAAA;AAGhE,iBAAK,SAAS,KAAK,eAAe,QAAW,iCACvC,cAAc,MAAM,QADmB;AAAA,cAE1C;AAAA,cACA,MAAM,UAAkB,QAAgB;AACrC,qBAAK;AAAA,kBACF;AAAA,kBACA;AAAA,kBACA;AAAA,kBACA,WAAW,aAAa;AAAA;AAAA;AAAA,cAG9B,KAAK,QAAe;AACjB,oBAAI,QAAQ,QAAQ;AACjB;AAAA;AAGH,4BAAY;AACZ,wBAAQ,KAAK;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;ACnM5B;AAAA;AAAA;AAAA;AAAA,IAMO;AANP;AAAA;AAGA;AAGO,wBAA+C;AAAA,MAOnD,YACU,SAAiB,OACjB,KACC,YACA,UACT;AAJQ;AACA;AACC;AACA;AATH,sBAAS,IAAI,iBAAiB,MAAM,KAAK,YAAY,KAAK;AAAA;AAAA,MAalE,QAA2B;AACxB,eAAO,IAAI,iBAAiB,MAAM,KAAK,YAAY,KAAK;AAAA;AAAA,MAG3D,KAAQ,MAAoC;AACzC,eAAO,KAAK,OAAO,KAAK;AAAA;AAAA;AAAA;AAAA;;;ACrBvB,sBAAyB,MAAwB,UAAsB,WAAqC,MAAM;AAEtH,QAAM,YAAY,CAAC,SAAY;AAC5B,aAAS,MAAM;AAAA;AAGlB,QAAM,WAAU,CAAC,QAAqC;AACnD,QAAI,4BAAK,UAAS,MAAM;AACrB,eAAU,eAAe,mBAAoB,4BAA4B,OAAO,KAAK;AAAA;AAAA;AAI3F,WAAS,KAAK,WAAW;AAAA;AAI5B,qCAAsC,KAAuB;AAC1D,MAAI,MAAM,CAAC,SAAiB;AACzB,YAAQ,KAAK,6DAA6D,uCAAuC;AACjH,UAAM;AAAA;AAGT,SAAO,OAAO,OAAO,KAAK,OAAO,oBAAoB,IAAI,KAAK,OAAO,mBAAmB;AAExF,6BAA2B,KAA4B,MAA0B;AAC9E,QAAI,QAAQ,KAAK;AACd,aAAO;AAAA;AAGV,QAAI,QAAQ;AAAA,MACT,YAAY;AAAA,MACZ,cAAc;AAAA,MACd,MAAO;AACJ,YAAI;AACJ,eAAO,IAAI,IAAI;AAAA;AAAA;AAIrB,WAAO;AAAA;AAAA;AA3Cb;AAAA;AACA;AAEA;AAAA;AAAA;;;ACCO,oCAAqC,WAAmB,MAA0B;AACtF,SAAO,cAAc,CAAC,aAAgC;AACnD,QAAI,CAAC,aAAa,YAAY;AAC3B,YAAM,IAAI,MAAM,4CAA6C;AAAA;AAGhE,WAAS,SAAQ,UAAU,MAAM;AAAA;AAAA;AAVvC;AAAA;AAAA;AAEA;AAAA;AAAA;;;ACoCO,2BAA2B,QAA8B;AAC7D,QAAM,SAAuB;AAAA,IAC1B,QAAQ;AAAA,IACR,QAAQ;AAAA,IACR,QAAQ;AAAA,IACR,MAAM;AAAA,IACN,SAAS;AAAA,MACN,SAAS;AAAA,MACT,YAAY;AAAA,MACZ,WAAW;AAAA;AAAA;AAGjB,SAAO,oBAAoB,QAAQ,SAAS;AAAA;AAlD/C,IAGM;AAHN;AAAA;AACA;AAEA,IAAM,UAAsC;AAAA,MACzC,IAAI,WAAW,qCAAqC,CAAC,QAAQ,CAAC,QAAQ,MAAM,YAAY;AACrF,eAAO,SAAS;AAChB,eAAO,SAAS;AAChB,eAAO,OAAO,CAAC,CAAC;AAAA;AAAA,MAEnB,IAAI,WAAW,qBAAqB,CAAC,QAAQ,CAAC,YAAY;AACvD,cAAM,QAAQ,OAAO,MAAM;AAC3B,cAAM,QAAQ,MAAM;AAEpB,YAAI,CAAC,SAAS,CAAC,MAAM,SAAS,MAAM;AACjC;AAAA;AAGH,eAAO,SAAS;AAAA,UACb,OAAO,MAAM,OAAO,GAAG,MAAM,SAAS;AAAA,UACtC,MAAM,MAAM,KAAK,KAAK;AAAA;AAAA;AAAA,MAG5B,IAAI,WAAW,8CAA8C,CAAC,QAAQ,CAAC,SAAS,YAAY,eAAe;AACxG,eAAO,QAAQ,UAAU,SAAS,SAAS,OAAO;AAClD,eAAO,QAAQ,aAAa,SAAS,YAAY,OAAO;AACxD,eAAO,QAAQ,YAAY,SAAS,WAAW,OAAO;AAAA;AAAA,MAEzD,IAAI,WAAW,0CAA0C,CAAC,QAAQ,CAAC,SAAS,OAAO,eAAe;AAC/F,eAAO,QAAQ,UAAU,SAAS,SAAS,OAAO;AAClD,cAAM,QAAQ,SAAS,OAAO,OAAO;AACrC,YAAI,cAAc,KAAK;AACpB,iBAAO,QAAQ,YAAY;AAAA,mBACnB,cAAc,KAAK;AAC3B,iBAAO,QAAQ,aAAa;AAAA;AAAA;AAAA;AAAA;AAAA;;;ACjCrC;AAAA;AAAA;AAAA;AAAA;AAcO,oBAAoB,SAAmB,OAAiB,YAAgD;AAC5G,QAAM,WAAqB;AAAA,IACxB;AAAA,IACA;AAAA,IACA;AAAA,IACA,GAAG,cAAc,SAAS;AAAA,IAC1B,GAAG;AAAA,IACH,GAAG;AAAA;AAGN,SAAO;AAAA,IACJ;AAAA,IACA,QAAQ;AAAA,IACR,QAAQ;AAAA;AAAA;AAIC,0BAAuC;AACnD,SAAO;AAAA,IACJ,OAA2B,YAA+B,MAAiB;AACxE,YAAM,OAAO,yBAAyB;AACtC,YAAM,OAAO,2BAA2B,YACrC,WACG,QAAQ,UACR,QAAQ,WAAW,KAAK,IAAI,2BAA2B,MACvD,CAAC,GAAG,WAAW,KAAK,IAAI,aAAa,KAAK,GAAG,mBAAmB,WAAW,GAAG;AAGpF,aAAO,KAAK,SAAS,MAAM;AAAA;AAAA;AAIjC,sCAAoC,SAAmB;AACpD,WACG,CAAC,0BAA0B,YAC3B,uBAAuB;AAAA;AAAA;AAjDhC;AAAA;AAGA;AACA;AAQA;AAAA;AAAA;;;ACNO,wBAAwB,UAAkB,OAAoC;AAClF,QAAM,WAAW,CAAC,eAAe;AACjC,MAAI,OAAO;AACR,aAAS,KAAK;AAAA;AAGjB,SAAO,0BAA0B,UAAU;AAAA;AAZ9C;AAAA;AAAA;AAAA;AAAA;;;ACcO,mBAAmB,MAAe,MAAc,MAAc;AAClE,QAAM,WAAW,OAAO,MAAM;AAC9B,MAAI;AAEJ,MAAK,SAAS,kBAAkB,KAAK,WAAY;AAC9C,WAAO,IAAI,YAAY,MAAM,MAAM,OAAO,OAAO;AAAA;AAGpD,MAAK,SAAS,oBAAoB,KAAK,WAAY;AAChD,WAAO,IAAI,YAAY,MAAM,MAAM,MAAM,OAAO;AAAA;AAGnD,MAAI,SAAS;AACb,QAAM,SAAS,SAAS,MAAM;AAC9B,SAAO,OAAO,QAAQ;AACnB,UAAM,QAAQ,OAAO;AACrB,QAAI,UAAU,MAAM;AACjB,eAAS,OAAO,KAAK;AACrB;AAAA;AAAA;AAIN,SAAO,IAAI,YAAY,MAAM,MAAM,OAAO,KAAK,WAAW;AAAA;AApC7D,IAEO,aASD,mBACA;AAZN;AAAA;AAEO,wBAAwC;AAAA,MAC5C,YACmB,MACA,MACA,UACA,QACjB;AAJiB;AACA;AACA;AACA;AAAA;AAAA;AAItB,IAAM,oBAAoB;AAC1B,IAAM,sBAAsB;AAAA;AAAA;;;ACN5B,wBAAwB,SAAmB;AACxC,SAAO,QAAQ,SAAS;AAAA;AAGpB,kBAAkB,OAAO,OAAO,MAAc,YAA8C;AAChG,QAAM,WAAW,CAAC,QAAQ,GAAG;AAC7B,MAAI,QAAQ,CAAC,eAAe,WAAW;AACpC,aAAS,OAAO,GAAG,GAAG;AAAA;AAGzB,SAAO;AAAA,IACJ;AAAA,IACA,QAAQ;AAAA,IACR,OAAO,MAA0B;AAC9B,aAAO,UAAU,SAAS,SAAS,WAAW,MAAM;AAAA;AAAA;AAAA;AApB7D,IAIM;AAJN;AAAA;AACA;AAGA,IAAM,cAAc;AAAA;AAAA;;;ACJpB,IAKO;AALP;AAAA;AAKO,wBAAwC;AAAA,MAAxC,cALP;AAMG,uBAAU;AACV,yBAAY;AACZ,0BAAa;AAEb,qBAA0D;AAAA;AAAA;AAAA;AAAA;;;ACPtD,yBAAyB,QAA4B;AACzD,QAAM,QAAQ,OAAO,OAAO,MAAM;AAClC,QAAM,SAAS,IAAI;AACnB,kBAAgB,QAAQ,MAAM;AAE9B,WAAS,IAAI,GAAG,MAAM,MAAM,QAAQ,IAAI,KAAK,KAAK;AAC/C,UAAM,OAAO,MAAM;AACnB,mBAAe,MAAM,WAAW,iBAAiB,MAAM;AAAA;AAG1D,SAAO;AAAA;AAGV,yBAAyB,QAAoB,SAAkB;AAC5D,EAAC,YAAW,IACR,OACA,MAAM,MACN,QAAQ,SAAU,MAAc;AAC9B,UAAM,WAAU,kBAAkB,KAAK;AACvC,QAAI,CAAC,UAAS;AACX;AAAA;AAGH,gBAAY,QAAQ,SAAQ,IAAI,SAAS,SAAQ,IAAI;AAAA;AAAA;AAI9D,qBAAsB,QAAoB,KAAa,OAAe;AACnE,QAAM,QAAS,gBAAgB,KAAK;AACpC,MAAI,CAAC,SAAS,CAAC,aAAa,MAAM,KAAK;AACpC;AAAA;AAGH,eAAa,MAAM,IAAI,QAAQ;AAAA;AAelC,wBAAwB,OAAe,EAAC,SAAoB;AACzD,QAAM,OAAO,MAAM,OAAO,MAAM;AAEhC,MAAI,MAAM;AACP,QAAI,cAAe,MAAK,MAAM,IAAI;AAClC,UAAM,KAAK;AAAA,MACR,MAAM,KAAK,GAAG;AAAA,MACd,SAAS,SAAS,KAAK,IAAI;AAAA,MAC3B,YAAY,YAAY,QAAQ,MAAM,IAAI;AAAA,MAC1C,WAAW,YAAY,QAAQ,OAAO,IAAI;AAAA,MAC1C,QAAQ;AAAA;AAGX,WAAO;AAAA;AAGV,SAAO;AAAA;AAGV,0BAA0B,OAAe,EAAC,SAAoB;AAC3D,QAAM,OAAO,MAAM,MAAM;AACzB,MAAI,MAAM;AACP,UAAM,KAAK;AAAA,MACR,MAAM,KAAK,GAAG;AAAA,MACd,QAAQ,CAAC,KAAK;AAAA,MACd,OAAO,CAAC,KAAK;AAAA,MACb,QAAQ;AAAA;AAEX,WAAO;AAAA;AAEV,SAAO;AAAA;AAjFV,IAuCM;AAvCN;AAAA;AACA;AAsCA,IAAM,eAA6E;AAAA,MAChF,KAAM,QAAQ,OAAO;AAClB,eAAO,UAAU;AAAA;AAAA,MAEpB,SAAU,QAAQ,OAAO;AACtB,eAAO,YAAY;AAAA;AAAA,MAEtB,UAAW,QAAQ,OAAO;AACvB,eAAO,aAAa;AAAA;AAAA;AAAA;AAAA;;;ACnC1B,qBAAqB,QAAkB,QAAuB;AAC3D,SAAO,OAAO,OAAO,CAAC,MAAM,OAAO,UAAU;AAC1C,SAAK,SAAS,OAAO,UAAU;AAC/B,WAAO;AAAA,KACP,uBAAO,OAAO,EAAC,MAAM;AAAA;AAGpB,oCAA8C,WAAW,UAAU,SAAS,mBAAmB;AACnG,SAAO,SAAU,QAA8B;AAC5C,UAAM,MAAsC,mBAAmB,QAAQ,MAAM,gBACzE,IAAI,SAAU,MAAM;AAClB,YAAM,aAAa,KAAK,OAAO,MAAM;AACrC,YAAM,cAA+B,YAAY,WAAW,GAAG,OAAO,MAAM,WAAW;AAEvF,UAAI,WAAW,SAAS,KAAK,CAAC,CAAC,WAAW,GAAG,QAAQ;AAClD,oBAAY,OAAO,gBAAgB,WAAW;AAAA;AAGjD,aAAO;AAAA;AAGb,WAAO;AAAA,MACJ;AAAA,MACA,QAAQ,IAAI,UAAU,IAAI,MAAM;AAAA,MAChC,OAAO,IAAI;AAAA;AAAA;AAAA;AApCpB,IAIa,gBAEA,iBAEA,UAEP;AAVN;AAAA;AACA;AACA;AAEO,IAAM,iBAAiB;AAEvB,IAAM,kBAAkB;AAExB,IAAM,WAAW;AAExB,IAAM,oBAAoB,CAAC,QAAQ,QAAQ,WAAW,QAAQ,eAAe;AAAA;AAAA;;;ACuD7E,sBAAsB,QAA0C,UAAsC;AACnG,QAAM,SAAmB;AACzB,QAAM,YAAsB;AAE5B,SAAO,KAAK,QAAQ,QAAQ,CAAC,UAAU;AACpC,WAAO,KAAK;AACZ,cAAU,KAAK,OAAO,OAAO;AAAA;AAGhC,SAAO;AAAA,IACJ;AAAA,IAAQ,UAAU,KAAK;AAAA;AAAA;AAI7B,qBAAwC,OAAmB;AACxD,SAAO,OAAO,KAAK,OAAO,OAAO,CAAC,KAAK,QAAQ;AAC5C,QAAI,CAAE,QAAO,iBAAiB;AAC3B,UAAI,OAAO,MAAM;AAAA;AAEpB,WAAO;AAAA,KACP;AAAA;AAGC,yBAA4C,MAA+B,IAAI,aAAuB,IAAsB;AAChI,QAAM,WAAW,WAAW,IAAI,UAAU,cAAc;AACxD,QAAM,SAAS,CAAC,iBAAiB,IAAI,WAAW,IAAI,SAAS,IAAI,SAAS;AAAA,IACvE,MAAM;AAAA,IACN,MAAM,IAAI,eAAe,QAAQ,QAAQ;AAAA,IACzC,SAAS;AAAA,IACT,MAAM;AAAA,IACN,MAAM,IAAI,YAAY,OAAO;AAAA,IAC7B,aAAa,IAAI,YAAY,QAAQ,QAAQ;AAAA,IAC7C,cAAc,IAAI,YAAY,QAAQ,QAAQ;AAAA;AAGjD,QAAM,CAAC,QAAQ,aAAa,aAAa,QAAQ;AAEjD,QAAM,SAAmB;AACzB,QAAM,UAAoB;AAAA,IACvB,mBAAmB,iBAAiB,YAAY;AAAA,IAChD,GAAG;AAAA;AAGN,QAAM,WAAgC,IAAY,KAAM,IAAY,gBAAgB,IAAI;AACxF,MAAI,UAAU;AACX,YAAQ,KAAK,eAAe;AAAA;AAG/B,MAAI,IAAI,QAAQ,IAAI,IAAI;AACrB,UAAM,gBAAiB,IAAI,cAAc,QAAS,QAAQ;AAC1D,WAAO,KAAK,GAAG,IAAI,OAAO,gBAAgB,IAAI;AAAA;AAGjD,MAAI,aAAa,IAAI,OAAO;AACzB,WAAO,KAAK,YAAY,IAAI;AAAA;AAG/B,oBAAkB,YAAY,MAAiB;AAE/C,SAAO;AAAA,IACJ;AAAA,IACA;AAAA,IACA,UAAU;AAAA,MACP,GAAG;AAAA,MACH,GAAG;AAAA;AAAA;AAAA;AAKL,iBAAoB,UAAkB,QAAkB,YAAgD;AAC5G,SAAO;AAAA,IACJ,UAAU,CAAC,OAAO,GAAG;AAAA,IACrB,QAAQ;AAAA,IACR,QAAQ,2BAA2B,UAAU;AAAA;AAAA;AAIpC,uBAAoC;AAChD,SAAO;AAAA,IACJ,OAA8C,MAAiB;AAC5D,YAAM,OAAO,yBAAyB;AACtC,YAAM,OAAO,2BAA2B,GAAG,SACxC,cAAc,gBAAmB,wBAAwB,YAAY,WAAW,UAAU,IAAI;AAEjG,aAAO,KAAK,SAAS,MAAM;AAAA;AAAA;AAIjC,yBAAuB,SAA2B;AAC/C,WAAO,QAAQ,QAAQ,UAAU,QAAQ,QAAQ,QAAQ;AAAA;AAG5D,sCAAoC,MAAgB,IAAc;AAC/D,WACG,aAAa,SACb,aAAa,OACb,uBAAuB;AAAA;AAAA;AAjKhC,IAoBK;AApBL;AAAA;AAEA;AAMA;AAUA;AAEA,IAAK,iBAAL,kBAAK,oBAAL;AACG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAbE;AAAA;AAAA;AAAA;;;ACpBL,IAEO,sBAaA;AAfP;AAAA;AAEO,iCAAoD;AAAA,MACxD,YACmB,QACA,OAAsB,MACtB,MACjB;AAHiB;AACA;AACA;AAAA;AAAA,MAInB,WAAW;AACR,eAAO,GAAG,KAAK,QAAQ,KAAK;AAAA;AAAA;AAI3B,+BAAgD;AAAA,MAAhD,cAfP;AAgBU,yBAA6B;AAC7B,sBAAmB;AACnB,sBAA4B;AAAA;AAAA,UAE/B,SAAS;AACV,eAAO,KAAK,UAAU,SAAS;AAAA;AAAA,UAG9B,SAAS;AACV,eAAO,KAAK;AAAA;AAAA,MAGf,WAAW;AACR,YAAI,KAAK,UAAU,QAAQ;AACxB,iBAAO,cAAc,KAAK,UAAU,KAAK;AAAA;AAG5C,eAAO;AAAA;AAAA;AAAA;AAAA;;;ACjCb,IAEO,aAgBA;AAlBP;AAAA;AAEO,wBAAwC;AAAA,MAAxC,cAFP;AAGU,8BAAiB;AAAA,UACrB,KAAK;AAAA;AAED,uBAAU;AACV,uBAAoB;AACpB,qBAAkB;AAClB,yBAAmC;AACnC,0BAAoC;AACpC,uBAA6B;AAAA,UACjC,SAAS;AAAA,UACT,WAAW;AAAA,UACX,YAAY;AAAA;AAAA;AAAA;AAIX,8BAAoD;AAAA,MAApD,cAlBP;AAmBG,sBAAS;AACT,oBAAO;AAAA,UACJ,OAAO;AAAA,UACP,QAAQ;AAAA;AAEX,sBAAS;AAAA,UACN,OAAO;AAAA,UACP,QAAQ;AAAA;AAEX,uBAAU;AAAA;AAAA,MAEV,WAAW;AACR,eAAO,KAAK;AAAA;AAAA;AAAA;AAAA;;;AC5BlB,iCAA4E,gBAAoD;AAC7H,SAAQ,eAAe,UAAU,eAAe,WAAW;AAAA,IACxD,aAAa;AAAA,IACb,UAAU;AAAA,IACV,aAAa;AAAA,IACb,YAAY;AAAA,IACZ,QAAQ,EAAC,OAAO,GAAG,OAAO;AAAA,IAC1B,OAAO,EAAC,OAAO,GAAG,OAAO;AAAA;AAAA;AAI/B,uBAAuB,QAAgB;AACpC,QAAM,QAAQ,YAAY,KAAK;AAC/B,QAAM,QAAQ,eAAe,KAAK;AAElC,SAAO;AAAA,IACJ,OAAO,SAAS,SAAS,MAAM,MAAM;AAAA,IACrC,OAAO,SAAS,SAAS,MAAM,MAAM;AAAA;AAAA;AApB3C,IAwBa;AAxBb;AAAA;AACA;AAuBO,IAAM,8BAAuF;AAAA,MACjG,IAAI,iBAAiB,kEAAkE,CAAC,QAAQ,CAAC,QAAQ,WAAW;AACjH,cAAM,MAAM,OAAO;AACnB,cAAM,cAAc,wBAAwB,OAAO;AAEnD,eAAO,OAAO,aAAa,GAAE,MAAM,SAAS;AAAA;AAAA,MAE/C,IAAI,iBAAiB,gFAAgF,CAAC,QAAQ,CAAC,QAAQ,WAAW;AAC/H,cAAM,MAAM,OAAO;AACnB,cAAM,cAAc,wBAAwB,OAAO;AAEnD,eAAO,OAAO,aAAa,GAAE,MAAM,SAAS;AAAA;AAAA,MAE/C,IAAI,iBAAiB,qDAAqD,CAAC,QAAQ,CAAC,OAAO,QAAQ,gBAAgB;AAChH,cAAM,UAAU,wBAAwB,OAAO;AAC/C,gBAAQ,QAAQ,cAAc;AAC9B,gBAAQ,SAAS,cAAc;AAC/B,gBAAQ,aAAa,SAAS;AAAA;AAAA;AAAA;AAAA;;;ACnB7B,6BACJ,SAAiB,QACG;AACpB,SAAO,oBAAoB,EAAC,gBAAgB,IAAI,0BAA8B,UAAS;AAAA;AAzB1F,IAIM,UAwBC;AA5BP;AAAA;AACA;AACA;AAEA,IAAM,WAA8F;AAAA,MACjG,IAAI,iBAAiB,oBAAoB,CAAC,QAAQ,CAAC,UAAU;AAC1D,eAAO,eAAe,IAAI,KAAK,KAAK;AACpC,eAAO;AAAA;AAAA,MAEV,GAAG;AAAA,MACH,IAAI,iBAAiB,CAAC,oCAAoC,wBAAwB,CAAC,QAAQ,CAAC,oBAAoB;AAC7G,QAAC,OAAO,eAA4C,iBAAiB;AAAA;AAAA,MAExE,IAAI,iBAAiB,CAAC,6CAA6C,wBAAwB,CAAC,QAAQ,CAAC,OAAO,SAAS,SAAS;AAC3H,QAAC,OAAO,eAA4C,kBAAkB;AAAA,UACnE,OAAO,SAAS;AAAA,UAChB;AAAA,UACA;AAAA;AAAA;AAAA;AAWF,iCAAqD;AAAA,MAArD,cA5BP;AA6BmB,mBAAgB;AAAA;AAAA;AAAA;AAAA;;;AC+B5B,8BAA8B,QAAgB,QAAgB;AAClE,QAAM,YAAY,oBAAoB,IAAI,qBAAqB,cAAc,QAAQ;AAErF,SAAO,UAAU,WAAW;AAAA;AA/D/B,IAMM,mBACA,eACA,cAEA,UA2BA,cAWO,iBAIA;AApDb;AAAA;AACA;AAEA;AACA;AAEA,IAAM,oBAAoB;AAC1B,IAAM,gBAAgB;AACtB,IAAM,eAAe;AAErB,IAAM,WAAoC;AAAA,MACvC,IAAI,WAAW,mBAAmB,CAAC,QAAQ,CAAC,MAAM,YAAY,eAAe;AAC1E,eAAO,MAAM,KAAK;AAElB,YAAI,YAAY;AACb,iBAAO,WAAW,QAAQ,WAAW;AAAA;AAGxC,YAAI,WAAW;AACZ,iBAAO,UAAU,QAAQ,UAAU;AAAA;AAAA;AAAA,MAGzC,IAAI,WAAW,eAAe,CAAC,QAAQ,CAAC,SAAS,EAAE,YAAY,EAAE,eAAe;AAC7E,YAAI,eAAe,UAAa,cAAc,QAAW;AACtD,iBAAO,QAAQ,UAAU,CAAC,WAAW;AACrC,iBAAO,QAAQ,aAAa,CAAC,cAAc;AAC3C,iBAAO,QAAQ,YAAY,CAAC,aAAa;AACzC,iBAAO;AAAA;AAEV,eAAO;AAAA;AAAA,MAEV,IAAI,WAAW,cAAc,CAAC,QAAQ,CAAC,QAAQ,UAAU;AACtD,eAAO,OAAO,OAAO;AACrB,eAAQ,WAAW,WAAY,OAAO,UAAU,OAAO,SAAS;AAAA;AAAA;AAItE,IAAM,eAA+C;AAAA,MAClD,IAAI,WAAW,iBAAiB,CAAC,QAAQ,CAAC,YAAY,KAAM,QAAO,SAAS;AAAA,MAC5E,IAAI,WAAW,kBAAkB,CAAC,QAAQ,CAAC,aAAa,KAAM,QAAO,UAAU;AAAA,MAC/E,IAAI,WAAW,oDAAoD,CAAC,QAAQ,CAAC,WAAW,YAAY,aAAa,kBAAkB;AAChI,eAAO,OAAO,QAAQ;AACtB,eAAO,KAAK,QAAQ;AACpB,eAAO,OAAO,SAAS;AACvB,eAAO,KAAK,SAAS;AAAA;AAAA;AAIpB,IAAM,kBAAkD,CAAC,QAAQ,WAAW;AAChF,aAAO,oBAAoB,IAAI,eAAe,UAAS,QAAQ;AAAA;AAG3D,IAAM,kBAAkD,CAAC,QAAQ,WAAW;AAChF,aAAO,OAAO,OACX,IAAI,eACJ,gBAAgB,QAAQ,SACxB,oBAAoC,QAAQ;AAAA;AAAA;AAAA;;;ACxDlD,IAMM,UAqBO,kBAWA;AAtCb;AAAA;AACA;AAEA;AACA;AAEA,IAAM,WAAqC;AAAA,MACxC,IAAI,WAAW,yBAAyB,CAAC,SAAS,CAAC,eAAe;AAC/D,gBAAQ,OAAO,KAAK;AAAA;AAAA,MAEvB,IAAI,WAAW,iDAAiD,CAAC,SAAS,CAAC,QAAQ,UAAU;AAC1F,gBAAQ,UAAU,KAAK,IAAI,qBAAqB,QAAQ;AAAA;AAAA,MAE3D,IAAI,WAAW,0DAA0D,CAAC,SAAS,CAAC,QAAQ,MAAM,eAAe;AAC9G,gBAAQ,UAAU,KAAK,IAAI,qBAAqB,QAAQ,MAAM,EAAC;AAAA;AAAA,MAElE,IAAI,WAAW,yBAAyB,CAAC,SAAS,CAAC,YAAY;AAC5D,gBAAQ,UAAU,KAAK,IAAI,qBAAqB,QAAQ;AAAA;AAAA,MAE3D,IAAI,WAAW,oCAAoC,CAAC,SAAS,CAAC,YAAY;AACvE,gBAAQ,SAAS;AAAA;AAAA;AAOhB,IAAM,mBAAoD,CAAC,QAAQ,WAAW;AAClF,aAAO,OAAO,OACX,iBAAiB,QAAQ,SACzB,gBAAgB,QAAQ;AAAA;AAQvB,IAAM,mBAAoD,CAAC,WAAW;AAC1E,aAAO,oBAAoB,IAAI,sBAAsB,UAAS;AAAA;AAAA;AAAA;;;ACjC1D,mBAAmB,YAA2D;AAClF,MAAI,CAAC,WAAW,QAAQ;AACrB,WAAO,uBAAuB;AAAA;AAGjC,SAAO;AAAA,IACJ,UAAU,CAAC,SAAS,GAAG;AAAA,IACvB,QAAQ;AAAA,IACR,OAAO,QAAQ,QAAqB;AACjC,YAAM,QAAQ,iBAAiB,QAAQ;AACvC,UAAI,MAAM,QAAQ;AACf,cAAM,IAAI,iBAAiB;AAAA;AAG9B,aAAO;AAAA;AAAA;AAAA;AApBhB;AAAA;AACA;AACA;AAEA;AAAA;AAAA;;;ACCA,8BAA8B,OAAe,QAAgB,QAAsC;AAChG,QAAM,UAAU,OAAO,SAAS;AAChC,QAAM,MAAM,OAAO,SAAS,UAAU,cAAc,KAAK;AACzD,QAAM,iBAAiB,CAAC,OAAO,SAAS;AAExC,SAAO;AAAA,IACJ;AAAA,IACA;AAAA,IACA,QAAQ,CAAC;AAAA,IACT,KAAK,CAAC;AAAA,IACN;AAAA,IACA;AAAA,IACA;AAAA;AAAA;AAjBN,IAqBM,UAmCO,iBAUA;AAlEb;AAAA;AAEA;AACA;AAkBA,IAAM,WAAoC;AAAA,MACvC,IAAI,WAAW,qBAAqB,CAAC,QAAQ,CAAC,UAAU;AACrD,eAAO,OAAO;AAAA;AAAA,MAEjB,IAAI,WAAW,uCAAuC,CAAC,QAAQ,CAAC,WAAW;AACxE,eAAO,MAAM,iCACN,OAAO,OAAO,KADR;AAAA,UAEV;AAAA;AAAA;AAAA,MAGN,IAAI,WAAW,qCAAqC,CAAC,QAAQ,CAAC,OAAO,QAAQ,UAAU;AACpF,eAAO,OAAO,KAAK,qBAAqB,OAAO,QAAQ;AAAA;AAAA,MAE1D,IAAI,WAAW,4EAA4E,CAAC,QAAQ,CAAC,OAAO,QAAQ,gBAAgB;AACjI,eAAO,SAAS,iCACT,OAAO,UAAU,KADR;AAAA,UAEb;AAAA,UACA;AAAA,UACA;AAAA;AAAA;AAAA,MAGN,IAAI,WAAW,gDAAgD,CAAC,QAAQ,CAAC,OAAO,QAAQ,MAAM,QAAQ;AACnG,eAAO,SAAS;AAAA,UACb,MAAM;AAAA,YACH;AAAA,YACA;AAAA;AAAA,UAEH,MAAM;AAAA,YACH;AAAA,YACA;AAAA;AAAA;AAAA;AAAA;AAML,IAAM,kBAAkD,CAAC,QAAQ,WAAW;AAChF,YAAM,aAAa,gBAAgB,QAAQ;AAC3C,YAAM,iBAAiB,oBAA8C,QAAQ;AAE7E,aAAO,kCACD,aACA;AAAA;AAIF,IAAM,kBAAkD,CAAC,QAAQ,WAAW;AAChF,aAAO,oBAAoB,EAAC,QAAQ,MAAK,UAAS,QAAQ;AAAA;AAAA;AAAA;;;ACnE7D;AAAA;AAAA;AAAA;AAAA;AAOO,sBAAsB,MAAe,IAAI,YAA8C;AAC3F,SAAO,YAAY;AACnB,SAAO,SAAS,KAAK;AAAA;AAGjB,kBAAkB,MAAe,IAAI,YAA8C;AACvF,QAAM,WAAW,CAAC,QAAQ,GAAG;AAC7B,MAAI,IAAI,QAAQ;AACb,aAAS,OAAO,GAAG,GAAG,IAAI;AAAA;AAE7B,MAAI,IAAI,QAAQ;AACb,aAAS,OAAO,GAAG,GAAG,IAAI;AAAA;AAG7B,SAAO,UAAU;AACjB,SAAO,UAAU;AACjB,SAAO,UAAU;AAEjB,SAAO;AAAA,IACJ;AAAA,IACA,QAAQ;AAAA,IACR;AAAA;AAAA;AA5BN;AAAA;AACA;AAEA;AAAA;AAAA;;;ACHA,IAEa,eAEN;AAJP;AAAA;AAEO,IAAM,gBAAgB;AAEtB,8BAAoD;AAAA,MAIxD,YACU,MACA,OACA,aAAqB;AAFrB;AACA;AACA;AAEP,YAAI,AAAS,QAAQ,gBAAjB,KAA+B;AAChC,gBAAM,SAAS,cAAc,KAAK,SAAS,CAAC,MAAM,MAAM;AACxD,eAAK,OAAO,OAAO,MAAM;AACzB,eAAK,OAAO,OAAO,MAAM;AAAA;AAAA;AAAA;AAAA;AAAA;;;ACuBlC,qBAAqB,MAAc;AAChC,QAAM,CAAC,IAAI,QAAQ,KAAK,MAAM;AAE9B,SAAO;AAAA,IACJ,MAAM,QAAQ;AAAA,IACd;AAAA;AAAA;AAIN,iBAAgB,QAA6B,QAA6B,SAAuD;AAC9H,SAAO,CAAC,GAAG,SAAS,UAAU;AAAA;AAGjC,mBAAmB,WAAgC,QAA+B;AAC/E,SAAO,OAAO,IAAI,OAAK,QAAO,QAAQ,GAAG,CAAC,QAAQ,SAAS,OAAO,OAAO,YAAY;AAAA;AAmFxF,mBAAmB,QAAsB,SAAiB;AACvD,QAAM,WAAU,QAAQ;AACxB,UAAQ;AAAA,SACA,SAAQ,OAAO;AACjB,aAAO,KAAK,SAAQ,OAAO,IAAI,SAAQ,OAAO,IAAI,SAAQ,OAAO;AAAA,SAC/D,SAAQ,OAAO;AACjB,aAAO,KAAK,gBAA0B,SAAQ,OAAO,IAAI,SAAQ,OAAO;AAAA;AAExE;AAAA;AAGN,gBAAc,OAAe,YAAoB,MAAc;AAC5D,UAAM,MAAM,GAAG,QAAQ;AACvB,UAAM,UAAU,SAAQ,IAAI;AAE5B,QAAI,SAAS;AACV,cAAQ,QAAQ;AAAA;AAGnB,QAAI,QAAQ,QAAQ,QAAQ,MAAM;AAC/B,aAAO,MAAM,KAAK,IAAI,kBAAkB,KAAK,QAAQ,SAAS,KAAK,OAAO;AAAA;AAAA;AAAA;AA5JnF,IAMO,eAkDD,UA2DO;AAnHb;AAAA;AACA;AACA;AAIO,0BAA4C;AAAA,MAA5C,cANP;AAOU,yBAAY;AACZ,0BAAa;AACb,uBAAU;AACV,uBAAU;AACV,uBAAU;AACV,wBAAW;AACX,uBAAU;AACV,qBAAQ;AACR,sBAAS;AACT,qBAAQ;AACR,sBAAS;AACT,uBAAU;AACV,wBAAW;AACX,wBAAW;AAEX,uBAAU,MAAM;AACpB,iBAAO,CAAC,KAAK,MAAM;AAAA;AAAA;AAAA;AAiCzB,IAAM,WAAyC,IAAI,IAAI;AAAA,MACpD,QAAO,gBAA0B,iBAA2B,CAAC,QAAQ,SAAS,OAAO,OAAO,SAAS;AAAA,MACrG,QAAO,gBAA0B,mBAA6B,CAAC,QAAQ,SAAS,OAAO,OAAO,SAAS;AAAA,MACvG,QAAO,gBAA0B,oBAA8B,CAAC,QAAQ,SAAS,OAAO,OAAO,UAAU;AAAA,MAEzG,QAAO,iBAA2B,gBAA0B,CAAC,QAAQ,SAAS,OAAO,OAAO,SAAS,SAAS,OAAO,OAAO,QAAQ;AAAA,MACpI,QAAO,iBAA2B,oBAA8B,CAAC,QAAQ,SACtE,OAAO,OAAO,SAAS,SAAS,OAAO,OAAO,QAAQ,SAAS,OAAO,OAAO,UAAU;AAAA,MAE1F,QAAO,mBAA6B,gBAA0B,CAAC,QAAQ,SAAS,OAAO,OAAO,SAAS,SAAS,OAAO,OAAO,QAAQ;AAAA,MAEtI,QAAO,oBAA8B,gBAA0B,CAAC,QAAQ,SAAS,OAAO,OAAO,UAAU,SAAS,OAAO,OAAO,QAAQ;AAAA,MACxI,QAAO,oBAA8B,oBAA8B,CAAC,QAAQ,SAAS,OAAO,OAAO,UAAU,SAAS,OAAO,OAAO,QAAQ;AAAA,MAE5I,QAAO,mBAA6B,gBAA0B,CAAC,QAAQ,SAAS;AAC7E,eAAO,OAAO,SAAS,YAAY;AAAA;AAAA,MAEtC,QAAO,mBAA6B,oBAA8B,CAAC,QAAQ,SAAS;AACjF,cAAM,UAAU,YAAY;AAC5B,eAAO,OAAO,SAAS;AACvB,eAAO,OAAO,UAAU,QAAQ;AAAA;AAAA,MAEnC,QAAO,mBAA6B,mBAA6B,CAAC,SAAS,UAAU;AAClF,eAAQ,QAAQ,UAAU,QAAQ,WAAW,IAAK;AAAA;AAAA,MAGrD,QAAO,qBAA+B,qBAA+B,CAAC,QAAQ,SAAS,OAAO,OAAO,WAAW;AAAA,MAEhH,GAAG,UAAU,iBAA2B,iBAA2B;AAAA,MACnE,GAAG,UAAU,mBAA6B,mBAA6B;AAAA,MACvE,GAAG,UAAU,oBAA8B,iBAA2B,mBAA6B;AAAA,MAEnG,CAAC,MAAM,CAAC,QAAQ,SAAS;AACtB,cAAM,WAAW;AACjB,cAAM,YAAY;AAClB,cAAM,aAAa;AACnB,cAAM,cAAc;AACpB,cAAM,mBAAmB;AACzB,YAAI;AAEJ,sBAAc,SAAS,KAAK;AAC5B,eAAO,QAAQ,eAAe,CAAC,YAAY,MAAM;AAEjD,sBAAc,UAAU,KAAK;AAC7B,eAAO,SAAS,eAAe,CAAC,YAAY,MAAM;AAElD,sBAAc,WAAW,KAAK;AAC9B,eAAO,UAAU,eAAe,YAAY;AAE5C,sBAAc,YAAY,KAAK;AAC/B,eAAO,WAAW,eAAe,YAAY;AAE7C,sBAAc,iBAAiB,KAAK;AACpC,eAAO,UAAU,eAAe,YAAY,MAAM,OAAO;AAEzD,eAAO,WAAW,gBAAgB,KAAK;AAAA;AAAA;AAItC,IAAM,qBAAqB,SAAU,MAA4B;AACrE,YAAM,QAAQ,KAAK,MAAM;AACzB,YAAM,SAAS,IAAI;AAEnB,eAAS,IAAI,GAAG,IAAI,MAAM,QAAQ,IAAI,KAAI;AACvC,YAAI,OAAO,MAAM,KAAK;AAEtB,YAAI,CAAC,MAAM;AACR;AAAA;AAGH,YAAI,KAAK,OAAO,OAAO,mBAA6B;AACjD,kBAAQ,OAAQ,OAAM,QAAQ;AAAA;AAGjC,kBAAU,QAAQ;AAAA;AAGrB,aAAO;AAAA;AAAA;AAAA;;;AC/HH,oBAAoB,YAAgD;AACxE,QAAM,WAAW;AAAA,IACd;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA,GAAG,WAAW,OAAO,SAAO,CAAC,eAAe,SAAS;AAAA;AAGxD,SAAO;AAAA,IACJ,QAAQ;AAAA,IACR;AAAA,IACA,OAAO,MAAc;AAClB,aAAO,mBAAmB;AAAA;AAAA;AAAA;AApBnC,IAIM;AAJN;AAAA;AACA;AAGA,IAAM,iBAAiB,CAAC,UAAU;AAAA;AAAA;;;ACJlC;AAAA;AAAA;AAAA;AAAA,IAgBO;AAhBP;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEO,yBAA4C;AAAA,MAEhD,YAAoB,WAA8B;AAA9B;AAAA;AAAA,MAGV,SAAY,MAAwB,MAAiC;AAC5E,cAAM,QAAQ,KAAK,UAAU;AAC7B,cAAM,UAAU,MAAM,KAAK;AAE3B,YAAI,MAAM;AACP,uBAAa,MAAM,SAAS;AAAA;AAG/B,eAAO,OAAO,OAAO,MAAM;AAAA,UACxB,MAAM,EAAC,OAAO,QAAQ,KAAK,KAAK;AAAA,UAChC,OAAO,EAAC,OAAO,QAAQ,MAAM,KAAK;AAAA,UAClC,WAAW,EAAC,OAAO;AAAA;AAAA;AAAA,MAIzB,IAAI,OAA0B;AAC3B,eAAO,KAAK,SACT,0BAA0B,CAAC,OAAO,GAAG,QAAQ,UAC7C,yBAAyB;AAAA;AAAA,MAI/B,IAAI,WAAsD;AACvD,cAAM,OAAO,yBAAyB;AAEtC,YAAI,OAAO,cAAc,UAAU;AAChC,iBAAO,KAAK,SAAS,2BAA2B,WAAW,KAAK,YAAY;AAAA;AAG/E,YAAI,OAAO,wCAAW,UAAS,UAAU;AACtC,iBAAO,KAAK,SAAS,2BAA2B,UAAU,MAAM,UAAU,QAAQ,KAAK,aAAa,SAAY;AAAA;AAGnH,eAAO,KAAK,SACT,uBAAuB,2DACvB;AAAA;AAAA,MAIN,WAAW,MAAc,OAA0B;AAChD,eAAO,KAAK,SACT,eAAe,MAAM,UAAU,OAC/B,yBAAyB;AAAA;AAAA,MAI/B,KAAK,MAA0B;AAC5B,eAAO,KAAK,SACT,SAAS,SAAS,MAAM,KAAK,UAAU,KAAK,mBAAmB,aAC/D,yBAAyB;AAAA;AAAA,MAI/B,QAAQ;AACL,eAAO,KAAK,SACT,UAAU,mBAAmB,aAC7B,yBAAyB;AAAA;AAAA,MAI/B,YAAY,QAAgB,QAAgB;AACzC,YAAI,CAAE,cAAa,WAAW,aAAa,UAAU;AAClD,iBAAO,KAAK,SAAS,uBAClB;AAAA;AAIN,eAAO,KAAK,SACT,UAAU,CAAC,QAAQ,QAAQ,GAAG,mBAAmB,cACjD,yBAAyB,WAAW;AAAA;AAAA,MAI1C,cAAc,SAAwB;AACnC,aAAK,UAAU,gBAAgB;AAC/B,eAAO;AAAA;AAAA,MAGV,OAAO;AACJ,cAAM,OAAO,SACV;AAAA,UACG,QAAQ,WAAW,UAAU,IAAI;AAAA,UACjC,QAAQ,WAAW,UAAU,IAAI;AAAA,WAEpC,mBAAmB;AAGtB,eAAO,KAAK,SACT,MACA,yBAAyB;AAAA;AAAA,MAI/B,QAAQ;AACL,eAAO,KAAK,SACT,0BAA0B,CAAC,SAAS,GAAG,mBAAmB,cAC1D,yBAAyB;AAAA;AAAA,MAI/B,SAAS;AACN,eAAO,KAAK,SAAS,WAAW,mBAAmB,aAAa,yBAAyB;AAAA;AAAA;AAI/F,WAAO,OAAO,aAAa,WAAW,kBAAU,kBAAU,gBAAQ;AAAA;AAAA;;;AC9HlE;AAAA;AAAA;AAAA;AACA;AADA,IAOM,qBAcC;AArBP;AAAA;AAAA;AAEA;AAKA,IAAM,sBAA4C,OAAM;AACrD,UAAI,KAAK;AACT,aAAO,MAAM;AACV;AACA,cAAM,EAAC,SAAS,SAAQ;AAExB,eAAO;AAAA,UACJ;AAAA,UACA;AAAA,UACA;AAAA;AAAA;AAAA;AAKF,sBAAgB;AAAA,MAKpB,YAAoB,cAAc,GAAG;AAAjB;AAJZ,sBAAS,aAAa,IAAI;AAC1B,uBAA2B;AAC3B,uBAA2B;AAGhC,aAAK,OAAO,+BAA+B;AAAA;AAAA,MAGtC,WAAW;AAChB,YAAI,CAAC,KAAK,QAAQ,UAAU,KAAK,QAAQ,UAAU,KAAK,aAAa;AAClE,eAAK,OAAO,kEAAkE,KAAK,QAAQ,QAAQ,KAAK,QAAQ,QAAQ,KAAK;AAC7H;AAAA;AAGH,cAAM,OAAO,OAAO,KAAK,SAAS,KAAK,QAAQ;AAC/C,aAAK,OAAO,oBAAoB,KAAK;AACrC,aAAK,KAAK,MAAM;AACb,eAAK,OAAO,kBAAkB,KAAK;AACnC,iBAAO,KAAK,SAAS;AACrB,eAAK;AAAA;AAAA;AAAA,MAIX,OAA0C;AACvC,cAAM,EAAC,SAAS,OAAM,OAAO,KAAK,SAAS;AAC3C,aAAK,OAAO,oBAAoB;AAEhC,aAAK;AAEL,eAAO;AAAA;AAAA;AAAA;AAAA;;;ACnDb;AAAA;AAAA;AAAA;AAkCO,wBAAwB,SAAmB,YAA0C;AACzF,SAAO,0BAA0B,CAAC,SAAS,GAAG,YAAY,GAAG;AAAA;AAnChE;AAAA;AAAA;AAAA;AAAA;;;ACiBO,+BAAgC,QAAgB,MAAyC;AAC7F,SAAO;AAAA,IACJ;AAAA,IAAQ;AAAA,IAAM,SAAS;AAAA;AAAA;AAItB,+BAAgC,QAA2C;AAC/E,SAAO;AAAA,IACJ;AAAA,IAAQ,MAAM;AAAA,IAAM,SAAS;AAAA;AAAA;AAzBnC,IAOO;AAPP;AAAA;AAOO,gCAA6D;AAAA,MAA7D,cAPP;AAQG,mBAAkC;AAClC,wBAA+D;AAC/D,sBAAqC;AAAA;AAAA,UAEjC,UAAmB;AACpB,eAAO,CAAC,KAAK,OAAO;AAAA;AAAA;AAAA;AAAA;;;ACenB,gCAAgC,MAAc,iBAAqC;AACvF,SAAO,oBAAoB,iBAAmB,iBAAiB,KAAK;AAAA;AA7BvE,IAKM,oBACA,kBAEA,UAgBO;AAxBb;AAAA;AACA;AAEA;AAEA,IAAM,qBAAqB;AAC3B,IAAM,mBAAmB;AAEzB,IAAM,WAAiD;AAAA,MACpD,IAAI,WAAW,oBAAoB,CAAC,QAAQ,CAAC,QAAQ,UAAU;AAC5D,cAAM,WAAW,sBAAsB,QAAQ;AAE/C,eAAO,IAAI,KAAK;AAChB,eAAO,SAAS,UAAU;AAAA;AAAA,MAE7B,IAAI,WAAW,kBAAkB,CAAC,QAAQ,CAAC,YAAY;AACpD,cAAM,WAAW,sBAAsB;AAEvC,eAAO,OAAO,KAAK;AACnB,eAAO,IAAI,KAAK;AAChB,eAAO,SAAS,UAAU;AAAA;AAAA;AAIzB,IAAM,uBAAoE,CAAC,QAAQ,WAAW;AAClG,aAAO,oBAAoB,IAAI,uBAAuB,UAAS,QAAQ;AAAA;AAAA;AAAA;;;ACzB1E,IAEO;AAFP;AAAA;AAEO,gCAAmD;AAAA,MAAnD,cAFP;AAGU,mBAAgB;AAChB,wBAAiD;AACjD,uBAAkB;AAClB,wBAAoB;AAAA;AAAA,MAE3B,KAAK,SAAkB,UAAmB,MAAc,QAAgB,OAAe;AACpF,YAAI,SAAS;AACV,eAAK,WAAW;AAChB,eAAK,UAAU;AAAA;AAGlB,aAAK,IAAI,KAAK;AACd,aAAK,SAAS,QAAQ;AAAA,UACnB;AAAA,UACA;AAAA,UACA;AAAA,UACA;AAAA;AAAA;AAAA;AAAA;AAAA;;;ACEF,4BAA6B,QAA+B;AAChE,SAAO,oBAAoB,IAAI,uBAAuB,UAAS;AAAA;AAtBlE,IAIM;AAJN;AAAA;AACA;AACA;AAEA,IAAM,WAA6C;AAAA,MAChD,IAAI,WAAW,yEAAyE,CAAC,QAAQ,CAAC,SAAS,MAAM,QAAQ,WAAW;AACjI,eAAO,KACJ,CAAC,CAAC,SACF,MACA,MAAM,QAAQ;AAAA;AAAA,MAGpB,IAAI,WAAW,wCAAwC,CAAC,QAAQ,CAAC,SAAS,MAAM,QAAQ,WAAW;AAChG,eAAO,KACJ,CAAC,CAAC,SACF,OACA,MAAM,QAAQ;AAAA;AAAA;AAAA;AAAA;;;AChBvB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAOO,qCAAqC,UAAoB;AAC7D,QAAM,iBAAiB,CAAC,MAAM,MAAM;AACpC,SAAO,SAAS,KAAK,aAAW,eAAe,SAAS;AAAA;AAGpD,oBAAoB,YAA4E;AACpG,QAAM,WAAW,4BAA4B;AAC7C,QAAM,WAAW,CAAC,UAAU,GAAG;AAE/B,MAAI,SAAS,WAAW,GAAG;AACxB,aAAS,KAAK;AAAA;AAGjB,MAAI,CAAC,SAAS,SAAS,OAAO;AAC3B,aAAS,OAAO,GAAG,GAAG;AAAA;AAGzB,SAAO;AAAA,IACJ,QAAQ;AAAA,IACR;AAAA,IACA,OAAO,QAAQ,QAAQ;AACpB,UAAI,UAAU;AACX,eAAO,qBAAqB,QAAQ,QAAQ,IAAI;AAAA;AAGnD,aAAO,mBAAmB;AAAA;AAAA;AAAA;AAK5B,2BAAsD;AAC1D,QAAM,UAAS;AAEf,SAAO;AAAA,IACJ,QAAQ;AAAA,IACR,UAAU,CAAC,UAAU;AAAA,IACrB;AAAA;AAAA;AAIC,4BAA4B,UAAoB,cAAc,OAA4C;AAC9G,SAAO;AAAA,IACJ,QAAQ;AAAA,IACR,UAAU,CAAC,UAAU,MAAM,cAAc,OAAO,MAAM,GAAG;AAAA,IACzD,OAAO,QAAQ,QAAQ;AACpB,aAAO,qBAAqB,QAAQ;AAAA;AAAA,IAEvC,QAAQ,EAAC,UAAU,UAAS,OAAO,MAAM,MAAM;AAC5C,UAAI,CAAC,uBAAuB,OAAO,QAAQ,WAAW;AACnD,eAAO,KAAK;AAAA;AAGf,WAAK;AAAA;AAAA;AAAA;AAKP,0BAA0B,QAAgB,cAAc,OAA6C;AACzG,QAAM,OAA6C;AAAA,IAChD,QAAQ;AAAA,IACR,UAAU,CAAC,UAAU,MAAM,cAAc,OAAO,MAAM;AAAA,IACtD,OAAO,QAAQ,QAAQ;AACpB,aAAO,qBAAqB,QAAQ,QAAQ,SAAS;AAAA;AAAA,IAExD,QAAQ,EAAC,UAAU,QAAQ,UAAS,OAAO,GAAG,MAAM;AACjD,UAAI,CAAC,uBAAuB,OAAO,QAAQ,WAAW;AACnD,eAAO,KAAK;AAAA;AAGf,YAAM,IAAI,iBACP,KAAK,OAAO,eAAe,SAAS,eAAe,UACnD,OAAO;AAAA;AAAA;AAKhB,SAAO;AAAA;AAnFV;AAAA;AAEA;AACA;AACA;AACA;AAAA;AAAA;;;ACLA,IAIa;AAJb;AAAA;AAIO,IAAM,mBAAmB,CAAC,SAA2B;AACzD,aAAO,KAAK,MAAM,OACd,IAAI,UAAQ,KAAK,QACjB,OAAO,UAAQ,CAAC,CAAC;AAAA;AAAA;AAAA;;;ACPxB;AAAA;AAAA;AAAA;AAGO,yBAAyB,OAAuC;AACpE,SAAO;AAAA,IACJ,UAAU,CAAC,gBAAgB,GAAG;AAAA,IAC9B,QAAQ;AAAA,IACR,QAAQ;AAAA;AAAA;AAPd;AAAA;AACA;AAAA;AAAA;;;ACDA;AAAA;AAAA;AAAA;AAAA;AAoBA,2BAA2B,SAAiB;AACzC,SAAO,sBAAsB,KAAK;AAAA;AAG9B,mBAAmB,MAA0B,WAA+B,YAAsD;AACtI,QAAM,WAAW,CAAC,SAAS,GAAG;AAE9B,eAAa,SAAS,SAAS,KAAK;AACpC,eAAa,cAAc,SAAS,KAAK;AAEzC,QAAM,SAAS,SAAS,KAAK;AAC7B,MAAI,QAAQ;AACT,WAAO,uBAAuB;AAAA;AAGjC,SAAO,0BAA0B;AAAA;AAG7B,yBAAyB,MAA0B,WAA+B,YAAsB;AAC5G,SAAO,YAAY;AAEnB,SAAO,UAAU,MAAM,WAAW;AAAA;AAzCrC;AAAA;AAAA;AAEA;AAAA;AAAA;;;ACFA;AAAA;AAAA;AAAA;AAIO,yBAAyB,YAA8C;AAC3E,SAAO;AAAA,IACJ,UAAU,CAAC,QAAQ,eAAe,GAAG;AAAA,IACrC,QAAQ;AAAA,IACR,OAAQ,QAAQ;AACb,aAAO,gBAAgB;AAAA;AAAA;AAAA;AAThC;AAAA;AAEA;AAAA;AAAA;;;ACmBO,0BAA2B,QAAgB,QAA6B;AAC5E,QAAM,SAAsB;AAAA,IACzB,KAAK;AAAA,IACL,QAAQ;AAAA,IACR,UAAU;AAAA,IACV,MAAM;AAAA;AAET,SAAO,oBAAoB,QAAQ,UAAS,QAAQ;AAAA;AA5BvD,IAGM;AAHN;AAAA;AACA;AAEA,IAAM,WAAqC;AAAA,MACxC,IAAI,WAAW,cAAc,CAAC,QAAQ,CAAC,YAAY;AAChD,eAAO,SAAS;AAAA;AAAA,MAEnB,IAAI,WAAW,uCAAuC,CAAC,QAAQ,CAAC,MAAM,cAAa;AAChF,eAAO,SAAS,KAAK;AAAA,UAClB;AAAA,UACA;AAAA;AAAA;AAAA,MAGN,IAAI,WAAW,oCAAoC,CAAC,QAAQ,CAAC,MAAM,cAAc;AAC9E,eAAO,KAAK,KAAK;AAAA,UACd;AAAA,UACA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AChBT;AAAA;AAAA;AAAA;AAMA,4BAA2B,SAAiB;AACzC,SAAO,sBAAsB,KAAK;AAAA;AAG9B,mBAAmB,QAAgB,QAAgB,YAA2D;AAClH,QAAM,WAAW,CAAC,SAAS,GAAG;AAC9B,MAAI,UAAU,QAAQ;AACnB,aAAS,KAAK,QAAQ;AAAA;AAGzB,QAAM,SAAS,SAAS,KAAK;AAC7B,MAAI,QAAQ;AACT,WAAO,uBAAuB;AAAA;AAGjC,SAAO;AAAA,IACJ;AAAA,IACA,QAAQ;AAAA,IACR,QAAQ;AAAA;AAAA;AAxBd;AAAA;AACA;AAGA;AAAA;AAAA;;;ACKO,yBAA0B,QAA4B;AAC1D,SAAO,oBAAoB,EAAC,OAAO,MAAK,WAAS;AAAA;AAVpD,IAGM;AAHN;AAAA;AACA;AAEA,IAAM,YAAoC;AAAA,MACvC,IAAI,WAAW,2BAA2B,CAAC,QAAQ,CAAC,MAAM,QAAQ;AAC/D,eAAO,MAAM,KAAK,EAAC,MAAM;AAAA;AAAA;AAAA;AAAA;;;ACL/B;AAAA;AAAA;AAAA;AAKO,kBAAkB,MAAyB,IAAoC;AACnF,SAAO;AAAA,IACJ,UAAU,CAAC,MAAM,MAAM,GAAG,QAAQ,OAAO;AAAA,IACzC,QAAQ;AAAA,IACR,QAAQ;AAAA;AAAA;AATd;AAAA;AACA;AAEA;AAAA;AAAA;;;ACHA;AAAA;AAAA;AAAA;AAMO,kBAAkB,QAAuB,QAAuB,YAA8C;AAClH,QAAM,WAAqB,CAAC,QAAQ,GAAG;AACvC,MAAI,UAAU,QAAQ;AACnB,aAAS,OAAO,GAAG,GAAG,QAAQ;AAAA;AAGjC,SAAO;AAAA,IACJ;AAAA,IACA,QAAQ;AAAA,IACR,OAAO,QAAQ,QAAoB;AAChC,aAAO,gBAAgB,QAAQ;AAAA;AAAA,IAElC,QAAQ,QAAQ,QAAQ,OAAO,MAAM;AAClC,YAAM,YAAY,qBAAqB,eAAe,OAAO,SAAS,eAAe,OAAO;AAC5F,UAAI,WAAW;AACZ,eAAO,KAAK,IAAI,iBAAiB;AAAA;AAGpC,WAAK;AAAA;AAAA;AAAA;AAxBd;AAAA;AACA;AACA;AAEA;AAAA;AAAA;;;ACSO,yBAA0B,MAAmC;AACjE,QAAM,UAA+C;AAErD,UAAQ,MAAM,CAAC,CAAC,UAAU,QAAQ,QAAQ,EAAE;AAE5C,SAAO,OAAO,OAAO;AAAA;AAGjB,gCAAiC,MAAgC;AACrE,QAAM,UAA4C;AAElD,UAAQ,MAAM,CAAC,CAAC,MAAM,KAAK,aAAa;AACrC,QAAI,CAAC,QAAQ,eAAe,OAAO;AAChC,cAAQ,QAAQ;AAAA,QACb;AAAA,QACA,MAAM,EAAE,OAAO,IAAI,MAAM;AAAA;AAAA;AAI/B,QAAI,WAAW,KAAK;AACjB,cAAQ,MAAM,KAAK,QAAQ,QAAQ,WAAW,OAAuC;AAAA;AAAA;AAI3F,SAAO,OAAO,OAAO;AAAA;AAGxB,iBAAiB,MAAc,SAAmC;AAC/D,yBAAuB,MAAM,CAAC,SAAS,QAAQ,KAAK,MAAM;AAAA;AAzC7D;AAAA;AAAA;AAAA;AAAA;;;ACAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIO,uBAAuB,YAAoB,YAAoB,aAAuB,IAAwB;AAClH,SAAO,0BAA0B,CAAC,UAAU,OAAO,GAAG,YAAY,YAAY;AAAA;AAG1E,wBAAwB,SAAmC;AAC/D,QAAM,WAAW,CAAC;AAClB,MAAI,SAAS;AACV,aAAS,KAAK;AAAA;AAGjB,SAAO;AAAA,IACJ;AAAA,IACA,QAAQ;AAAA,IACR,QAAQ,UAAU,yBAAyB;AAAA;AAAA;AAI1C,yBAAyB,aAAuB,IAAwB;AAC5E,QAAM,WAAW,CAAC,GAAG;AACrB,MAAI,SAAS,OAAO,aAAa;AAC9B,aAAS,QAAQ;AAAA;AAGpB,SAAO,0BAA0B;AAAA;AAG7B,oBAAoB,aAAuB,IAAwB;AACvE,QAAM,WAAW,CAAC,GAAG;AACrB,MAAI,SAAS,OAAO,UAAU;AAC3B,aAAS,QAAQ;AAAA;AAGpB,SAAO,0BAA0B;AAAA;AAG7B,0BAA0B,YAAoB;AAClD,SAAO,0BAA0B,CAAC,UAAU,UAAU;AAAA;AAxCzD;AAAA;AAAA;AAEA;AAAA;AAAA;;;ACFA;AAAA;AAAA;AAAA;AAKO,uBAAuB,MAAkB,IAAI,YAA6C;AAC9F,QAAM,UAAU,gBAAqB;AACrC,QAAM,UAAS,2BAA2B,QAAQ,UAAU,QAAQ;AAEpE,SAAO;AAAA,IACJ,UAAU,CAAC,SAAS,QAAQ,GAAG,QAAQ,UAAU,GAAG;AAAA,IACpD,QAAQ;AAAA,IACR;AAAA;AAAA;AAZN;AAAA;AACA;AAEA;AAAA;AAAA;;;ACHA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGO,0BAA0B,MAAc,MAAkC;AAC9E,SAAO,cAAc,CAAC,OAAO,MAAM;AAAA;AAG/B,2BAA2B,YAA0C;AACzE,SAAO,cAAc,CAAC,QAAQ,GAAG;AAAA;AAG7B,uBAAuB,YAA0C;AACrE,QAAM,WAAW,CAAC,GAAG;AACrB,MAAI,SAAS,OAAO,aAAa;AAC9B,aAAS,QAAQ;AAAA;AAGpB,SAAO,0BAA0B;AAAA;AAG7B,6BAA6B,YAA0C;AAC3E,SAAO,cAAc,CAAC,UAAU,GAAG;AAAA;AArBtC;AAAA;AACA;AAAA;AAAA;;;ACyCA,sBAAsB,GAAW,GAAoB;AAClD,QAAM,SAAS,MAAM;AACrB,QAAM,SAAS,MAAM;AAErB,MAAI,WAAW,QAAQ;AACpB,WAAO,SAAS,IAAI;AAAA;AAGvB,SAAO,SAAS,OAAO,GAAG,KAAK;AAAA;AAGlC,gBAAgB,GAAW,GAAW;AACnC,SAAO,MAAM,IAAI,IAAI,IAAI,IAAI,IAAI;AAAA;AAGpC,iBAAiB,OAAe;AAC7B,SAAO,MAAM;AAAA;AAGhB,kBAAkB,OAA2B;AAC1C,MAAI,OAAO,UAAU,UAAU;AAC5B,WAAO,SAAS,MAAM,QAAQ,SAAS,KAAK,OAAO;AAAA;AAGtD,SAAO;AAAA;AAlEV,IAEO,SAQM;AAVb;AAAA;AAEO,oBAAmC;AAAA,MACvC,YACmB,KACA,QACjB;AAFiB;AACA;AAAA;AAAA;AAKf,IAAM,eAAe,SAAU,MAAc,aAAa,OAAO;AACrE,YAAM,OAAO,KACT,MAAM,MACN,IAAI,SACJ,OAAO;AAEX,UAAI,CAAC,YAAY;AACd,aAAK,KAAK,SAAU,MAAM,MAAM;AAC7B,gBAAM,SAAS,KAAK,MAAM;AAC1B,gBAAM,SAAS,KAAK,MAAM;AAE1B,cAAI,OAAO,WAAW,KAAK,OAAO,WAAW,GAAG;AAC7C,mBAAO,aAAa,SAAS,OAAO,KAAK,SAAS,OAAO;AAAA;AAG5D,mBAAS,IAAI,GAAG,IAAI,KAAK,IAAI,OAAO,QAAQ,OAAO,SAAS,IAAI,GAAG,KAAK;AACrE,kBAAM,OAAO,OAAO,SAAS,OAAO,KAAK,SAAS,OAAO;AAEzD,gBAAI,MAAM;AACP,qBAAO;AAAA;AAAA;AAIb,iBAAO;AAAA;AAAA;AAIb,YAAM,SAAS,aAAa,KAAK,KAAK,CAAC,GAAG,MAAM,UAAU,KAAK,CAAC,QAAQ,IAAI,QAAQ,QAAQ;AAE5F,aAAO,IAAI,QAAQ,MAAM;AAAA;AAAA;AAAA;;;ACvC5B;AAAA;AAAA;AAAA;AAAA;AAAA;AAOO,qBAAsB,aAAuB,IAA2B;AAC5E,QAAM,gBAAgB,WAAW,KAAK,CAAC,WAAW,WAAW,KAAK;AAElE,SAAO;AAAA,IACJ,QAAQ;AAAA,IACR,UAAU,CAAC,OAAO,MAAM,GAAG;AAAA,IAC3B,OAAQ,MAAc;AACnB,aAAO,aAAa,MAAM;AAAA;AAAA;AAAA;AAQ5B,oBAAqB,MAA0C;AACnE,SAAO;AAAA,IACJ,QAAQ;AAAA,IACR,UAAU,CAAC,OAAO;AAAA,IAClB,SAAU;AACP,aAAO,EAAC;AAAA;AAAA;AAAA;AAQV,6BAA8B,MAAc,YAAgD;AAChG,SAAO;AAAA,IACJ,QAAQ;AAAA,IACR,UAAU,CAAC,OAAO,MAAM,MAAM,YAAY;AAAA,IAC1C,SAAU;AACP,aAAO,EAAC;AAAA;AAAA;AAAA;AAxCjB;AAAA;AACA;AAAA;AAAA;;;ACDA;AAAA;AAAA,QAAM,EAAC,8BAAe;AACtB,QAAM,EAAC,gCAAgB;AAEvB,QAAM,EAAC,0BAAa;AACpB,QAAM,EAAC,oDAA0B;AACjC,QAAM;AAAA,MACH;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,QACC;AACJ,QAAM,EAAC,oCAAkB;AACzB,QAAM,EAAC,yBAAY,mCAAiB,yCAAoB,wCAAoB;AAC5E,QAAM,EAAC,sCAAmB;AAC1B,QAAM,EAAC,sCAAmB;AAC1B,QAAM,EAAC,uBAAW,sCAAmB;AACrC,QAAM,EAAC,6CAAsB,8CAAuB;AACpD,QAAM,EAAC,4BAAc;AACrB,QAAM,EAAC,sCAAmB;AAC1B,QAAM,EAAC,0BAAa;AACpB,QAAM,EAAC,wBAAY;AACnB,QAAM,EAAC,wBAAY;AACnB,QAAM,EAAC,gCAAgB;AACvB,QAAM,EAAC,+BAAe,iCAAgB,mCAAiB,yBAAY,wCAAoB;AACvF,QAAM,EAAC,6BAAc,0BAAa;AAClC,QAAM,EAAC,kCAAiB;AACxB,QAAM,EAAC,qCAAkB,uCAAmB,+BAAe,8CAAuB;AAClF,QAAM,EAAC,2CAAqB,yBAAY,8BAAe;AACvD,QAAM,EAAC,uDAA2B,0DAA6B;AAE/D,kBAAc,SAAS,SAAS;AAC7B,WAAK,YAAY,IAAI,aAClB,QAAQ,QAAQ,QAAQ,SACxB,IAAI,WAAU,QAAQ,yBAAyB;AAAA;AAIrD,IAAC,MAAI,YAAY,OAAO,OAAO,cAAa,YAAY,cAAc;AAStE,SAAI,UAAU,eAAe,SAAU,SAAS;AAC7C,WAAK,UAAU,SAAS;AACxB,aAAO;AAAA;AAWV,SAAI,UAAU,MAAM,SAAU,MAAM,OAAO;AACxC,UAAI,UAAU,WAAW,KAAK,OAAO,SAAS,UAAU;AACrD,aAAK,UAAU,MAAM;AAAA,aACjB;AACJ,QAAC,MAAK,UAAU,MAAM,KAAK,UAAU,OAAO,IAAI,QAAQ;AAAA;AAG3D,aAAO;AAAA;AAMV,SAAI,UAAU,YAAY,SAAU,SAAS;AAC1C,aAAO,KAAK,SACT,eACG,yBAAwB,cAAc,IACtC,aAAY,YAAY,WAAW,KAEtC,0BAAyB;AAAA;AAI/B,6BAA0B,KAAK,MAAM,UAAU,WAAW;AACvD,UAAI,OAAO,aAAa,UAAU;AAC/B,eAAO,wBAAuB,OAAQ;AAAA;AAGzC,aAAO,KAAK,UAAU,YAAW,WAAW,gBAAe,oBAAmB;AAAA;AAOjF,SAAI,UAAU,QAAQ,WAAY;AAC/B,aAAO,KAAK,SACT,gBAAgB,SAAS,YAAW,GAAG,YACvC,0BAAyB;AAAA;AAO/B,SAAI,UAAU,SAAS,WAAY;AAChC,aAAO,KAAK,SACT,gBAAgB,UAAU,kBAAiB,GAAG,YAC9C,0BAAyB;AAAA;AAY/B,SAAI,UAAU,KAAK,SAAU,MAAM,IAAI;AACpC,aAAO,KAAK,SAAS,UAAS,MAAM,KAAK,0BAAyB;AAAA;AAQrE,SAAI,UAAU,oBAAoB,SAAU,MAAM;AAC/C,UAAI,MAAM;AACV,aAAO,KAAK,KAAK,WAAY;AAC1B,YAAI,KAAK,SAAU,KAAK,MAAM;AAC3B,cAAI,SAAS,KAAK,QAAQ;AAAA;AAAA;AAAA;AAQnC,SAAI,UAAU,OAAO,SAAU,QAAQ,QAAQ,SAAS,MAAM;AAC3D,aAAO,KAAK,SACT,UAAS,YAAW,QAAQ,gBAAe,YAAW,QAAQ,gBAAe,oBAAmB,aAChG,0BAAyB;AAAA;AAc/B,SAAI,UAAU,QAAQ,SAAU,QAAQ,QAAQ;AAC7C,aAAO,KAAK,SACT,WAAU,YAAW,QAAQ,gBAAe,YAAW,QAAQ,gBAAe,oBAAmB,aACjG,0BAAyB;AAAA;AAW/B,SAAI,UAAU,SAAS,SAAU,SAAS;AACvC,cAAQ,KAAK;AACb,aAAO;AAAA;AAYV,SAAI,UAAU,OAAO,SAAU,SAAS,MAAM;AAC3C,aAAO,KAAK,SACT,aAAY,oBAAmB,aAC/B,0BAAyB;AAAA;AAQ/B,SAAI,UAAU,SAAS,WAAY;AAChC,aAAO,KAAK,SACT,2BAA0B,CAAC,UAAU,GAAG,oBAAmB,cAC3D,0BAAyB;AAAA;AAO/B,SAAI,UAAU,QAAQ,SAAU,MAAM;AACnC,aAAO,KAAK,SACT,WAAU,cAAa,OAAO,oBAAmB,aACjD,0BAAyB;AAAA;AAO/B,SAAI,UAAU,SAAS,SAAU,QAAQ;AACtC,YAAM,OAAO,0BAAyB;AAEtC,UAAI,OAAO,WAAW,UAAU;AAC7B,eAAO,KAAK,SACT,wBAAuB,4BACvB;AAAA;AAIN,aAAO,KAAK,SACT,2BAA0B,CAAC,UAAU,GAAG,oBAAmB,WAAW,GAAG,OAAO,UAChF;AAAA;AAON,SAAI,UAAU,SAAS,SAAU,MAAM;AACpC,YAAM,OAAQ,OAAO,SAAS,WACzB,YAAW,QACX,wBAAuB;AAE5B,aAAO,KAAK,SAAS,MAAM,0BAAyB;AAAA;AAMvD,SAAI,UAAU,kBAAkB,SAAU,SAAS,YAAY;AAC5D,aAAO,KAAK,SACT,qBAAoB,SAAS,aAC7B,0BAAyB;AAAA;AAQ/B,SAAI,UAAU,WAAW,WAAY;AAClC,YAAM,WAAW,CAAC,YAAY,GAAG,oBAAmB,WAAW;AAC/D,aAAO,KAAK,SACT,2BAA0B,WAC1B,0BAAyB;AAAA;AAW/B,SAAI,UAAU,iBAAiB,SAAU,YAAY,YAAY,MAAM;AACpE,aAAO,KAAK,SAAS,CAAC,MAAM,YAAY,aAAa,0BAAyB;AAAA;AAMjF,SAAI,UAAU,sBAAsB,SAAU,YAAY,MAAM;AAC7D,aAAO,KAAK,SAAS,CAAC,MAAM,aAAa,0BAAyB;AAAA;AAMrE,SAAI,UAAU,oBAAoB,SAAU,YAAY,aAAa,MAAM;AACxE,aAAO,KAAK,SACT,kBAAiB,YAAY,OAAO,gBAAgB,YAAY,cAAc,QAC9E,0BAAyB;AAAA;AAO/B,SAAI,UAAU,sBAAsB,SAAU,aAAa,aAAa,MAAM;AAC3E,aAAO,KAAK,SACT,oBAAmB,aAAa,OAAO,gBAAgB,YAAY,cAAc,QACjF,0BAAyB;AAAA;AAU/B,SAAI,UAAU,SAAS,SAAU,SAAS,MAAM;AAC7C,aAAO,KAAK,SACT,YAAW,oBAAmB,aAC9B,0BAAyB;AAAA;AAS/B,SAAI,UAAU,cAAc,SAAU,MAAM;AACzC,aAAO,KAAK,SACT,oBACA,0BAAyB;AAAA;AAO/B,SAAI,UAAU,MAAM,SAAU,UAAU;AACrC,YAAM,qBAAqB,CAAC,MAAM,QAAQ;AAC1C,YAAM,UAAU,GAAG,MAAM,KAAK,qBAAqB,YAAY,UAAU;AAEzE,eAAS,IAAI,GAAG,IAAI,QAAQ,UAAU,oBAAoB,KAAK;AAC5D,YAAI,CAAC,kBAAiB,QAAQ,KAAK;AAChC,kBAAQ,OAAO,GAAG,QAAQ,SAAS;AACnC;AAAA;AAAA;AAIN,cAAQ,KACL,GAAG,oBAAmB,WAAW,GAAG;AAGvC,UAAI,OAAO,0BAAyB;AAEpC,UAAI,CAAC,QAAQ,QAAQ;AAClB,eAAO,KAAK,SACT,wBAAuB,oDACvB;AAAA;AAIN,aAAO,KAAK,SAAS,2BAA0B,UAAU;AAAA;AAG5D,SAAI,UAAU,eAAe,SAAU,MAAM,MAAM,MAAM;AACtD,aAAO,KAAK,SACT,kBAAiB,MAAM,OACvB,0BAAyB;AAAA;AAI/B,SAAI,UAAU,kBAAkB,SAAU,MAAM,MAAM;AACnD,aAAO,KAAK,SACT,qBAAoB,oBAAmB,WAAW,QAClD,0BAAyB;AAAA;AAI/B,SAAI,UAAU,gBAAgB,SAAU,MAAM,MAAM;AACjD,aAAO,KAAK,SACT,mBAAkB,oBAAmB,WAAW,QAChD,0BAAyB;AAAA;AAI/B,SAAI,UAAU,YAAY,SAAU,SAAS,MAAM;AAChD,aAAO,KAAK,SACT,eAAc,oBAAmB,aACjC,0BAAyB;AAAA;AAI/B,SAAI,UAAU,aAAa,WAAY;AACpC,aAAO,KAAK,SACT,iBAAgB,oBAAmB,aACnC,0BAAyB;AAAA;AAO/B,SAAI,UAAU,YAAY,SAAU,YAAY,YAAY,MAAM;AAC/D,aAAO,KAAK,SACT,eAAc,YAAY,YAAY,oBAAmB,aACzD,0BAAyB;AAAA;AAO/B,SAAI,UAAU,eAAe,SAAU,YAAY,MAAM;AACtD,aAAO,KAAK,SACT,kBAAiB,aACjB,0BAAyB;AAAA;AAQ/B,SAAI,UAAU,aAAa,SAAU,SAAS,MAAM;AACjD,aAAO,KAAK,SACT,gBAAe,YAAY,OAC3B,0BAAyB;AAAA;AAU/B,SAAI,UAAU,SAAS,SAAU,SAAS,MAAM;AAC7C,aAAO,KAAK,SACT,YAAW,oBAAmB,aAC9B,0BAAyB;AAAA;AAU/B,SAAI,UAAU,MAAM,SAAU,SAAS,MAAM;AAC1C,YAAM,UAAU,oBAAmB;AAEnC,UAAI,QAAQ,OAAO,OAAO;AACvB,gBAAQ,QAAQ;AAAA;AAGnB,aAAO,KAAK,SACT,2BAA0B,UAC1B,0BAAyB;AAAA;AAS/B,SAAI,UAAU,mBAAmB,SAAU,MAAM;AAC9C,aAAO,KAAK,SACT,2BAA0B,CAAC,wBAC3B,0BAAyB;AAAA;AAW/B,SAAI,UAAU,WAAW,SAAU,QAAQ,MAAM;AAC9C,YAAM,OAAO,cAAa,EAAC,QAAQ,YAAW,QAAQ,kBAAgB,oBAAmB;AAEzF,aAAO,KAAK,SAAS,MAAM,0BAAyB;AAAA;AAMvD,SAAI,UAAU,KAAK,SAAU,OAAO;AACjC,aAAO,KAAK,SACT,2BAA0B,CAAC,MAAM,MAAM,GAAG,SAAQ,UAClD,0BAAyB;AAAA;AAU/B,SAAI,UAAU,cAAc,SAAU,OAAO;AAC1C,aAAO,KAAK,SACT,2BAA0B,CAAC,MAAM,YAAY,GAAG,SAAQ,UACxD,0BAAyB;AAAA;AAa/B,SAAI,UAAU,UAAU,SAAU,SAAS,MAAM;AAC9C,aAAO,KAAK,SAAS,SAAS;AAAA;AAGjC,SAAI,UAAU,gBAAgB,WAAY;AACvC,aAAO,KAAK,SAAS,UAAU;AAAA;AAGlC,SAAI,UAAU,WAAW,SAAU,QAAQ,MAAM;AAC9C,UAAI,UAAU,0BAAyB;AACvC,UAAI,UAAU,CAAC;AACf,UAAI,UAAU,KAAK;AAEnB,UAAI,OAAO,YAAY,UAAU;AAC9B,eAAO,KAAK,SACT,wBAAuB,iEACvB;AAAA;AAIN,UAAI,MAAM,QAAQ,UAAU;AACzB,gBAAQ,KAAK,MAAM,SAAS;AAAA;AAG/B,YAAM,OAAO,WAAW,WACnB,2BAA0B,WAC1B,2BAA0B;AAE/B,aAAO,KAAK,SAAS,MAAM;AAAA;AAG9B,SAAI,UAAU,OAAO,SAAU,SAAS,MAAM;AAC3C,YAAM,OAAO,cAAa,WACrB,wBAAuB,0GACvB,2BAA0B,CAAC,QAAQ,GAAG,oBAAmB;AAE9D,aAAO,KAAK,SACT,MACA,0BAAyB;AAAA;AAI/B,SAAI,UAAU,cAAc,WAAY;AACrC,aAAO,KAAK,SACT,iBAAgB,oBAAmB,WAAW,KAC9C,0BAAyB;AAAA;AAI/B,SAAI,UAAU,aAAa,SAAU,SAAS;AAC3C,YAAM,OAAO,CAAC,2BAA0B,WACnC,wBAAuB,8EACvB,gBAAe,SAAQ,UAAU,oBAAmB,GAAG,MAAM,KAAK,WAAW;AAElF,aAAO,KAAK,SACT,MACA,0BAAyB;AAAA;AAI/B,SAAI,UAAU,WAAW,WAAY;AAClC,YAAM,WAAW,CAAC,aAAa,GAAG,oBAAmB,WAAW;AAChE,aAAO,KAAK,SACT,2BAA0B,UAAU,OACpC,0BAAyB;AAAA;AAU/B,SAAI,UAAU,OAAO,SAAU,SAAS,MAAM;AAC3C,aAAO,KAAK,SACT,2BAA0B,CAAC,QAAQ,GAAG,oBAAmB,WAAW,MACpE,0BAAyB;AAAA;AAM/B,SAAI,UAAU,QAAQ,SAAU,MAAM,SAAS,MAAM;AAClD,YAAM,yBAAyB,qBAAoB;AACnD,YAAM,YAAY,0BAA0B,KAAK,KAAK,OAAO,YAAW,MAAM,kBAAiB;AAC/F,YAAM,aAAa,oBAAmB,GAAG,MAAM,KAAK,WAAW,yBAAyB,IAAI;AAE5F,aAAO,KAAK,SACT,sBAAqB,WAAW,aAChC,0BAAyB;AAAA;AAI/B,SAAI,UAAU,OAAO,SAAU,MAAM;AAClC,YAAM,OAAO;AAAA,QACV,UAAU;AAAA,QACV,QAAQ;AAAA,QACR,SAAU;AACP,cAAI,OAAO,SAAS,YAAY;AAC7B;AAAA;AAAA;AAAA;AAKT,aAAO,KAAK,SAAS;AAAA;AAQxB,SAAI,UAAU,aAAa,WAAY;AAGpC,aAAO;AAAA;AASV,SAAI,UAAU,cAAc,SAAU,WAAW,MAAM;AACpD,aAAO,KAAK,SACT,iBAAgB,SAAS,YAAW,WAAW,4BAA2B,OAC1E,0BAAyB;AAAA;AAI/B,SAAI,UAAU,cAAc,SAAU,WAAW,MAAM;AACpD,aAAO,KAAK,SACT,iBAAgB,YAAW,WAAW,iBACtC,0BAAyB;AAAA;AAI/B,WAAO,UAAU;AAAA;AAAA;;;ACjpBjB;AAYO,sCAAgC,SAAS;AAAA,EAE7C,YACmB,QAChB,SACD;AACC,UAAM,QAAW;AAHD;AAAA;AAAA;;;ACdtB;;;ACAA;AAEO,mCAA6B,SAAS;AAAA,EAE1C,YACU,MACS,QAChB,SACD;AACC,UAAM,MAAM;AAJL;AACS;AAIhB,WAAO,eAAe,MAAM,WAAW;AAAA;AAAA;;;ADR7C;AACA;AACA;AACA;AACA;AACA;AACA;;;AETA;AAGO,sCAAsC,eAAwD;AAClG,QAAM,SAAS,cAAc,eAAe;AAE5C,SAAO;AAAA,IACJ,MAAM;AAAA,IACN,OAAO,MAAM;AACV,aAAO,CAAC,GAAG,QAAQ,GAAG;AAAA;AAAA;AAAA;;;ACP/B;AAFA;AAKA,IAAM,QAAQ,WAAW;AAElB,mCAAmC;AAAA,EACG,UAAU;AAAA,EACV,SAAS;AAAA,IAC6B,IAAoC;AAEpH,0BAAwB;AACrB,QAAI,WAAW;AACf,UAAM,SAAS;AAAA,MACZ,OAAO;AAAA,MACP,cAAc;AAAA,MACd,MAAM;AAAA,MACN,aAAa;AAAA;AAGhB,UAAM,SAAS,QAAQ,KAAK;AAAA,MACzB,YAAY,QAAQ,QAAQ,OAAO,aAAa;AAAA,MAChD,WAAW,QAAQ,QAAQ,OAAO,YAAY;AAAA;AAGjD,qBAAiB,SAAS,OAAO,OAAO,OAAO;AAC/C,qBAAiB,QAAQ,OAAO,MAAM,OAAO;AAE7C,WAAO;AAAA,MACJ,MAAM,MAAc;AACjB,mBAAW;AACX,eAAO,MAAM;AAAA;AAAA,MAEhB,KAAK,MAAc;AAChB,mBAAW;AACX,eAAO,KAAK;AAAA;AAAA,UAEX,WAAW;AACZ,eAAO;AAAA;AAAA,MAEV;AAAA;AAAA;AAIN,4BAA0B,MAAwB,OAA8B,SAAgC;AAC7G,QAAI,SAAS,OAAO;AACjB;AAAA;AAGH,IAAC,UAAS,OAAO,MAAM,UAAU,MAAM,QAAQ,KAAK,MAAM,MAAM,QAAQ,KAAK,QAAQ;AAAA;AAGxF,SAAO;AAAA,IACJ,MAAM;AAAA,IACA,OAAO,IAAO,IAAkB;AAAA,iDAAzB,OAAO,EAAC,SAAS,SAAQ;AAvD5C;AAwDS,cAAM,SAAS;AAEf,YAAI,aAAa;AACjB,YAAI,aAAa,MAAM,KAAM,cAAa;AAE1C,uBAAQ,WAAR,oBAAgB,GAAG,QAAQ;AAC3B,sBAAQ,WAAR,mBAAgB,GAAG,QAAQ;AAC3B,gBAAQ,GAAG,SAAS;AAEpB,gBAAQ,GAAG,SAAS,CAAC,SAAiB,OAAO,MAAM;AACnD,gBAAQ,GAAG,QAAQ,CAAC,SAAiB,OAAO,KAAK;AAEjD,YAAG;AACA,gBAAM,OAAO;AACb,cAAI,YAAY;AACb,kBAAM,MAAM;AAAA;AAEf,gBAAM,OAAO;AAAA,iBAET,KAAP;AACG,gBAAM,OAAO,UAAU;AAAA;AAAA;AAAA;AAAA;AAAA;;;AC5EnC;AAMA,qBAAsB,QAAoB;AACvC,SAAO,CAAC,CAAE,QAAO,YAAY,OAAO,OAAO;AAAA;AAG9C,yBAA0B,QAAoB;AAC3C,SAAO,OAAO,OAAO,CAAC,GAAG,OAAO,QAAQ,GAAG,OAAO;AAAA;AAG9C,+BAAgC,YAAY,OAAO,UAAU,aAAa,eAAuD,iBAAiB;AAEtJ,SAAO,CAAC,OAAmC,WAAuB;AAC/D,QAAK,CAAC,aAAa,SAAU,CAAC,QAAQ,SAAS;AAC5C,aAAO;AAAA;AAGV,WAAO,aAAa;AAAA;AAAA;AAInB,8BAA8B,QAAwE;AAE1G,SAAO;AAAA,IACJ,MAAM;AAAA,IACN,OAAO,MAAM,SAAS;AACnB,YAAM,QAAQ,OAAO,KAAK,OAAO;AAAA,QAC9B,QAAQ,QAAQ;AAAA,QAChB,QAAQ,QAAQ;AAAA,QAChB,UAAU,QAAQ;AAAA;AAGrB,UAAI,OAAO,SAAS,QAAQ;AACzB,eAAO,EAAC,OAAO,IAAI,SAAS,QAAW,MAAM,SAAS;AAAA;AAGzD,aAAO;AAAA,QACJ;AAAA;AAAA;AAAA;AAAA;;;ACxCZ;AAEO,wBAAkB;AAAA,EAAlB,cAHP;AAKW,mBAAqD,oBAAI;AAAA;AAAA,EAE1D,IAAmC,QAA0D;AACjG,UAAM,UAAgC;AAEtC,YAAQ,QAAQ,QAAQ,aAAU,WAAU,KAAK,QAAQ,IAAI,OAAO,SAAS;AAE7E,WAAO,MAAM;AACV,cAAQ,QAAQ,aAAU,KAAK,QAAQ,OAAO;AAAA;AAAA;AAAA,EAI7C,KAAoC,MAAS,MAAuC,SAA0D;AAClJ,QAAI,SAAS;AACb,UAAM,aAAa,OAAO,OAAO,OAAO,OAAO;AAE/C,eAAW,UAAU,KAAK,SAAS;AAChC,UAAI,OAAO,SAAS,MAAM;AACvB,iBAAS,OAAO,OAAO,QAAQ;AAAA;AAAA;AAIrC,WAAO;AAAA;AAAA;;;AC1Bb;AAIO,+BAA+B,UAAuD;AAC1F,QAAM,kBAAkB;AACxB,QAAM,kBAAkB,CAAC,YAAY,SAAS,SAAS,QAAQ;AAE/D,QAAM,aAA6C;AAAA,IAChD,MAAM;AAAA,IACN,OAAO,OAAO,SAAS;AAX7B;AAYS,UAAI,CAAC,QAAQ,SAAS,SAAS,kBAAkB;AAC9C;AAAA;AAGH,qBAAQ,QAAQ,WAAhB,oBAAwB,GAAG,QAAQ,CAAC,UAAkB;AACnD,cAAM,UAAU,yCAAyC,KAAK,MAAM,SAAS;AAC7E,YAAI,CAAC,SAAS;AACX;AAAA;AAGH,iBAAS;AAAA,UACN,QAAQ,QAAQ;AAAA,UAChB,OAAO,mBAAmB,QAAQ;AAAA,UAClC,UAAU,SAAS,QAAQ;AAAA,UAC3B,WAAW,SAAS,QAAQ;AAAA,UAC5B,OAAO,SAAS,QAAQ;AAAA;AAAA;AAAA;AAAA;AAMpC,QAAM,SAAwC;AAAA,IAC3C,MAAM;AAAA,IACN,OAAO,MAAM,SAAS;AACnB,UAAI,CAAC,gBAAgB,SAAS,QAAQ,SAAS;AAC5C,eAAO;AAAA;AAGV,aAAO,UAAU,MAAM;AAAA;AAAA;AAI7B,SAAO,CAAC,QAAQ;AAAA;AAGnB,4BAA6B,OAAe;AACzC,SAAO,OAAO,MAAM,cAAc,MAAM,KAAK,OAAO;AAAA;;;AC/CvD;AAGO,4BAA4B,cAAuE;AACvG,QAAM,UAAU,KAAK,cAAc,CAAC,OAAO;AAE3C,SAAO;AAAA,IACJ,MAAM;AAAA,IACN,OAAO,MAAM;AACV,aAAO,kCAAI,UAAY;AAAA;AAAA;AAAA;;;ACLzB,uBAAuB,EAAC,SAAgG;AAE5H,MAAI,QAAQ,GAAG;AACZ,WAAO;AAAA,MACJ,MAAM;AAAA,MACN,OAAO,OAAO,SAAS;AAVhC;AAWY,YAAI;AAEJ,wBAAgB;AACb,qBAAW,aAAa;AACxB,oBAAU,WAAW,MAAM;AAAA;AAG9B,wBAAgB;AAlB5B;AAmBe,yBAAQ,QAAQ,WAAhB,oBAAwB,IAAI,QAAQ;AACpC,yBAAQ,QAAQ,WAAhB,oBAAwB,IAAI,QAAQ;AACpC,kBAAQ,QAAQ,IAAI,QAAQ;AAC5B,kBAAQ,QAAQ,IAAI,SAAS;AAC7B,qBAAW,aAAa;AAAA;AAG3B,wBAAgB;AACb;AACA,kBAAQ,KACL,IAAI,eAAe,QAAW,WAAW;AAAA;AAI/C,uBAAQ,QAAQ,WAAhB,oBAAwB,GAAG,QAAQ;AACnC,sBAAQ,QAAQ,WAAhB,mBAAwB,GAAG,QAAQ;AACnC,gBAAQ,QAAQ,GAAG,QAAQ;AAC3B,gBAAQ,QAAQ,GAAG,SAAS;AAE5B;AAAA;AAAA;AAAA;AAAA;;;ACzBZ;AAGA,IAAM,MAAM;AAwBL,4BAA4B,SAA8C,SAAqC;AACnH,QAAM,UAAU,IAAI;AACpB,QAAM,SAAS,qBACZ,WAAY,QAAO,YAAY,WAAW,EAAC,YAAW,YAAY,IAClE;AAGH,MAAI,CAAC,aAAa,OAAO,UAAU;AAChC,UAAM,IAAQ,kBAAkB,QAAQ;AAAA;AAG3C,MAAI,MAAM,QAAQ,OAAO,SAAS;AAC/B,YAAQ,IAAI,6BAA6B,OAAO;AAAA;AAGnD,UAAQ,IAAI,0BAA0B,OAAO;AAC7C,SAAO,YAAY,QAAQ,IAAI,sBAAsB,OAAO;AAC5D,SAAO,WAAW,QAAQ,IAAI,cAAc,OAAO;AACnD,SAAO,gBAAgB,QAAQ,IAAI,mBAAmB,OAAO;AAE7D,UAAQ,IAAI,qBAAqB,sBAAsB;AACvD,SAAO,UAAU,QAAQ,IAAI,qBAAqB,OAAO;AAEzD,SAAO,IAAI,IAAI,QAAQ;AAAA;;;AC7D1B;AAIA,IAAM,0BAA0B;AAAA,EAC7B;AAAA,EAAgB;AAAA,EAAO;AAAA,EAAiB;AAAA;AAG3C,IAAM,0BAA0B;AAAA,EAC7B;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA;AAGI,iBAAiB,MAAoG;AAEzH,MAAI;AAEJ,MAAI,QAAQ,QAAQ;AAEpB,MAAI;AACD,UAAM,mBAAmB,GAAG;AAAA,WACtB,GAAP;AACC,YAAQ,QAAQ,OAAO;AAAA;AAG1B,2BAAyB;AACtB,WAAO;AAAA;AAGV,yBAAuB;AACpB,WAAO;AAAA;AAGV,QAAM,aAAa,CAAC,GAAG,yBAAyB,GAAG,yBAAyB,OAAO,CAAC,KAAU,SAAiB;AAC5G,UAAM,UAAU,wBAAwB,SAAS;AAEjD,UAAM,QAAQ,UAAU,aAAa,MAAM,OAAO,YAAY,MAAM,KAAK;AACzE,UAAM,cAAc,UAAU,cAAc;AAE5C,WAAO,eAAe,KAAK,MAAM;AAAA,MAC9B,YAAY;AAAA,MACZ,cAAc;AAAA,MACd,OAAO,MAAM,QAAQ;AAAA;AAGxB,WAAO;AAAA,KACP;AAEH,SAAO;AAEP,wBAAsB,IAAY,MAA4C;AAC3E,WAAO,YAAa,OAAa;AAC9B,UAAI,OAAO,MAAK,MAAK,YAAY,YAAY;AAC1C,cAAM,IAAI,UACP,gHAC8C;AAAA;AAGpD,aAAO,MAAM,KAAK,WAAY;AAC3B,eAAO,IAAI,QAAQ,SAAU,SAAS,QAAQ;AAC3C,gBAAM,WAAkC,CAAC,KAAmB,WAAiB;AAC1E,gBAAI,KAAK;AACN,qBAAO,OAAO,QAAQ;AAAA;AAGzB,oBAAQ;AAAA;AAEX,gBAAK,KAAK;AAEV,eAAI,IAAI,MAAM,MAAK;AAAA;AAAA;AAAA;AAAA;AAM/B,uBAAqB,IAAY,MAAU,KAAgB;AACxD,WAAO,IAAI,UAAgB;AACxB,WAAI,IAAI,GAAG;AAEX,aAAO;AAAA;AAAA;AAAA;AAKhB,iBAAiB,OAAoC;AAElD,MAAI,iBAAiB,OAAO;AACzB,WAAO;AAAA;AAGV,MAAI,OAAO,UAAU,UAAU;AAC5B,WAAO,IAAI,MAAM;AAAA;AAGpB,SAAO,IAAI,iBAAiB;AAAA;;;ACnJ/B,IAAO,cAAQ;",
   "names": []
 }
diff --git a/node_modules/simple-git/dist/src/lib/args/log-format.d.ts b/node_modules/simple-git/dist/src/lib/args/log-format.d.ts
deleted file mode 100644
index 4874e16..0000000
--- a/node_modules/simple-git/dist/src/lib/args/log-format.d.ts
+++ /dev/null
@@ -1,9 +0,0 @@
-export declare enum LogFormat {
-    NONE = "",
-    STAT = "--stat",
-    NUM_STAT = "--numstat",
-    NAME_ONLY = "--name-only",
-    NAME_STATUS = "--name-status"
-}
-export declare function logFormatFromCommand(customArgs: string[]): LogFormat;
-export declare function isLogFormat(customArg: string | unknown): boolean;
diff --git a/node_modules/simple-git/dist/src/lib/errors/git-error.d.ts b/node_modules/simple-git/dist/src/lib/errors/git-error.d.ts
index 2eff39b..a0677ab 100644
--- a/node_modules/simple-git/dist/src/lib/errors/git-error.d.ts
+++ b/node_modules/simple-git/dist/src/lib/errors/git-error.d.ts
@@ -1,4 +1,3 @@
-import type { SimpleGitTask } from '../types';
 /**
  * The `GitError` is thrown when the underlying `git` process throws a
  * fatal exception (eg an `ENOENT` exception when attempting to use a
@@ -25,6 +24,6 @@ import type { SimpleGitTask } from '../types';
  ```
  */
 export declare class GitError extends Error {
-    task?: SimpleGitTask<any> | undefined;
-    constructor(task?: SimpleGitTask<any> | undefined, message?: string);
+    task?: import("../tasks/task").EmptyTask | import("../types").StringTask<any> | import("../types").BufferTask<any> | undefined;
+    constructor(task?: import("../tasks/task").EmptyTask | import("../types").StringTask<any> | import("../types").BufferTask<any> | undefined, message?: string);
 }
diff --git a/node_modules/simple-git/dist/src/lib/errors/git-plugin-error.d.ts b/node_modules/simple-git/dist/src/lib/errors/git-plugin-error.d.ts
index 94d4f8b..17aed24 100644
--- a/node_modules/simple-git/dist/src/lib/errors/git-plugin-error.d.ts
+++ b/node_modules/simple-git/dist/src/lib/errors/git-plugin-error.d.ts
@@ -1,7 +1,6 @@
-import { SimpleGitOptions, SimpleGitTask } from '../types';
 import { GitError } from './git-error';
 export declare class GitPluginError extends GitError {
-    task?: SimpleGitTask<any> | undefined;
-    readonly plugin?: keyof SimpleGitOptions | undefined;
-    constructor(task?: SimpleGitTask<any> | undefined, plugin?: keyof SimpleGitOptions | undefined, message?: string);
+    task?: import("../tasks/task").EmptyTask | import("../types").StringTask<any> | import("../types").BufferTask<any> | undefined;
+    readonly plugin?: "progress" | "timeout" | "completion" | "errors" | "spawnOptions" | "baseDir" | "binary" | "maxConcurrentProcesses" | "config" | undefined;
+    constructor(task?: import("../tasks/task").EmptyTask | import("../types").StringTask<any> | import("../types").BufferTask<any> | undefined, plugin?: "progress" | "timeout" | "completion" | "errors" | "spawnOptions" | "baseDir" | "binary" | "maxConcurrentProcesses" | "config" | undefined, message?: string);
 }
diff --git a/node_modules/simple-git/dist/src/lib/git-factory.d.ts b/node_modules/simple-git/dist/src/lib/git-factory.d.ts
index 12a608f..ed550dd 100644
--- a/node_modules/simple-git/dist/src/lib/git-factory.d.ts
+++ b/node_modules/simple-git/dist/src/lib/git-factory.d.ts
@@ -11,5 +11,5 @@ export declare function esModuleFactory<T>(defaultExport: T): T & {
     __esModule: true;
     default: T;
 };
-export declare function gitExportFactory(factory: SimpleGitFactory): SimpleGitFactory & typeof api;
+export declare function gitExportFactory<T = {}>(factory: SimpleGitFactory, extra: T): ((options: Partial<SimpleGitOptions>) => import("../../typings").SimpleGit) & typeof api;
 export declare function gitInstanceFactory(baseDir?: string | Partial<SimpleGitOptions>, options?: Partial<SimpleGitOptions>): any;
diff --git a/node_modules/simple-git/dist/src/lib/parsers/parse-branch.d.ts b/node_modules/simple-git/dist/src/lib/parsers/parse-branch.d.ts
index 7c0fe2a..3c39c29 100644
--- a/node_modules/simple-git/dist/src/lib/parsers/parse-branch.d.ts
+++ b/node_modules/simple-git/dist/src/lib/parsers/parse-branch.d.ts
@@ -1,2 +1,2 @@
-import type { BranchSummary } from '../../../typings';
+import { BranchSummary } from '../../../typings';
 export declare function parseBranchSummary(stdOut: string): BranchSummary;
diff --git a/node_modules/simple-git/dist/src/lib/parsers/parse-diff-summary.d.ts b/node_modules/simple-git/dist/src/lib/parsers/parse-diff-summary.d.ts
index 4528dc4..baaeb64 100644
--- a/node_modules/simple-git/dist/src/lib/parsers/parse-diff-summary.d.ts
+++ b/node_modules/simple-git/dist/src/lib/parsers/parse-diff-summary.d.ts
@@ -1,3 +1,2 @@
-import { LogFormat } from '../args/log-format';
-import { DiffSummary } from '../responses/DiffSummary';
-export declare function getDiffParser(format?: LogFormat): (stdOut: string) => DiffSummary;
+import { DiffResult } from '../../../typings';
+export declare function parseDiffResult(stdOut: string): DiffResult;
diff --git a/node_modules/simple-git/dist/src/lib/parsers/parse-list-log-summary.d.ts b/node_modules/simple-git/dist/src/lib/parsers/parse-list-log-summary.d.ts
index e4a30da..113af34 100644
--- a/node_modules/simple-git/dist/src/lib/parsers/parse-list-log-summary.d.ts
+++ b/node_modules/simple-git/dist/src/lib/parsers/parse-list-log-summary.d.ts
@@ -1,6 +1,5 @@
 import { LogResult } from '../../../typings';
-import { LogFormat } from '../args/log-format';
 export declare const START_BOUNDARY = "\u00F2\u00F2\u00F2\u00F2\u00F2\u00F2 ";
 export declare const COMMIT_BOUNDARY = " \u00F2\u00F2";
 export declare const SPLITTER = " \u00F2 ";
-export declare function createListLogSummaryParser<T = any>(splitter?: string, fields?: string[], logFormat?: LogFormat): (stdOut: string) => LogResult<T>;
+export declare function createListLogSummaryParser<T = any>(splitter?: string, fields?: string[]): (stdOut: string) => LogResult<T>;
diff --git a/node_modules/simple-git/dist/src/lib/responses/BranchSummary.d.ts b/node_modules/simple-git/dist/src/lib/responses/BranchSummary.d.ts
index 9aa3342..69cd698 100644
--- a/node_modules/simple-git/dist/src/lib/responses/BranchSummary.d.ts
+++ b/node_modules/simple-git/dist/src/lib/responses/BranchSummary.d.ts
@@ -1,8 +1,4 @@
-import type { BranchSummary, BranchSummaryBranch } from '../../../typings';
-export declare enum BranchStatusIdentifier {
-    CURRENT = "*",
-    LINKED = "+"
-}
+import { BranchSummary, BranchSummaryBranch } from '../../../typings';
 export declare class BranchSummaryResult implements BranchSummary {
     all: string[];
     branches: {
@@ -10,5 +6,5 @@ export declare class BranchSummaryResult implements BranchSummary {
     };
     current: string;
     detached: boolean;
-    push(status: BranchStatusIdentifier | unknown, detached: boolean, name: string, commit: string, label: string): void;
+    push(current: boolean, detached: boolean, name: string, commit: string, label: string): void;
 }
diff --git a/node_modules/simple-git/dist/src/lib/tasks/diff.d.ts b/node_modules/simple-git/dist/src/lib/tasks/diff.d.ts
index 8bcd1f2..c1e37aa 100644
--- a/node_modules/simple-git/dist/src/lib/tasks/diff.d.ts
+++ b/node_modules/simple-git/dist/src/lib/tasks/diff.d.ts
@@ -1,5 +1,3 @@
 import { StringTask } from '../types';
 import { DiffResult } from '../../../typings';
-import { EmptyTask } from './task';
-export declare function diffSummaryTask(customArgs: string[]): StringTask<DiffResult> | EmptyTask;
-export declare function validateLogFormatConfig(customArgs: unknown[]): EmptyTask | void;
+export declare function diffSummaryTask(customArgs: string[]): StringTask<DiffResult>;
diff --git a/node_modules/simple-git/dist/src/lib/tasks/log.d.ts b/node_modules/simple-git/dist/src/lib/tasks/log.d.ts
index cc9293b..d58a446 100644
--- a/node_modules/simple-git/dist/src/lib/tasks/log.d.ts
+++ b/node_modules/simple-git/dist/src/lib/tasks/log.d.ts
@@ -1,5 +1,5 @@
-import type { Options, StringTask } from '../types';
-import type { LogResult, SimpleGit } from '../../../typings';
+import { Options, StringTask } from '../types';
+import { LogResult, SimpleGit } from '../../../typings';
 export interface DefaultLogFields {
     hash: string;
     date: string;
diff --git a/node_modules/simple-git/dist/src/lib/tasks/stash-list.d.ts b/node_modules/simple-git/dist/src/lib/tasks/stash-list.d.ts
index 9470967..5bf9a9c 100644
--- a/node_modules/simple-git/dist/src/lib/tasks/stash-list.d.ts
+++ b/node_modules/simple-git/dist/src/lib/tasks/stash-list.d.ts
@@ -1,4 +1,3 @@
 import { LogOptions, LogResult } from '../../../typings';
-import type { StringTask } from '../types';
-import type { EmptyTask } from './task';
-export declare function stashListTask(opt: LogOptions<import("./log").DefaultLogFields> | undefined, customArgs: string[]): EmptyTask | StringTask<LogResult>;
+import { StringTask } from '../types';
+export declare function stashListTask(opt: LogOptions<import("./log").DefaultLogFields> | undefined, customArgs: string[]): StringTask<LogResult>;
diff --git a/node_modules/simple-git/dist/src/lib/tasks/task.d.ts b/node_modules/simple-git/dist/src/lib/tasks/task.d.ts
index 4f8c6c0..9c64e4e 100644
--- a/node_modules/simple-git/dist/src/lib/tasks/task.d.ts
+++ b/node_modules/simple-git/dist/src/lib/tasks/task.d.ts
@@ -1,4 +1,4 @@
-import type { BufferTask, EmptyTaskParser, SimpleGitTask, StringTask } from '../types';
+import { BufferTask, EmptyTaskParser, SimpleGitTask, StringTask } from '../types';
 export declare const EMPTY_COMMANDS: [];
 export declare type EmptyTask = {
     commands: typeof EMPTY_COMMANDS;
diff --git a/node_modules/simple-git/dist/src/lib/types/index.d.ts b/node_modules/simple-git/dist/src/lib/types/index.d.ts
index 4fe0734..7dbd521 100644
--- a/node_modules/simple-git/dist/src/lib/types/index.d.ts
+++ b/node_modules/simple-git/dist/src/lib/types/index.d.ts
@@ -1,6 +1,4 @@
 /// <reference types="node" />
-/// <reference types="node" />
-/// <reference types="node" />
 import type { SpawnOptions } from 'child_process';
 import type { SimpleGitTask } from './tasks';
 import type { SimpleGitProgressEvent } from './handlers';
diff --git a/node_modules/simple-git/dist/src/lib/utils/task-parser.d.ts b/node_modules/simple-git/dist/src/lib/utils/task-parser.d.ts
index b1a62b8..5734495 100644
--- a/node_modules/simple-git/dist/src/lib/utils/task-parser.d.ts
+++ b/node_modules/simple-git/dist/src/lib/utils/task-parser.d.ts
@@ -1,5 +1,5 @@
-import type { MaybeArray, TaskParser, TaskResponseFormat } from '../types';
+import { TaskParser, TaskResponseFormat } from '../types';
 import { GitOutputStreams } from './git-output-streams';
 import { LineParser } from './line-parser';
 export declare function callTaskParser<INPUT extends TaskResponseFormat, RESPONSE>(parser: TaskParser<INPUT, RESPONSE>, streams: GitOutputStreams<INPUT>): RESPONSE;
-export declare function parseStringResponse<T>(result: T, parsers: LineParser<T>[], texts: MaybeArray<string>, trim?: boolean): T;
+export declare function parseStringResponse<T>(result: T, parsers: LineParser<T>[], ...texts: string[]): T;
diff --git a/node_modules/simple-git/dist/typings/index.d.ts b/node_modules/simple-git/dist/typings/index.d.ts
index 12449c3..fc284f2 100644
--- a/node_modules/simple-git/dist/typings/index.d.ts
+++ b/node_modules/simple-git/dist/typings/index.d.ts
@@ -7,6 +7,5 @@ export * from './types';
 
 export declare const gitP: SimpleGitFactory;
 
-export declare const simpleGit: SimpleGitFactory;
-
+declare const simpleGit: SimpleGitFactory;
 export default simpleGit;
diff --git a/node_modules/simple-git/dist/typings/response.d.ts b/node_modules/simple-git/dist/typings/response.d.ts
index 19a22ef..795e5af 100644
--- a/node_modules/simple-git/dist/typings/response.d.ts
+++ b/node_modules/simple-git/dist/typings/response.d.ts
@@ -5,7 +5,6 @@ export interface BranchSummaryBranch {
    name: string;
    commit: string;
    label: string;
-   linkedWorkTree: boolean;
 }
 
 export interface BranchSummary {
diff --git a/node_modules/simple-git/package.json b/node_modules/simple-git/package.json
index 02b4232..476da3e 100644
--- a/node_modules/simple-git/package.json
+++ b/node_modules/simple-git/package.json
@@ -1,7 +1,7 @@
 {
   "name": "simple-git",
   "description": "Simple GIT interface for node.js",
-  "version": "3.10.0",
+  "version": "3.7.1",
   "author": "Steve King <steve@mydev.co>",
   "contributors": [
     {
@@ -11,16 +11,16 @@
   ],
   "funding": {
     "type": "github",
-    "url": "https://github.com/steveukx/git-js?sponsor=1"
+    "url": "https://github.com/sponsors/steveukx/"
   },
   "dependencies": {
     "@kwsites/file-exists": "^1.1.1",
     "@kwsites/promise-deferred": "^1.1.1",
-    "debug": "^4.3.4"
+    "debug": "^4.3.3"
   },
   "devDependencies": {
-    "@kwsites/promise-result": "^1.1.0",
     "@simple-git/babel-config": "^1.0.0",
+    "@kwsites/promise-result": "^1.1.0",
     "@types/debug": "^4.1.5",
     "@types/jest": "^27.0.3",
     "@types/node": "^14.14.10",
@@ -51,7 +51,8 @@
     },
     "./promise": {
       "require": "./promise.js"
-    }
+    },
+    "./package.json": "./package.json"
   },
   "types": "./dist/typings/index.d.ts",
   "files": [
diff --git a/node_modules/simple-git/readme.md b/node_modules/simple-git/readme.md
index fc5ca3e..fa03eb0 100644
--- a/node_modules/simple-git/readme.md
+++ b/node_modules/simple-git/readme.md
@@ -30,14 +30,14 @@ const simpleGit = require('simple-git');
 simpleGit().clean(simpleGit.CleanOptions.FORCE);
 
 // or use named properties
-const {simpleGit, CleanOptions} = require('simple-git');
+const {default: simpleGit, CleanOptions} = require('simple-git');
 simpleGit().clean(CleanOptions.FORCE);
 ```
 
 Include into your JavaScript app as an ES Module:
 
 ```javascript
-import { simpleGit, CleanOptions } from 'simple-git';
+import simpleGit, { CleanOptions } from 'simple-git';
 
 simpleGit().clean(CleanOptions.FORCE);
 ```
@@ -45,7 +45,7 @@ simpleGit().clean(CleanOptions.FORCE);
 Include in a TypeScript app using the bundled type definitions:
 
 ```typescript
-import { simpleGit, SimpleGit, CleanOptions } from 'simple-git';
+import simpleGit, { SimpleGit, CleanOptions } from 'simple-git';
 
 const git: SimpleGit = simpleGit().clean(CleanOptions.FORCE);
 ```
@@ -55,7 +55,7 @@ const git: SimpleGit = simpleGit().clean(CleanOptions.FORCE);
 Configure each `simple-git` instance with a properties object passed to the main `simpleGit` function:
 
 ```typescript
-import { simpleGit, SimpleGit, SimpleGitOptions } from 'simple-git';
+import simpleGit, { SimpleGit, SimpleGitOptions } from 'simple-git';
 
 const options: Partial<SimpleGitOptions> = {
    baseDir: process.cwd(),
@@ -186,6 +186,10 @@ For type details of the response for each of the tasks, please see the [TypeScri
 | `.commit(message, handlerFn)` | commits changes in the current working directory with the supplied message where the message can be either a single string or array of strings to be passed as separate arguments (the `git` command line interface converts these to be separated by double line breaks) |
 | `.commit(message, [fileA, ...], options, handlerFn)` | commits changes on the named files with the supplied message, when supplied, the optional options object can contain any other parameters to pass to the commit command, setting the value of the property to be a string will add `name=value` to the command string, setting any other type of value will result in just the key from the object being passed (ie: just `name`), an example of setting the author is below |
 | `.customBinary(gitPath)` | sets the command to use to reference git, allows for using a git binary not available on the path environment variable |
+| `.diff(options, handlerFn)` | get the diff of the current repo compared to the last commit with a set of options supplied as a string |
+| `.diff(handlerFn)` | get the diff for all file in the current repo compared to the last commit |
+| `.diffSummary(handlerFn)` | gets a summary of the diff for files in the repo, uses the `git diff --stat` format to calculate changes. Handler is called with a nullable error object and an instance of the [DiffSummary](https://github.com/steveukx/git-js/blob/main/simple-git/src/lib/responses/DiffSummary.js) |
+| `.diffSummary(options, handlerFn)` | includes options in the call to `diff --stat options` and returns a [DiffSummary](https://github.com/steveukx/git-js/blob/main/simple-git/src/lib/responses/DiffSummary.js) |
 | `.env(name, value)` | Set environment variables to be passed to the spawned child processes, [see usage in detail below](#environment-variables). |
 | `.exec(handlerFn)` | calls a simple function in the current step |
 | `.fetch([options, ] handlerFn)` | update the local working copy database with changes from the default remote repo and branch, when supplied the options argument can be a standard [options object](#how-to-specify-options) either an array of string commands as supported by the [git fetch](https://git-scm.com/docs/git-fetch). |
@@ -197,6 +201,8 @@ For type details of the response for each of the tasks, please see the [TypeScri
 | `.revert(commit [, options [, handlerFn]])` | reverts one or more commits in the working copy. The commit can be any regular commit-ish value (hash, name or offset such as `HEAD~2`) or a range of commits (eg: `master~5..master~2`). When supplied the [options](#how-to-specify-options) argument contain any options accepted by [git-revert](https://git-scm.com/docs/git-revert). |
 | `.rm([fileA, ...], handlerFn)` | removes any number of files from source control |
 | `.rmKeepLocal([fileA, ...], handlerFn)` | removes files from source control but leaves them on disk |
+| `.stash([options, ][ handlerFn])` | Stash the working directory, optional first argument can be an array of string arguments or [options](#how-to-specify-options) object to pass to the [git stash](https://git-scm.com/docs/git-stash) command. |
+| `.stashList([options, ][handlerFn])` | Retrieves the stash list, optional first argument can be an object specifying `options.splitter` to override the default value of `;;;;`, alternatively options can be a set of arguments as supported by the `git stash list` command. |
 | `.tag(args[], handlerFn)` | Runs any supported [git tag](https://git-scm.com/docs/git-tag) commands with arguments passed as an array of strings . |
 | `.tags([options, ] handlerFn)` | list all tags, use the optional [options](#how-to-specify-options) object to set any options allows by the [git tag](https://git-scm.com/docs/git-tag) command. Tags will be sorted by semantic version number by default, for git versions 2.7 and above, use the `--sort` option to set a custom sort. |
 | `.show([options], handlerFn)` | Show various types of objects, for example the file content at a certain commit. `options` is the single value string or array of string commands you want to run |
@@ -239,6 +245,7 @@ For type details of the response for each of the tasks, please see the [TypeScri
 
 - `mirror(repoPath, [localPath, [options]])` behaves the same as the `.clone` interface with the [`--mirror` flag](https://git-scm.com/docs/git-clone#Documentation/git-clone.txt---mirror) enabled.
 
+
 ## git config
 
 - `.addConfig(key, value, append = false, scope = 'local')` add a local configuration property, when `append` is set to
@@ -254,17 +261,6 @@ For type details of the response for each of the tasks, please see the [TypeScri
 - `.listConfig()` reads the current configuration and returns a [ConfigListSummary](https://github.com/steveukx/git-js/blob/main/simple-git/src/lib/responses/ConfigList.ts)
 - `.listConfig(scope: GitConfigScope)` as with `listConfig` but returns only those items in a specified scope (note that configuration values are overlaid on top of each other to build the config `git` will actually use - to resolve the configuration you are using use `(await listConfig()).all` without the scope argument)
 
-## git diff
-
-- `.diff([ options ])` get the diff of the current repo compared to the last commit, optionally including
-  any number of other arguments supported by [git diff](https://git-scm.com/docs/git-diff) supplied as an
-  [options](#how-to-specify-options) object/array. Returns the raw `diff` output as a string.
-
-- `.diffSummary([ options ])` creates a [DiffResult](https://github.com/steveukx/git-js/blob/main/simple-git/src/lib/responses/DiffSummary.ts)
-  to summarise the diff for files in the repo. Uses the `--stat` format by default which can be overridden
-  by passing in any of the log format commands (eg: `--numstat` or `--name-stat`) as part of the optional
-  [options](#how-to-specify-options) object/array.
-
 ## git grep [examples](https://github.com/steveukx/git-js/blob/main/examples/git-grep.md)
 
 - `.grep(searchTerm)` searches for a single search term across all files in the working tree, optionally passing a standard [options](#how-to-specify-options) object of additional arguments
@@ -379,12 +375,6 @@ For type details of the response for each of the tasks, please see the [TypeScri
 - `.submoduleInit([options]` Initialises sub modules, the optional [options](#how-to-specify-options) argument can be used to pass extra options to the `git submodule init` command.
 - `.submoduleUpdate(subModuleName, [options])` Updates sub modules, can be called with a sub module name and [options](#how-to-specify-options), just the options or with no arguments
 
-## git stash
-
-- `.stash([ options ])` Stash the working directory, optional first argument can be an array of string arguments or [options](#how-to-specify-options) object to pass to the [git stash](https://git-scm.com/docs/git-stash) command.
-
-- `.stashList([ options ])` Retrieves the stash list, optional first argument can be an object in the same format as used in [git log](#git-log).
-
 ## changing the working directory [examples](https://github.com/steveukx/git-js/blob/main/examples/git-change-working-directory.md)
 
 - `.cwd(workingDirectory)` Sets the working directory for all future commands - note, this will change the working for the root instance, any chain created from the root will also be changed.
@@ -580,7 +570,7 @@ if (mergeSummary.failed) {
 With typed errors available in TypeScript
 
 ```typescript
-import { simpleGit, MergeSummary, GitResponseError } from 'simple-git';
+import simpleGit, { MergeSummary, GitResponseError } from 'simple-git';
 try {
   const mergeSummary = await simpleGit().merge();
   console.log(`Merged ${ mergeSummary.merges.length } files`);
